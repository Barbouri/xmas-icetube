   1               		.file	"iv.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
  10               		.text
  11               	.Ltext0:
  87               	.global	_Z7delaymsj
  89               	_Z7delaymsj:
  90               		.stabd	46,0,0
   1:iv.c          **** /***************************************************************************
   2:iv.c          ****  Ice Tube Clock firmware August 13, 2009
   3:iv.c          ****  (c) 2009 Limor Fried / Adafruit Industries
   4:iv.c          **** 
   5:iv.c          **** Permission is hereby granted, free of charge, to any person obtaining a copy
   6:iv.c          **** of this software and associated documentation files (the "Software"), to deal
   7:iv.c          **** in the Software without restriction, including without limitation the rights
   8:iv.c          **** to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   9:iv.c          **** copies of the Software, and to permit persons to whom the Software is
  10:iv.c          **** furnished to do so, subject to the following conditions:
  11:iv.c          **** 
  12:iv.c          **** The above copyright notice and this permission notice shall be included in
  13:iv.c          **** all copies or substantial portions of the Software.
  14:iv.c          **** 
  15:iv.c          **** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:iv.c          **** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  17:iv.c          **** FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  18:iv.c          **** AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  19:iv.c          **** LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  20:iv.c          **** OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  21:iv.c          **** THE SOFTWARE.
  22:iv.c          **** ****************************************************************************/
  23:iv.c          **** 
  24:iv.c          **** 
  25:iv.c          **** #include <avr/io.h>      
  26:iv.c          **** #include <string.h>
  27:iv.c          **** #include <avr/interrupt.h>   // Interrupts and timers
  28:iv.c          **** #include <util/delay.h>      // Blocking delay functions
  29:iv.c          **** #include <avr/pgmspace.h>    // So we can store the 'font table' in ROM
  30:iv.c          **** #include <avr/eeprom.h>      // Date/time/pref backup in permanent EEPROM
  31:iv.c          **** #include <avr/wdt.h>     // Watchdog timer to repair lockups
  32:iv.c          **** 
  33:iv.c          **** #include "iv.h"
  34:iv.c          **** #include "util.h"
  35:iv.c          **** #include "fonttable.h"
  36:iv.c          **** 
  37:iv.c          **** uint8_t region = REGION_US;
  38:iv.c          **** 
  39:iv.c          **** // These variables store the current time.
  40:iv.c          **** volatile uint8_t time_s, time_m, time_h;
  41:iv.c          **** // ... and current date
  42:iv.c          **** volatile uint8_t date_m, date_d, date_y;
  43:iv.c          **** 
  44:iv.c          **** // how loud is the speaker supposed to be?
  45:iv.c          **** volatile uint8_t volume;
  46:iv.c          **** 
  47:iv.c          **** // whether the alarm is on, going off, and alarm time
  48:iv.c          **** volatile uint8_t alarm_on, alarming, alarm_h, alarm_m;
  49:iv.c          **** 
  50:iv.c          **** // what is being displayed on the screen? (eg time, date, menu...)
  51:iv.c          **** volatile uint8_t displaymode;
  52:iv.c          **** 
  53:iv.c          **** // are we in low power sleep mode?
  54:iv.c          **** volatile uint8_t sleepmode = 0;
  55:iv.c          **** 
  56:iv.c          **** volatile uint8_t timeunknown = 0;        // MEME
  57:iv.c          **** volatile uint8_t restored = 0;
  58:iv.c          **** 
  59:iv.c          **** // Our display buffer, which is updated to show the time/date/etc
  60:iv.c          **** // and is multiplexed onto the tube
  61:iv.c          **** uint8_t display[DISPLAYSIZE]; // stores segments, not values!
  62:iv.c          **** uint8_t currdigit = 0;        // which digit we are currently multiplexing
  63:iv.c          **** 
  64:iv.c          **** // This table allow us to index between what digit we want to light up
  65:iv.c          **** // and what the pin number is on the MAX6921 see the .h for values.
  66:iv.c          **** // Stored in ROM (PROGMEM) to save RAM
  67:iv.c          **** const uint8_t digittable[] PROGMEM = {
  68:iv.c          ****   DIG_9, DIG_8, DIG_7, DIG_6, DIG_5, DIG_4, DIG_3, DIG_2, DIG_1
  69:iv.c          **** };
  70:iv.c          **** 
  71:iv.c          **** // This table allow us to index between what segment we want to light up
  72:iv.c          **** // and what the pin number is on the MAX6921 see the .h for values.
  73:iv.c          **** // Stored in ROM (PROGMEM) to save RAM
  74:iv.c          **** const uint8_t segmenttable[] PROGMEM = {
  75:iv.c          ****   SEG_H, SEG_G,  SEG_F,  SEG_E,  SEG_D,  SEG_C,  SEG_B,  SEG_A 
  76:iv.c          **** };
  77:iv.c          **** 
  78:iv.c          **** // muxdiv and MUX_DIVIDER divides down a high speed interrupt (31.25KHz)
  79:iv.c          **** // down so that we can refresh at about 100Hz (31.25KHz / 300)
  80:iv.c          **** // We refresh the entire display at 100Hz so each digit is updated
  81:iv.c          **** // 100Hz/DISPLAYSIZE
  82:iv.c          **** uint16_t muxdiv = 0;
  83:iv.c          **** #define MUX_DIVIDER (300 / DISPLAYSIZE)
  84:iv.c          **** 
  85:iv.c          **** // Likewise divides 100Hz down to 1Hz for the alarm beeping
  86:iv.c          **** uint16_t alarmdiv = 0;
  87:iv.c          **** #define ALARM_DIVIDER 100
  88:iv.c          **** 
  89:iv.c          **** // How long we have been snoozing
  90:iv.c          **** uint16_t snoozetimer = 0;
  91:iv.c          **** 
  92:iv.c          **** // We have a non-blocking delay function, milliseconds is updated by
  93:iv.c          **** // an interrupt
  94:iv.c          **** volatile uint16_t milliseconds = 0;
  95:iv.c          **** void delayms(uint16_t ms) {
  92               	.LM0:
  93               	.LFBB1:
  94               	/* prologue: function */
  95               	/* frame size = 0 */
  96               	/* stack size = 0 */
  97               	.L__stack_usage = 0
  96:iv.c          ****   sei();
  99               	.LM1:
 100               	/* #APP */
 101               	 ;  96 "iv.c" 1
 102 0000 7894      		sei
 103               	 ;  0 "" 2
  97:iv.c          **** 
  98:iv.c          ****   milliseconds = 0;
 105               	.LM2:
 106               	/* #NOAPP */
 107 0002 1092 0000 		sts milliseconds+1,__zero_reg__
 108 0006 1092 0000 		sts milliseconds,__zero_reg__
 109               	.L2:
  99:iv.c          ****   while (milliseconds < ms);
 111               	.LM3:
 112 000a 2091 0000 		lds r18,milliseconds
 113 000e 3091 0000 		lds r19,milliseconds+1
 114 0012 2817      		cp r18,r24
 115 0014 3907      		cpc r19,r25
 116 0016 00F0      		brlo .L2
 117               	/* epilogue start */
 100:iv.c          **** }
 119               	.LM4:
 120 0018 0895      		ret
 122               	.Lscope1:
 124               		.stabd	78,0,0
 126               	.global	_Z11pet_the_dogv
 128               	_Z11pet_the_dogv:
 129               		.stabd	46,0,0
 101:iv.c          **** 
 102:iv.c          **** // When the alarm is going off, pressing a button turns on snooze mode
 103:iv.c          **** // this sets the snoozetimer off in MAXSNOOZE seconds - which turns on
 104:iv.c          **** // the alarm again
 105:iv.c          **** void setsnooze(void) {
 106:iv.c          ****   //snoozetimer = eeprom_read_byte((uint8_t *)EE_SNOOZE);
 107:iv.c          ****   //snoozetimer *= 60; // convert minutes to seconds
 108:iv.c          ****   snoozetimer = MAXSNOOZE;
 109:iv.c          ****   DEBUGP("snooze");
 110:iv.c          ****   display_str("snoozing");
 111:iv.c          ****   displaymode = SHOW_SNOOZE;
 112:iv.c          ****   delayms(1000);
 113:iv.c          ****   displaymode = SHOW_TIME;
 114:iv.c          **** }
 115:iv.c          **** 
 116:iv.c          **** // we reset the watchdog timer 
 117:iv.c          **** void pet_the_dog(void) {
 131               	.LM5:
 132               	.LFBB2:
 133               	/* prologue: function */
 134               	/* frame size = 0 */
 135               	/* stack size = 0 */
 136               	.L__stack_usage = 0
 118:iv.c          ****   wdt_reset();
 138               	.LM6:
 139               	/* #APP */
 140               	 ;  118 "iv.c" 1
 141 001a A895      		wdr
 142               	 ;  0 "" 2
 143               	/* epilogue start */
 119:iv.c          **** }
 145               	.LM7:
 146               	/* #NOAPP */
 147 001c 0895      		ret
 149               	.Lscope2:
 151               		.stabd	78,0,0
 153               	.global	__vector_23
 155               	__vector_23:
 156               		.stabd	46,0,0
 120:iv.c          **** 
 121:iv.c          **** // called @ (F_CPU/256) = ~30khz (31.25 khz)
 122:iv.c          **** ISR(TIMER0_OVF_vect) {
 123:iv.c          ****   // allow other interrupts to go off while we're doing display updates
 124:iv.c          ****   sei();
 125:iv.c          **** 
 126:iv.c          ****   // kick the dog
 127:iv.c          ****   pet_the_dog();
 128:iv.c          **** 
 129:iv.c          ****   // divide down to 100Hz * digits
 130:iv.c          ****   muxdiv++;
 131:iv.c          ****   if (muxdiv < MUX_DIVIDER)
 132:iv.c          ****     return;
 133:iv.c          ****   muxdiv = 0;
 134:iv.c          ****   // now at 100Hz * digits
 135:iv.c          **** 
 136:iv.c          ****   // ok its not really 1ms but its like within 10% :)
 137:iv.c          ****   milliseconds++;
 138:iv.c          **** 
 139:iv.c          ****   // Cycle through each digit in the display
 140:iv.c          ****   if (currdigit >= DISPLAYSIZE)
 141:iv.c          ****     currdigit = 0;
 142:iv.c          **** 
 143:iv.c          ****   // Set the current display's segments
 144:iv.c          ****   setdisplay(currdigit, display[currdigit]);
 145:iv.c          ****   // and go to the next
 146:iv.c          ****   currdigit++;
 147:iv.c          **** 
 148:iv.c          ****   // check if we should have the alarm on
 149:iv.c          ****   if (alarming && !snoozetimer) {
 150:iv.c          ****     alarmdiv++;
 151:iv.c          ****     if (alarmdiv > ALARM_DIVIDER) {
 152:iv.c          ****       alarmdiv = 0;
 153:iv.c          ****     } else {
 154:iv.c          ****       return;
 155:iv.c          ****     }
 156:iv.c          ****     // This part only gets reached at 1Hz
 157:iv.c          **** 
 158:iv.c          ****     // This sets the buzzer frequency
 159:iv.c          ****     ICR1 = 250;
 160:iv.c          ****     OCR1A = OCR1B = ICR1/2;
 161:iv.c          **** 
 162:iv.c          ****     // ok alarm is ringing!
 163:iv.c          ****     if (alarming & 0xF0) { // top bit indicates pulsing alarm state
 164:iv.c          ****       alarming &= ~0xF0;
 165:iv.c          ****       TCCR1B &= ~_BV(CS11); // turn buzzer off!
 166:iv.c          ****     } else {
 167:iv.c          ****       alarming |= 0xF0;
 168:iv.c          ****       TCCR1B |= _BV(CS11); // turn buzzer on!
 169:iv.c          ****     }
 170:iv.c          ****   }
 171:iv.c          ****   
 172:iv.c          **** }
 173:iv.c          **** 
 174:iv.c          **** 
 175:iv.c          **** // We use the pin change interrupts to detect when buttons are pressed
 176:iv.c          **** 
 177:iv.c          **** // These store the current button states for all 3 buttons. We can 
 178:iv.c          **** // then query whether the buttons are pressed and released or pressed
 179:iv.c          **** // This allows for 'high speed incrementing' when setting the time
 180:iv.c          **** volatile uint8_t last_buttonstate = 0, just_pressed = 0, pressed = 0;
 181:iv.c          **** volatile uint8_t buttonholdcounter = 0;
 182:iv.c          **** 
 183:iv.c          **** // called when button 1 and 3 are pressed
 184:iv.c          **** ISR(PCINT2_vect) {
 185:iv.c          ****   PCICR = 0;
 186:iv.c          ****   // allow interrupts while we're doing this
 187:iv.c          ****   sei();
 188:iv.c          **** 
 189:iv.c          ****   if (! (PIND & _BV(BUTTON1))) {
 190:iv.c          ****     // button1 is pressed
 191:iv.c          ****     if (! (last_buttonstate & 0x1)) { // was not pressed before
 192:iv.c          ****       delayms(10);                    // debounce
 193:iv.c          ****       if (PIND & _BV(BUTTON1)) {      // filter out bounce
 194:iv.c          **** 	PCICR = _BV(PCIE0) | _BV(PCIE2);
 195:iv.c          **** 	return;
 196:iv.c          ****       }
 197:iv.c          ****       tick();                         // make a noise
 198:iv.c          ****       // check if we will snag this button press for snoozing
 199:iv.c          ****       if (alarming) {
 200:iv.c          **** 	// turn on snooze
 201:iv.c          **** 	setsnooze();
 202:iv.c          **** 	PCICR = _BV(PCIE0) | _BV(PCIE2);
 203:iv.c          **** 	return;
 204:iv.c          ****       }
 205:iv.c          ****       last_buttonstate |= 0x1;
 206:iv.c          ****       just_pressed |= 0x1;
 207:iv.c          ****       DEBUGP("b1");
 208:iv.c          ****     }
 209:iv.c          ****   } else {
 210:iv.c          ****     last_buttonstate &= ~0x1;
 211:iv.c          ****   }
 212:iv.c          **** 
 213:iv.c          ****   if (! (PIND & _BV(BUTTON3))) {
 214:iv.c          ****     // button3 is pressed
 215:iv.c          ****     if (! (last_buttonstate & 0x4)) { // was not pressed before
 216:iv.c          ****       delayms(10);                    // debounce
 217:iv.c          ****       if (PIND & _BV(BUTTON3)) {      // filter out bounces
 218:iv.c          **** 	PCICR = _BV(PCIE0) | _BV(PCIE2);
 219:iv.c          **** 	return;
 220:iv.c          ****       }
 221:iv.c          ****       buttonholdcounter = 2;          // see if we're press-and-holding
 222:iv.c          ****       while (buttonholdcounter) {
 223:iv.c          **** 	if (PIND & _BV(BUTTON3)) {        // released
 224:iv.c          **** 	  tick();                         // make a noise
 225:iv.c          **** 	  last_buttonstate &= ~0x4;
 226:iv.c          **** 	  // check if we will snag this button press for snoozing
 227:iv.c          **** 	  if (alarming) {
 228:iv.c          **** 	    // turn on snooze
 229:iv.c          **** 	    setsnooze();
 230:iv.c          **** 	    PCICR = _BV(PCIE0) | _BV(PCIE2);
 231:iv.c          **** 	    return;
 232:iv.c          **** 	  }
 233:iv.c          **** 	  DEBUGP("b3");
 234:iv.c          **** 	  just_pressed |= 0x4;
 235:iv.c          **** 	  PCICR = _BV(PCIE0) | _BV(PCIE2);
 236:iv.c          **** 	  return;
 237:iv.c          **** 	}
 238:iv.c          ****       }
 239:iv.c          ****       last_buttonstate |= 0x4;
 240:iv.c          ****       pressed |= 0x4;                 // held down
 241:iv.c          ****     }
 242:iv.c          ****   } else {
 243:iv.c          ****     pressed = 0;                      // button released
 244:iv.c          ****     last_buttonstate &= ~0x4;
 245:iv.c          ****   }
 246:iv.c          ****   PCICR = _BV(PCIE0) | _BV(PCIE2);
 247:iv.c          **** }
 248:iv.c          **** 
 249:iv.c          **** // called when button 2 is pressed
 250:iv.c          **** ISR(PCINT0_vect) {
 251:iv.c          ****   PCICR = 0;
 252:iv.c          ****   sei();
 253:iv.c          ****   if (! (PINB & _BV(BUTTON2))) {
 254:iv.c          ****     // button2 is pressed
 255:iv.c          ****     if (! (last_buttonstate & 0x2)) { // was not pressed before
 256:iv.c          ****       delayms(10);                    // debounce
 257:iv.c          ****       if (PINB & _BV(BUTTON2)) {      // filter out bounces
 258:iv.c          **** 	PCICR = _BV(PCIE0) | _BV(PCIE2);
 259:iv.c          **** 	return;
 260:iv.c          ****       }
 261:iv.c          ****       tick();                         // make a noise
 262:iv.c          ****       // check if we will snag this button press for snoozing
 263:iv.c          ****       if (alarming) {
 264:iv.c          **** 	setsnooze(); 	// turn on snooze
 265:iv.c          **** 	PCICR = _BV(PCIE0) | _BV(PCIE2);
 266:iv.c          **** 	return;
 267:iv.c          ****       }
 268:iv.c          ****       last_buttonstate |= 0x2;
 269:iv.c          ****       just_pressed |= 0x2;
 270:iv.c          ****       DEBUGP("b2");
 271:iv.c          ****     }
 272:iv.c          ****   } else {
 273:iv.c          ****     last_buttonstate &= ~0x2;
 274:iv.c          ****   }
 275:iv.c          ****   PCICR = _BV(PCIE0) | _BV(PCIE2);
 276:iv.c          **** }
 277:iv.c          **** 
 278:iv.c          **** // This variable keeps track of whether we have not pressed any
 279:iv.c          **** // buttons in a few seconds, and turns off the menu display
 280:iv.c          **** volatile uint8_t timeoutcounter = 0;
 281:iv.c          **** 
 282:iv.c          **** 
 283:iv.c          **** // called once per second when the clock timer overflows
 284:iv.c          **** ISR(TIMER2_OVF_vect) {
 285:iv.c          ****   CLKPR = _BV(CLKPCE);  //MEME
 286:iv.c          ****   CLKPR = 0;
 287:iv.c          **** 
 288:iv.c          ****   time_s++;             // one second has gone by
 289:iv.c          **** 
 290:iv.c          ****   // a minute!
 291:iv.c          ****   if (time_s >= 60) {
 292:iv.c          ****     time_s = 0;
 293:iv.c          ****     time_m++;
 294:iv.c          ****   }
 295:iv.c          **** 
 296:iv.c          ****   // an hour...
 297:iv.c          ****   if (time_m >= 60) {
 298:iv.c          ****     time_m = 0;
 299:iv.c          ****     time_h++; 
 300:iv.c          ****     // lets write the time to the EEPROM
 301:iv.c          ****     eeprom_write_byte((uint8_t *)EE_HOUR, time_h);
 302:iv.c          ****     eeprom_write_byte((uint8_t *)EE_MIN, time_m);
 303:iv.c          ****   }
 304:iv.c          **** 
 305:iv.c          ****   // a day....
 306:iv.c          ****   if (time_h >= 24) {
 307:iv.c          ****     time_h = 0;
 308:iv.c          ****     date_d++;
 309:iv.c          ****     eeprom_write_byte((uint8_t *)EE_DAY, date_d);
 310:iv.c          ****   }
 311:iv.c          **** 
 312:iv.c          ****   /*
 313:iv.c          ****   if (! sleepmode) {
 314:iv.c          ****     uart_putw_dec(time_h);
 315:iv.c          ****     uart_putchar(':');
 316:iv.c          ****     uart_putw_dec(time_m);
 317:iv.c          ****     uart_putchar(':');
 318:iv.c          ****     uart_putw_dec(time_s);
 319:iv.c          ****     putstring_nl("");
 320:iv.c          ****   }
 321:iv.c          ****   */
 322:iv.c          **** 
 323:iv.c          ****   // a full month!
 324:iv.c          ****   // we check the leapyear and date to verify when its time to roll over months
 325:iv.c          ****   if ((date_d > 31) ||
 326:iv.c          ****       ((date_d == 31) && ((date_m == 4)||(date_m == 6)||(date_m == 9)||(date_m == 11))) ||
 327:iv.c          ****       ((date_d == 30) && (date_m == 2)) ||
 328:iv.c          ****       ((date_d == 29) && (date_m == 2) && !leapyear(2000+date_y))) {
 329:iv.c          ****     date_d = 1;
 330:iv.c          ****     date_m++;
 331:iv.c          ****     eeprom_write_byte((uint8_t *)EE_MONTH, date_m);
 332:iv.c          ****   }
 333:iv.c          ****   
 334:iv.c          ****   // HAPPY NEW YEAR!
 335:iv.c          ****   if (date_m >= 13) {
 336:iv.c          ****     date_y++;
 337:iv.c          ****     date_m = 1;
 338:iv.c          ****     eeprom_write_byte((uint8_t *)EE_YEAR, date_y);
 339:iv.c          ****   }
 340:iv.c          ****   
 341:iv.c          ****   // If we're in low power mode we should get out now since the display is off
 342:iv.c          ****   if (sleepmode)
 343:iv.c          ****     return;
 344:iv.c          ****    
 345:iv.c          **** 
 346:iv.c          ****   if (displaymode == SHOW_TIME) {
 347:iv.c          ****     if (timeunknown && (time_s % 2)) {
 348:iv.c          ****       display_str("        ");
 349:iv.c          ****     } else {
 350:iv.c          ****       display_time(time_h, time_m, time_s);
 351:iv.c          ****     }
 352:iv.c          ****     if (alarm_on)
 353:iv.c          ****       display[0] |= 0x2;
 354:iv.c          ****     else 
 355:iv.c          ****       display[0] &= ~0x2;
 356:iv.c          ****     
 357:iv.c          ****   }
 358:iv.c          ****   if (alarm_on && (alarm_h == time_h) && (alarm_m == time_m) && (time_s == 0)) {
 359:iv.c          ****     DEBUGP("alarm on!");
 360:iv.c          ****     alarming = 1;
 361:iv.c          ****     snoozetimer = 0;
 362:iv.c          ****   }
 363:iv.c          **** 
 364:iv.c          ****   if (timeoutcounter)
 365:iv.c          ****     timeoutcounter--;
 366:iv.c          ****   if (buttonholdcounter)
 367:iv.c          ****     buttonholdcounter--;
 368:iv.c          ****   if (snoozetimer) {
 369:iv.c          ****     snoozetimer--;
 370:iv.c          ****     if (snoozetimer % 2) 
 371:iv.c          ****       display[0] |= 0x2;
 372:iv.c          ****     else
 373:iv.c          ****       display[0] &= ~0x2;
 374:iv.c          ****   }
 375:iv.c          **** }
 376:iv.c          **** 
 377:iv.c          **** // called when the alarm switch turns on or off
 378:iv.c          **** ISR(INT0_vect) {
 379:iv.c          ****   uart_putchar('i');
 380:iv.c          ****   uint8_t x = ALARM_PIN & _BV(ALARM);
 381:iv.c          ****   sei();
 382:iv.c          ****   delayms(10); // wait for debouncing
 383:iv.c          ****   if (x != (ALARM_PIN & _BV(ALARM)))
 384:iv.c          ****     return;
 385:iv.c          ****   setalarmstate();
 386:iv.c          **** }
 387:iv.c          **** 
 388:iv.c          **** 
 389:iv.c          **** // called when external power is lost or restored
 390:iv.c          **** ISR(ANALOG_COMP_vect) {
 158               	.LM8:
 159               	.LFBB3:
 160 001e 1F92      		push __zero_reg__
 161 0020 0F92      		push r0
 162 0022 0FB6      		in r0,__SREG__
 163 0024 0F92      		push r0
 164 0026 1124      		clr __zero_reg__
 165 0028 2F93      		push r18
 166 002a 3F93      		push r19
 167 002c 4F93      		push r20
 168 002e 5F93      		push r21
 169 0030 6F93      		push r22
 170 0032 7F93      		push r23
 171 0034 8F93      		push r24
 172 0036 9F93      		push r25
 173 0038 AF93      		push r26
 174 003a BF93      		push r27
 175 003c EF93      		push r30
 176 003e FF93      		push r31
 177               	/* prologue: Signal */
 178               	/* frame size = 0 */
 179               	/* stack size = 15 */
 180               	.L__stack_usage = 15
 181               	.LBB59:
 391:iv.c          ****   //DEBUGP("COMP");
 392:iv.c          ****   if (ACSR & _BV(ACO)) {
 183               	.LM9:
 184 0040 00B6      		in __tmp_reg__,80-32
 185 0042 05FE      		sbrs __tmp_reg__,5
 186 0044 00C0      		rjmp .L6
 187               	.LBB60:
 393:iv.c          ****     //DEBUGP("HIGH");
 394:iv.c          ****     if (!sleepmode) {
 189               	.LM10:
 190 0046 8091 0000 		lds r24,sleepmode
 191 004a 8823      		tst r24
 192 004c 01F0      		breq .+2
 193 004e 00C0      		rjmp .L5
 194               	.LBB61:
 395:iv.c          ****       VFDSWITCH_PORT |= _BV(VFDSWITCH); // turn off display
 196               	.LM11:
 197 0050 5B9A      		sbi 43-32,3
 396:iv.c          ****       VFDCLK_PORT &= ~_BV(VFDCLK) & ~_BV(VFDDATA); // no power to vfdchip
 199               	.LM12:
 200 0052 85B1      		in r24,37-32
 201 0054 877D      		andi r24,lo8(-41)
 202 0056 85B9      		out 37-32,r24
 397:iv.c          ****       BOOST_PORT &= ~_BV(BOOST); // pull boost fet low
 204               	.LM13:
 205 0058 5E98      		cbi 43-32,6
 398:iv.c          ****       SPCR  &= ~_BV(SPE); // turn off spi
 207               	.LM14:
 208 005a 8CB5      		in r24,76-32
 209 005c 8F7B      		andi r24,lo8(-65)
 210 005e 8CBD      		out 76-32,r24
 399:iv.c          ****       if (restored) {
 212               	.LM15:
 213 0060 8091 0000 		lds r24,restored
 214 0064 8823      		tst r24
 215 0066 01F0      		breq .L8
 400:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_MIN, time_m);
 217               	.LM16:
 218 0068 6091 0000 		lds r22,time_m
 219 006c 85E0      		ldi r24,lo8(5)
 220 006e 90E0      		ldi r25,hi8(5)
 221 0070 0E94 0000 		call __eewr_byte_m328p
 401:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_SEC, time_s);
 223               	.LM17:
 224 0074 6091 0000 		lds r22,time_s
 225 0078 86E0      		ldi r24,lo8(6)
 226 007a 90E0      		ldi r25,hi8(6)
 227 007c 0E94 0000 		call __eewr_byte_m328p
 228               	.L8:
 229               	.LBB62:
 402:iv.c          ****       }
 403:iv.c          ****       DEBUGP("z");
 231               	.LM18:
 232 0080 80E0      		ldi r24,lo8(_ZZ11__vector_23E3__c)
 233 0082 90E0      		ldi r25,hi8(_ZZ11__vector_23E3__c)
 234 0084 61E0      		ldi r22,lo8(1)
 235 0086 0E94 0000 		call _Z13ROM_putstringPKch
 236               	.LBE62:
 404:iv.c          ****       TCCR0B = 0; // no boost
 238               	.LM19:
 239 008a 15BC      		out 69-32,__zero_reg__
 405:iv.c          ****       volume = 0; // low power buzzer
 241               	.LM20:
 242 008c 1092 0000 		sts volume,__zero_reg__
 406:iv.c          ****       PCICR = 0;  // ignore buttons
 244               	.LM21:
 245 0090 1092 6800 		sts 104,__zero_reg__
 246 0094 00C0      		rjmp .L10
 247               	.L6:
 248               	.LBE61:
 249               	.LBE60:
 250               	.LBB63:
 407:iv.c          **** 
 408:iv.c          ****       app_start();
 409:iv.c          ****     }
 410:iv.c          ****   } else {
 411:iv.c          ****     //DEBUGP("LOW");
 412:iv.c          ****     if (sleepmode) {
 252               	.LM22:
 253 0096 8091 0000 		lds r24,sleepmode
 254 009a 8823      		tst r24
 255 009c 01F0      		breq .L5
 256               	.LBB64:
 413:iv.c          ****       if (restored) {
 258               	.LM23:
 259 009e 8091 0000 		lds r24,restored
 260 00a2 8823      		tst r24
 261 00a4 01F0      		breq .L9
 414:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_MIN, time_m);
 263               	.LM24:
 264 00a6 6091 0000 		lds r22,time_m
 265 00aa 85E0      		ldi r24,lo8(5)
 266 00ac 90E0      		ldi r25,hi8(5)
 267 00ae 0E94 0000 		call __eewr_byte_m328p
 415:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_SEC, time_s);
 269               	.LM25:
 270 00b2 6091 0000 		lds r22,time_s
 271 00b6 86E0      		ldi r24,lo8(6)
 272 00b8 90E0      		ldi r25,hi8(6)
 273 00ba 0E94 0000 		call __eewr_byte_m328p
 274               	.L9:
 275               	.LBB65:
 416:iv.c          ****       }
 417:iv.c          ****       DEBUGP("WAKERESET"); 
 277               	.LM26:
 278 00be 80E0      		ldi r24,lo8(_ZZ11__vector_23E3__c_0)
 279 00c0 90E0      		ldi r25,hi8(_ZZ11__vector_23E3__c_0)
 280 00c2 61E0      		ldi r22,lo8(1)
 281 00c4 0E94 0000 		call _Z13ROM_putstringPKch
 282               	.L10:
 283               	.LBE65:
 418:iv.c          ****       app_start();
 285               	.LM27:
 286 00c8 E091 0000 		lds r30,app_start
 287 00cc F091 0000 		lds r31,app_start+1
 288 00d0 0995      		icall
 289               	.L5:
 290               	/* epilogue start */
 291               	.LBE64:
 292               	.LBE63:
 293               	.LBE59:
 419:iv.c          ****     }
 420:iv.c          ****   }
 421:iv.c          **** }
 295               	.LM28:
 296 00d2 FF91      		pop r31
 297 00d4 EF91      		pop r30
 298 00d6 BF91      		pop r27
 299 00d8 AF91      		pop r26
 300 00da 9F91      		pop r25
 301 00dc 8F91      		pop r24
 302 00de 7F91      		pop r23
 303 00e0 6F91      		pop r22
 304 00e2 5F91      		pop r21
 305 00e4 4F91      		pop r20
 306 00e6 3F91      		pop r19
 307 00e8 2F91      		pop r18
 308 00ea 0F90      		pop r0
 309 00ec 0FBE      		out __SREG__,r0
 310 00ee 0F90      		pop r0
 311 00f0 1F90      		pop __zero_reg__
 312 00f2 1895      		reti
 314               	.Lscope3:
 316               		.stabd	78,0,0
 318               	.global	_Z9gotosleepv
 320               	_Z9gotosleepv:
 321               		.stabd	46,0,0
 422:iv.c          **** /*********************** Main app **********/
 423:iv.c          **** 
 424:iv.c          **** uint32_t t;
 425:iv.c          **** 
 426:iv.c          **** void gotosleep(void) {
 323               	.LM29:
 324               	.LFBB4:
 325               	/* prologue: function */
 326               	/* frame size = 0 */
 327               	/* stack size = 0 */
 328               	.L__stack_usage = 0
 427:iv.c          ****   // battery
 428:iv.c          ****   //if (sleepmode) //already asleep?
 429:iv.c          ****   //  return;
 430:iv.c          ****   //DEBUGP("sleeptime");
 431:iv.c          ****   
 432:iv.c          ****   sleepmode = 1;
 330               	.LM30:
 331 00f4 81E0      		ldi r24,lo8(1)
 332 00f6 8093 0000 		sts sleepmode,r24
 433:iv.c          ****   VFDSWITCH_PORT |= _BV(VFDSWITCH); // turn off display
 334               	.LM31:
 335 00fa 5B9A      		sbi 43-32,3
 434:iv.c          ****   SPCR  &= ~_BV(SPE); // turn off spi
 337               	.LM32:
 338 00fc 8CB5      		in r24,76-32
 339 00fe 8F7B      		andi r24,lo8(-65)
 340 0100 8CBD      		out 76-32,r24
 435:iv.c          ****   VFDCLK_PORT &= ~_BV(VFDCLK) & ~_BV(VFDDATA); // no power to vfdchip
 342               	.LM33:
 343 0102 85B1      		in r24,37-32
 344 0104 877D      		andi r24,lo8(-41)
 345 0106 85B9      		out 37-32,r24
 436:iv.c          ****   BOOST_PORT &= ~_BV(BOOST); // pull boost fet low
 347               	.LM34:
 348 0108 5E98      		cbi 43-32,6
 437:iv.c          ****   TCCR0B = 0; // no boost
 350               	.LM35:
 351 010a 15BC      		out 69-32,__zero_reg__
 438:iv.c          ****   volume = 0; // low power buzzer
 353               	.LM36:
 354 010c 1092 0000 		sts volume,__zero_reg__
 439:iv.c          ****   PCICR = 0;  // ignore buttons
 356               	.LM37:
 357 0110 1092 6800 		sts 104,__zero_reg__
 440:iv.c          **** 
 441:iv.c          ****   // sleep time!
 442:iv.c          ****   //beep(3520, 1);
 443:iv.c          ****   //beep(1760, 1);
 444:iv.c          ****   //beep(880, 1);
 445:iv.c          ****   // turn beeper off
 446:iv.c          ****   PORTB &= ~_BV(SPK1) & ~_BV(SPK2); 
 359               	.LM38:
 360 0114 85B1      		in r24,37-32
 361 0116 897F      		andi r24,lo8(-7)
 362 0118 85B9      		out 37-32,r24
 447:iv.c          ****   
 448:iv.c          ****   // turn off pullups
 449:iv.c          ****   PORTD &= ~_BV(BUTTON1) & ~_BV(BUTTON3);
 364               	.LM39:
 365 011a 8BB1      		in r24,43-32
 366 011c 8F7C      		andi r24,lo8(-49)
 367 011e 8BB9      		out 43-32,r24
 450:iv.c          ****   PORTB &= ~_BV(BUTTON2);
 369               	.LM40:
 370 0120 2898      		cbi 37-32,0
 451:iv.c          ****   DDRD &= ~_BV(BUTTON1) & ~_BV(BUTTON3);
 372               	.LM41:
 373 0122 8AB1      		in r24,42-32
 374 0124 8F7C      		andi r24,lo8(-49)
 375 0126 8AB9      		out 42-32,r24
 452:iv.c          ****   DDRB &= ~_BV(BUTTON2);
 377               	.LM42:
 378 0128 2098      		cbi 36-32,0
 453:iv.c          ****   ALARM_PORT &= ~_BV(ALARM);
 380               	.LM43:
 381 012a 5A98      		cbi 43-32,2
 454:iv.c          ****   ALARM_DDR &= ~_BV(ALARM);
 383               	.LM44:
 384 012c 5298      		cbi 42-32,2
 455:iv.c          ****   
 456:iv.c          **** 
 457:iv.c          ****   // reduce the clock speed
 458:iv.c          ****   CLKPR = _BV(CLKPCE);
 386               	.LM45:
 387 012e E1E6      		ldi r30,lo8(97)
 388 0130 F0E0      		ldi r31,hi8(97)
 389 0132 90E8      		ldi r25,lo8(-128)
 390 0134 9083      		st Z,r25
 459:iv.c          ****   CLKPR = _BV(CLKPS3);
 392               	.LM46:
 393 0136 88E0      		ldi r24,lo8(8)
 394 0138 8083      		st Z,r24
 460:iv.c          ****   
 461:iv.c          ****   //  PPR |= _BV(PRUSART0) | _BV(PRADC) | _BV(PRSPI) | _BV(PRTIM1) | _BV(PRTIM0) | _BV(PRTWI);
 462:iv.c          ****   PORTC |= _BV(4);  // sleep signal
 396               	.LM47:
 397 013a 449A      		sbi 40-32,4
 463:iv.c          ****   SMCR |= _BV(SM1) | _BV(SM0) | _BV(SE); // sleep mode
 399               	.LM48:
 400 013c 83B7      		in r24,83-32
 401 013e 8760      		ori r24,lo8(7)
 402 0140 83BF      		out 83-32,r24
 464:iv.c          ****   asm("sleep"); 
 404               	.LM49:
 405               	/* #APP */
 406               	 ;  464 "iv.c" 1
 407 0142 8895      		sleep
 408               	 ;  0 "" 2
 465:iv.c          ****   CLKPR = _BV(CLKPCE);
 410               	.LM50:
 411               	/* #NOAPP */
 412 0144 9083      		st Z,r25
 466:iv.c          ****   CLKPR = 0;
 414               	.LM51:
 415 0146 1082      		st Z,__zero_reg__
 467:iv.c          ****   PORTC &= ~_BV(4);
 417               	.LM52:
 418 0148 4498      		cbi 40-32,4
 419               	/* epilogue start */
 468:iv.c          **** }
 421               	.LM53:
 422 014a 0895      		ret
 424               	.Lscope4:
 426               		.stabd	78,0,0
 428               	.global	_Z11initbuttonsv
 430               	_Z11initbuttonsv:
 431               		.stabd	46,0,0
 469:iv.c          ****  
 470:iv.c          ****  void wakeup(void) {
 471:iv.c          ****    if (!sleepmode)
 472:iv.c          ****      return;
 473:iv.c          ****    CLKPR = _BV(CLKPCE);
 474:iv.c          ****    CLKPR = 0;
 475:iv.c          ****    DEBUGP("waketime");
 476:iv.c          ****    sleepmode = 0;
 477:iv.c          ****    // plugged in
 478:iv.c          ****    // wait to verify
 479:iv.c          ****    _delay_ms(20);
 480:iv.c          ****    if (ACSR & _BV(ACO)) 
 481:iv.c          ****      return;
 482:iv.c          ****    
 483:iv.c          ****    // turn on pullups
 484:iv.c          ****    initbuttons();
 485:iv.c          **** 
 486:iv.c          ****    // turn on boost
 487:iv.c          ****    boost_init(eeprom_read_byte((uint8_t *)EE_BRIGHT));
 488:iv.c          **** 
 489:iv.c          ****    // turn on vfd control
 490:iv.c          ****    vfd_init();
 491:iv.c          **** 
 492:iv.c          ****    // turn on display
 493:iv.c          ****    VFDSWITCH_PORT &= ~_BV(VFDSWITCH); 
 494:iv.c          ****    VFDBLANK_PORT &= ~_BV(VFDBLANK);
 495:iv.c          ****    volume = eeprom_read_byte((uint8_t *)EE_VOLUME); // reset
 496:iv.c          ****    
 497:iv.c          ****    speaker_init();
 498:iv.c          **** 
 499:iv.c          ****    pet_the_dog();
 500:iv.c          **** 
 501:iv.c          ****    setalarmstate();
 502:iv.c          **** 
 503:iv.c          ****    // wake up sound
 504:iv.c          ****    beep(880, 1);
 505:iv.c          ****    beep(1760, 1);
 506:iv.c          ****    beep(3520, 1);
 507:iv.c          **** 
 508:iv.c          ****    pet_the_dog();
 509:iv.c          ****  }
 510:iv.c          **** 
 511:iv.c          **** 
 512:iv.c          **** void initbuttons(void) {
 433               	.LM54:
 434               	.LFBB5:
 435               	/* prologue: function */
 436               	/* frame size = 0 */
 437               	/* stack size = 0 */
 438               	.L__stack_usage = 0
 513:iv.c          ****     DDRB =  _BV(VFDCLK) | _BV(VFDDATA) | _BV(SPK1) | _BV(SPK2);
 440               	.LM55:
 441 014c 8EE2      		ldi r24,lo8(46)
 442 014e 84B9      		out 36-32,r24
 514:iv.c          ****     DDRD = _BV(BOOST) | _BV(VFDSWITCH);
 444               	.LM56:
 445 0150 88E4      		ldi r24,lo8(72)
 446 0152 8AB9      		out 42-32,r24
 515:iv.c          ****     DDRC = _BV(VFDLOAD) | _BV(VFDBLANK) | _BV(4);
 448               	.LM57:
 449 0154 89E1      		ldi r24,lo8(25)
 450 0156 87B9      		out 39-32,r24
 516:iv.c          ****     PORTD = _BV(BUTTON1) | _BV(BUTTON3) | _BV(ALARM);
 452               	.LM58:
 453 0158 84E3      		ldi r24,lo8(52)
 454 015a 8BB9      		out 43-32,r24
 517:iv.c          ****     PORTB = _BV(BUTTON2);
 456               	.LM59:
 457 015c 81E0      		ldi r24,lo8(1)
 458 015e 85B9      		out 37-32,r24
 518:iv.c          **** 
 519:iv.c          ****     PCICR = _BV(PCIE0) | _BV(PCIE2);
 460               	.LM60:
 461 0160 95E0      		ldi r25,lo8(5)
 462 0162 9093 6800 		sts 104,r25
 520:iv.c          ****     PCMSK0 = _BV(PCINT0);
 464               	.LM61:
 465 0166 8093 6B00 		sts 107,r24
 521:iv.c          ****     PCMSK2 = _BV(PCINT21) | _BV(PCINT20);    
 467               	.LM62:
 468 016a 80E3      		ldi r24,lo8(48)
 469 016c 8093 6D00 		sts 109,r24
 470               	/* epilogue start */
 522:iv.c          **** }
 472               	.LM63:
 473 0170 0895      		ret
 475               	.Lscope5:
 477               		.stabd	78,0,0
 479               	.global	_Z10clock_initv
 481               	_Z10clock_initv:
 482               		.stabd	46,0,0
 523:iv.c          **** 
 524:iv.c          **** 
 525:iv.c          **** 
 526:iv.c          **** int main(void) {
 527:iv.c          ****   //  uint8_t i;
 528:iv.c          ****   uint8_t mcustate;
 529:iv.c          **** 
 530:iv.c          ****   // turn boost off
 531:iv.c          ****   TCCR0B = 0;
 532:iv.c          ****   BOOST_DDR |= _BV(BOOST);
 533:iv.c          ****   BOOST_PORT &= ~_BV(BOOST); // pull boost fet low
 534:iv.c          **** 
 535:iv.c          ****   // check if we were reset
 536:iv.c          ****   mcustate = MCUSR;
 537:iv.c          ****   MCUSR = 0;
 538:iv.c          **** 
 539:iv.c          ****   uart_putw_hex(mcustate);
 540:iv.c          **** 
 541:iv.c          ****   wdt_disable();
 542:iv.c          ****   // now turn it back on... 2 second time out
 543:iv.c          ****   //WDTCSR |= _BV(WDP0) | _BV(WDP1) | _BV(WDP2);
 544:iv.c          ****   //WDTCSR = _BV(WDE);
 545:iv.c          ****   wdt_enable(WDTO_2S);
 546:iv.c          ****   pet_the_dog();
 547:iv.c          **** 
 548:iv.c          ****   // we lost power at some point so lets alert the user
 549:iv.c          ****   // that the time may be wrong (the clock still works)
 550:iv.c          ****   timeunknown = 1;
 551:iv.c          **** 
 552:iv.c          ****   // have we read the time & date from eeprom?
 553:iv.c          ****   restored = 0;
 554:iv.c          **** 
 555:iv.c          ****   // setup uart
 556:iv.c          ****   uart_init(BRRL_192);
 557:iv.c          ****   //DEBUGP("VFD Clock");
 558:iv.c          ****   DEBUGP("!");
 559:iv.c          **** 
 560:iv.c          ****   //DEBUGP("turning on anacomp");
 561:iv.c          ****   // set up analog comparator
 562:iv.c          ****   ACSR = _BV(ACBG) | _BV(ACIE); // use bandgap, intr. on toggle!
 563:iv.c          ****   _delay_ms(1);
 564:iv.c          ****   // settle!
 565:iv.c          ****   if (ACSR & _BV(ACO)) {
 566:iv.c          ****     // hmm we should not interrupt here
 567:iv.c          ****     ACSR |= _BV(ACI);
 568:iv.c          **** 
 569:iv.c          ****     // even in low power mode, we run the clock 
 570:iv.c          ****     DEBUGP("clock init");
 571:iv.c          ****     clock_init();  
 572:iv.c          **** 
 573:iv.c          ****   } else {
 574:iv.c          ****     // we aren't in low power mode so init stuff
 575:iv.c          **** 
 576:iv.c          ****     // init io's
 577:iv.c          ****     initbuttons();
 578:iv.c          ****     
 579:iv.c          ****     VFDSWITCH_PORT &= ~_BV(VFDSWITCH);
 580:iv.c          ****     
 581:iv.c          ****     DEBUGP("turning on buttons");
 582:iv.c          ****     // set up button interrupts
 583:iv.c          ****     DEBUGP("turning on alarmsw");
 584:iv.c          ****     // set off an interrupt if alarm is set or unset
 585:iv.c          ****     EICRA = _BV(ISC00);
 586:iv.c          ****     EIMSK = _BV(INT0);
 587:iv.c          ****   
 588:iv.c          ****     displaymode = SHOW_TIME;
 589:iv.c          ****     DEBUGP("vfd init");
 590:iv.c          ****     vfd_init();
 591:iv.c          ****     
 592:iv.c          ****     DEBUGP("boost init");
 593:iv.c          ****     boost_init(eeprom_read_byte((uint8_t *)EE_BRIGHT));
 594:iv.c          ****     sei();
 595:iv.c          **** 
 596:iv.c          ****     region = eeprom_read_byte((uint8_t *)EE_REGION);
 597:iv.c          ****     
 598:iv.c          ****     DEBUGP("speaker init");
 599:iv.c          ****     speaker_init();
 600:iv.c          **** 
 601:iv.c          ****     beep(4000, 1);
 602:iv.c          **** 
 603:iv.c          ****     DEBUGP("clock init");
 604:iv.c          ****     clock_init();  
 605:iv.c          **** 
 606:iv.c          ****     DEBUGP("alarm init");
 607:iv.c          ****     setalarmstate();
 608:iv.c          ****   }
 609:iv.c          ****   DEBUGP("done");
 610:iv.c          ****   while (1) {
 611:iv.c          ****     //_delay_ms(100);
 612:iv.c          ****     pet_the_dog();
 613:iv.c          ****     //uart_putc_hex(ACSR);
 614:iv.c          ****     if (ACSR & _BV(ACO)) {
 615:iv.c          ****       // DEBUGP("SLEEPYTIME");
 616:iv.c          ****       gotosleep();
 617:iv.c          ****       continue;
 618:iv.c          ****     }
 619:iv.c          ****     //DEBUGP(".");
 620:iv.c          ****     if (just_pressed & 0x1) {
 621:iv.c          ****       just_pressed = 0;
 622:iv.c          ****       switch(displaymode) {
 623:iv.c          ****       case (SHOW_TIME):
 624:iv.c          **** 	displaymode = SET_ALARM;
 625:iv.c          **** 	display_str("set alarm");
 626:iv.c          **** 	set_alarm();
 627:iv.c          **** 	break;
 628:iv.c          ****       case (SET_ALARM):
 629:iv.c          **** 	displaymode = SET_TIME;
 630:iv.c          **** 	display_str("set time");
 631:iv.c          **** 	set_time();
 632:iv.c          **** 	timeunknown = 0;
 633:iv.c          **** 	break;
 634:iv.c          ****       case (SET_TIME):
 635:iv.c          **** 	displaymode = SET_DATE;
 636:iv.c          **** 	display_str("set date");
 637:iv.c          **** 	set_date();
 638:iv.c          **** 	break;
 639:iv.c          ****       case (SET_DATE):
 640:iv.c          **** 	displaymode = SET_BRIGHTNESS;
 641:iv.c          **** 	display_str("set brit");
 642:iv.c          **** 	set_brightness();
 643:iv.c          **** 	break;
 644:iv.c          ****       case (SET_BRIGHTNESS):
 645:iv.c          **** 	displaymode = SET_VOLUME;
 646:iv.c          **** 	display_str("set vol ");
 647:iv.c          **** 	set_volume();
 648:iv.c          **** 	break;
 649:iv.c          ****       case (SET_VOLUME):
 650:iv.c          **** 	displaymode = SET_REGION;
 651:iv.c          **** 	display_str("set regn");
 652:iv.c          **** 	set_region();
 653:iv.c          **** 	break;
 654:iv.c          **** 	/*
 655:iv.c          ****       case (SET_REGION):
 656:iv.c          **** 	displaymode = SET_SNOOZE;
 657:iv.c          **** 	display_str("set snoz");
 658:iv.c          **** 	set_snooze();
 659:iv.c          **** 	break;
 660:iv.c          **** 	*/
 661:iv.c          ****       default:
 662:iv.c          **** 	displaymode = SHOW_TIME;
 663:iv.c          ****       }
 664:iv.c          ****     } else if ((just_pressed & 0x2) || (just_pressed & 0x4)) {
 665:iv.c          ****       just_pressed = 0;
 666:iv.c          ****       displaymode = NONE;
 667:iv.c          ****       display_date(DAY);
 668:iv.c          **** 
 669:iv.c          ****       pet_the_dog();
 670:iv.c          ****       delayms(1500);
 671:iv.c          ****       pet_the_dog();
 672:iv.c          **** 
 673:iv.c          ****       displaymode = SHOW_TIME;     
 674:iv.c          ****     } 
 675:iv.c          ****   }
 676:iv.c          **** }
 677:iv.c          **** 
 678:iv.c          **** /**************************** SUB-MENUS *****************************/
 679:iv.c          **** 
 680:iv.c          **** void set_alarm(void) 
 681:iv.c          **** {
 682:iv.c          ****   uint8_t mode;
 683:iv.c          ****   uint8_t hour, min, sec;
 684:iv.c          ****     
 685:iv.c          ****   hour = min = sec = 0;
 686:iv.c          ****   mode = SHOW_MENU;
 687:iv.c          **** 
 688:iv.c          ****   hour = alarm_h;
 689:iv.c          ****   min = alarm_m;
 690:iv.c          ****   sec = 0;
 691:iv.c          ****   
 692:iv.c          ****   timeoutcounter = INACTIVITYTIMEOUT;
 693:iv.c          ****   
 694:iv.c          ****   while (1) {
 695:iv.c          ****     if (just_pressed & 0x1) { // mode change
 696:iv.c          ****       return;
 697:iv.c          ****     }
 698:iv.c          ****     if (just_pressed || pressed) {
 699:iv.c          ****       timeoutcounter = INACTIVITYTIMEOUT;  
 700:iv.c          ****       // timeout w/no buttons pressed after 3 seconds?
 701:iv.c          ****     } else if (!timeoutcounter) {
 702:iv.c          ****       //timed out!
 703:iv.c          ****       displaymode = SHOW_TIME;     
 704:iv.c          ****       alarm_h = hour;
 705:iv.c          ****       alarm_m = min;
 706:iv.c          ****       eeprom_write_byte((uint8_t *)EE_ALARM_HOUR, alarm_h);    
 707:iv.c          ****       eeprom_write_byte((uint8_t *)EE_ALARM_MIN, alarm_m);    
 708:iv.c          ****       return;
 709:iv.c          ****     }
 710:iv.c          ****     if (just_pressed & 0x2) {
 711:iv.c          ****       just_pressed = 0;
 712:iv.c          ****       if (mode == SHOW_MENU) {
 713:iv.c          **** 	// ok now its selected
 714:iv.c          **** 	mode = SET_HOUR;
 715:iv.c          **** 	display_alarm(hour, min);
 716:iv.c          **** 	display[1] |= 0x1;
 717:iv.c          **** 	display[2] |= 0x1;	
 718:iv.c          ****       } else if (mode == SET_HOUR) {
 719:iv.c          **** 	mode = SET_MIN;
 720:iv.c          **** 	display_alarm(hour, min);
 721:iv.c          **** 	display[4] |= 0x1;
 722:iv.c          **** 	display[5] |= 0x1;
 723:iv.c          ****       } else {
 724:iv.c          **** 	// done!
 725:iv.c          **** 	alarm_h = hour;
 726:iv.c          **** 	alarm_m = min;
 727:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_ALARM_HOUR, alarm_h);    
 728:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_ALARM_MIN, alarm_m);    
 729:iv.c          **** 	displaymode = SHOW_TIME;
 730:iv.c          **** 	return;
 731:iv.c          ****       }
 732:iv.c          ****     }
 733:iv.c          ****     if ((just_pressed & 0x4) || (pressed & 0x4)) {
 734:iv.c          ****       just_pressed = 0;
 735:iv.c          **** 
 736:iv.c          ****       if (mode == SET_HOUR) {
 737:iv.c          **** 	hour = (hour+1) % 24;
 738:iv.c          **** 	display_alarm(hour, min);
 739:iv.c          **** 	display[1] |= 0x1;
 740:iv.c          **** 	display[2] |= 0x1;
 741:iv.c          ****       }
 742:iv.c          ****       if (mode == SET_MIN) {
 743:iv.c          **** 	min = (min+1) % 60;
 744:iv.c          **** 	display_alarm(hour, min);
 745:iv.c          **** 	display[4] |= 0x1;
 746:iv.c          **** 	display[5] |= 0x1;
 747:iv.c          ****       }
 748:iv.c          **** 
 749:iv.c          ****       if (pressed & 0x4)
 750:iv.c          **** 	delayms(75);
 751:iv.c          ****     }
 752:iv.c          ****   }
 753:iv.c          **** }
 754:iv.c          **** 
 755:iv.c          **** void set_time(void) 
 756:iv.c          **** {
 757:iv.c          ****   uint8_t mode;
 758:iv.c          ****   uint8_t hour, min, sec;
 759:iv.c          ****     
 760:iv.c          ****   hour = time_h;
 761:iv.c          ****   min = time_m;
 762:iv.c          ****   sec = time_s;
 763:iv.c          ****   mode = SHOW_MENU;
 764:iv.c          **** 
 765:iv.c          ****   timeoutcounter = INACTIVITYTIMEOUT;
 766:iv.c          ****   
 767:iv.c          ****   while (1) {
 768:iv.c          ****     if (just_pressed & 0x1) { // mode change
 769:iv.c          ****       return;
 770:iv.c          ****     }
 771:iv.c          ****     if (just_pressed || pressed) {
 772:iv.c          ****       timeoutcounter = INACTIVITYTIMEOUT;  
 773:iv.c          ****       // timeout w/no buttons pressed after 3 seconds?
 774:iv.c          ****     } else if (!timeoutcounter) {
 775:iv.c          ****       //timed out!
 776:iv.c          ****       displaymode = SHOW_TIME;     
 777:iv.c          ****       return;
 778:iv.c          ****     }
 779:iv.c          ****     if (just_pressed & 0x2) {
 780:iv.c          ****       just_pressed = 0;
 781:iv.c          ****       if (mode == SHOW_MENU) {
 782:iv.c          **** 	hour = time_h;
 783:iv.c          **** 	min = time_m;
 784:iv.c          **** 	sec = time_s;
 785:iv.c          **** 
 786:iv.c          **** 	// ok now its selected
 787:iv.c          **** 	mode = SET_HOUR;
 788:iv.c          **** 	display_time(hour, min, sec);
 789:iv.c          **** 	display[1] |= 0x1;
 790:iv.c          **** 	display[2] |= 0x1;	
 791:iv.c          ****       } else if (mode == SET_HOUR) {
 792:iv.c          **** 	mode = SET_MIN;
 793:iv.c          **** 	display_time(hour, min, sec);
 794:iv.c          **** 	display[4] |= 0x1;
 795:iv.c          **** 	display[5] |= 0x1;
 796:iv.c          ****       } else if (mode == SET_MIN) {
 797:iv.c          **** 	mode = SET_SEC;
 798:iv.c          **** 	display_time(hour, min, sec);
 799:iv.c          **** 	display[7] |= 0x1;
 800:iv.c          **** 	display[8] |= 0x1;
 801:iv.c          ****       } else {
 802:iv.c          **** 	// done!
 803:iv.c          **** 	time_h = hour;
 804:iv.c          **** 	time_m = min;
 805:iv.c          **** 	time_s = sec;
 806:iv.c          **** 	displaymode = SHOW_TIME;
 807:iv.c          **** 	return;
 808:iv.c          ****       }
 809:iv.c          ****     }
 810:iv.c          ****     if ((just_pressed & 0x4) || (pressed & 0x4)) {
 811:iv.c          ****       just_pressed = 0;
 812:iv.c          ****       
 813:iv.c          ****       if (mode == SET_HOUR) {
 814:iv.c          **** 	hour = (hour+1) % 24;
 815:iv.c          **** 	display_time(hour, min, sec);
 816:iv.c          **** 	display[1] |= 0x1;
 817:iv.c          **** 	display[2] |= 0x1;
 818:iv.c          **** 	time_h = hour;
 819:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_HOUR, time_h);    
 820:iv.c          ****       }
 821:iv.c          ****       if (mode == SET_MIN) {
 822:iv.c          **** 	min = (min+1) % 60;
 823:iv.c          **** 	display_time(hour, min, sec);
 824:iv.c          **** 	display[4] |= 0x1;
 825:iv.c          **** 	display[5] |= 0x1;
 826:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_MIN, time_m);
 827:iv.c          **** 	time_m = min;
 828:iv.c          ****       }
 829:iv.c          ****       if ((mode == SET_SEC) ) {
 830:iv.c          **** 	sec = (sec+1) % 60;
 831:iv.c          **** 	display_time(hour, min, sec);
 832:iv.c          **** 	display[7] |= 0x1;
 833:iv.c          **** 	display[8] |= 0x1;
 834:iv.c          **** 	time_s = sec;
 835:iv.c          ****       }
 836:iv.c          ****       
 837:iv.c          ****       if (pressed & 0x4)
 838:iv.c          **** 	delayms(75);
 839:iv.c          ****     }
 840:iv.c          ****   }
 841:iv.c          **** }
 842:iv.c          **** 
 843:iv.c          **** 
 844:iv.c          **** 
 845:iv.c          **** void set_date(void) {
 846:iv.c          ****   uint8_t mode = SHOW_MENU;
 847:iv.c          **** 
 848:iv.c          ****   timeoutcounter = INACTIVITYTIMEOUT;;  
 849:iv.c          **** 
 850:iv.c          ****   while (1) {
 851:iv.c          ****     if (just_pressed || pressed) {
 852:iv.c          ****       timeoutcounter = INACTIVITYTIMEOUT;;  
 853:iv.c          ****       // timeout w/no buttons pressed after 3 seconds?
 854:iv.c          ****     } else if (!timeoutcounter) {
 855:iv.c          ****       //timed out!
 856:iv.c          ****       displaymode = SHOW_TIME;     
 857:iv.c          ****       return;
 858:iv.c          ****     }
 859:iv.c          ****     if (just_pressed & 0x1) { // mode change
 860:iv.c          ****       return;
 861:iv.c          ****     }
 862:iv.c          ****     if (just_pressed & 0x2) {
 863:iv.c          **** 
 864:iv.c          ****       just_pressed = 0;
 865:iv.c          ****       if (mode == SHOW_MENU) {
 866:iv.c          **** 	// start!
 867:iv.c          **** 	if (region == REGION_US) {
 868:iv.c          **** 	  mode = SET_MONTH;
 869:iv.c          **** 	}
 870:iv.c          **** 	else {
 871:iv.c          **** 	  DEBUGP("Set day");
 872:iv.c          **** 	  mode = SET_DAY;
 873:iv.c          **** 	}
 874:iv.c          **** 	display_date(DATE);
 875:iv.c          **** 	display[1] |= 0x1;
 876:iv.c          **** 	display[2] |= 0x1;
 877:iv.c          ****       } else if (((mode == SET_MONTH) && (region == REGION_US)) ||
 878:iv.c          **** 		 ((mode == SET_DAY) && (region == REGION_EU))) {
 879:iv.c          **** 	if (region == REGION_US)
 880:iv.c          **** 	  mode = SET_DAY;
 881:iv.c          **** 	else
 882:iv.c          **** 	  mode = SET_MONTH;
 883:iv.c          **** 	display_date(DATE);
 884:iv.c          **** 	display[4] |= 0x1;
 885:iv.c          **** 	display[5] |= 0x1;
 886:iv.c          ****       } else if (((mode == SET_DAY) && (region == REGION_US)) ||
 887:iv.c          **** 	((mode == SET_MONTH) && (region == REGION_EU))) {
 888:iv.c          **** 	mode = SET_YEAR;
 889:iv.c          **** 	display_date(DATE);
 890:iv.c          **** 	display[7] |= 0x1;
 891:iv.c          **** 	display[8] |= 0x1;
 892:iv.c          ****       } else {
 893:iv.c          **** 	displaymode = NONE;
 894:iv.c          **** 	display_date(DATE);
 895:iv.c          **** 	delayms(1500);
 896:iv.c          **** 	displaymode = SHOW_TIME;
 897:iv.c          **** 	return;
 898:iv.c          ****       }
 899:iv.c          ****     }
 900:iv.c          ****     if ((just_pressed & 0x4) || (pressed & 0x4)) {
 901:iv.c          ****       just_pressed = 0;
 902:iv.c          ****       if (mode == SET_MONTH) {
 903:iv.c          **** 	date_m++;
 904:iv.c          **** 	if (date_m >= 13)
 905:iv.c          **** 	  date_m = 1;
 906:iv.c          **** 	display_date(DATE);
 907:iv.c          **** 	if (region == REGION_US) {
 908:iv.c          **** 	  display[1] |= 0x1;
 909:iv.c          **** 	  display[2] |= 0x1;
 910:iv.c          **** 	} else {
 911:iv.c          **** 	  display[4] |= 0x1;
 912:iv.c          **** 	  display[5] |= 0x1;
 913:iv.c          **** 	}
 914:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_MONTH, date_m);    
 915:iv.c          ****       }
 916:iv.c          ****       if (mode == SET_DAY) {
 917:iv.c          **** 	date_d++;
 918:iv.c          **** 	if (date_d > 31)
 919:iv.c          **** 	  date_d = 1;
 920:iv.c          **** 	display_date(DATE);
 921:iv.c          **** 
 922:iv.c          **** 	if (region == REGION_EU) {
 923:iv.c          **** 	  display[1] |= 0x1;
 924:iv.c          **** 	  display[2] |= 0x1;
 925:iv.c          **** 	} else {
 926:iv.c          **** 	  display[4] |= 0x1;
 927:iv.c          **** 	  display[5] |= 0x1;
 928:iv.c          **** 	}
 929:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_DAY, date_d);    
 930:iv.c          ****       }
 931:iv.c          ****       if (mode == SET_YEAR) {
 932:iv.c          **** 	date_y++;
 933:iv.c          **** 	date_y %= 100;
 934:iv.c          **** 	display_date(DATE);
 935:iv.c          **** 	display[7] |= 0x1;
 936:iv.c          **** 	display[8] |= 0x1;
 937:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_YEAR, date_y);    
 938:iv.c          ****       }
 939:iv.c          **** 
 940:iv.c          ****       if (pressed & 0x4)
 941:iv.c          **** 	delayms(60);
 942:iv.c          ****     }
 943:iv.c          ****   }
 944:iv.c          **** }
 945:iv.c          **** 
 946:iv.c          **** 
 947:iv.c          **** void set_brightness(void) {
 948:iv.c          ****   uint8_t mode = SHOW_MENU;
 949:iv.c          ****   uint8_t brightness;
 950:iv.c          **** 
 951:iv.c          ****   timeoutcounter = INACTIVITYTIMEOUT;;  
 952:iv.c          ****   brightness = eeprom_read_byte((uint8_t *)EE_BRIGHT);
 953:iv.c          **** 
 954:iv.c          ****   while (1) {
 955:iv.c          ****     if (just_pressed || pressed) {
 956:iv.c          ****       timeoutcounter = INACTIVITYTIMEOUT;;  
 957:iv.c          ****       // timeout w/no buttons pressed after 3 seconds?
 958:iv.c          ****     } else if (!timeoutcounter) {
 959:iv.c          ****       //timed out!
 960:iv.c          ****       displaymode = SHOW_TIME;     
 961:iv.c          ****       eeprom_write_byte((uint8_t *)EE_BRIGHT, brightness);
 962:iv.c          ****       return;
 963:iv.c          ****     }
 964:iv.c          ****     if (just_pressed & 0x1) { // mode change
 965:iv.c          ****       return;
 966:iv.c          ****     }
 967:iv.c          ****     if (just_pressed & 0x2) {
 968:iv.c          **** 
 969:iv.c          ****       just_pressed = 0;
 970:iv.c          ****       if (mode == SHOW_MENU) {
 971:iv.c          **** 	// start!
 972:iv.c          **** 	mode = SET_BRITE;
 973:iv.c          **** 	// display brightness
 974:iv.c          **** 	display_str("brite ");
 975:iv.c          **** 	display[7] = pgm_read_byte(numbertable + (brightness / 10)) | 0x1;
 976:iv.c          **** 	display[8] = pgm_read_byte(numbertable + (brightness % 10)) | 0x1;
 977:iv.c          ****       } else {	
 978:iv.c          **** 	displaymode = SHOW_TIME;
 979:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_BRIGHT, brightness);
 980:iv.c          **** 	return;
 981:iv.c          ****       }
 982:iv.c          ****     }
 983:iv.c          ****     if ((just_pressed & 0x4) || (pressed & 0x4)) {
 984:iv.c          ****       just_pressed = 0;
 985:iv.c          ****       if (mode == SET_BRITE) {
 986:iv.c          **** 	brightness += 5;
 987:iv.c          **** 	if (brightness > 91)
 988:iv.c          **** 	  brightness = 30;
 989:iv.c          **** 	display[7] = pgm_read_byte(numbertable + (brightness / 10)) | 0x1;
 990:iv.c          **** 	display[8] = pgm_read_byte(numbertable + (brightness % 10)) | 0x1;
 991:iv.c          **** 	if (brightness <= 30) {
 992:iv.c          **** 	  OCR0A = 30; 
 993:iv.c          **** 	} else if (brightness <= 35) {
 994:iv.c          **** 	  OCR0A = 35;
 995:iv.c          **** 	} else if (brightness <= 40) {
 996:iv.c          **** 	  OCR0A = 40;
 997:iv.c          **** 	} else if (brightness <= 45) {
 998:iv.c          **** 	  OCR0A = 45;
 999:iv.c          **** 	} else if (brightness <= 50) {
1000:iv.c          **** 	  OCR0A = 50;
1001:iv.c          **** 	} else if (brightness <= 55) {
1002:iv.c          **** 	  OCR0A = 55;
1003:iv.c          **** 	} else if (brightness <= 60) {
1004:iv.c          **** 	  OCR0A = 60;
1005:iv.c          **** 	} else if (brightness <= 65) {
1006:iv.c          **** 	  OCR0A = 65;
1007:iv.c          **** 	} else if (brightness <= 70) {
1008:iv.c          **** 	  OCR0A = 70;
1009:iv.c          **** 	} else if (brightness <= 75) {
1010:iv.c          **** 	  OCR0A = 75;
1011:iv.c          **** 	} else if (brightness <= 80) {
1012:iv.c          **** 	  OCR0A = 80;
1013:iv.c          **** 	} else if (brightness <= 85) {
1014:iv.c          **** 	  OCR0A = 85;
1015:iv.c          **** 	} else if (brightness <= 90) {
1016:iv.c          **** 	  OCR0A = 90;
1017:iv.c          **** 	} else {
1018:iv.c          **** 	  OCR0A = 30;
1019:iv.c          **** 	}
1020:iv.c          ****       }
1021:iv.c          ****     }
1022:iv.c          ****   }
1023:iv.c          **** }
1024:iv.c          **** 
1025:iv.c          **** 
1026:iv.c          **** void set_volume(void) {
1027:iv.c          ****   uint8_t mode = SHOW_MENU;
1028:iv.c          ****   uint8_t volume;
1029:iv.c          **** 
1030:iv.c          ****   timeoutcounter = INACTIVITYTIMEOUT;;  
1031:iv.c          ****   volume = eeprom_read_byte((uint8_t *)EE_VOLUME);
1032:iv.c          **** 
1033:iv.c          ****   while (1) {
1034:iv.c          ****     if (just_pressed || pressed) {
1035:iv.c          ****       timeoutcounter = INACTIVITYTIMEOUT;;  
1036:iv.c          ****       // timeout w/no buttons pressed after 3 seconds?
1037:iv.c          ****     } else if (!timeoutcounter) {
1038:iv.c          ****       //timed out!
1039:iv.c          ****       displaymode = SHOW_TIME;     
1040:iv.c          ****       return;
1041:iv.c          ****     }
1042:iv.c          ****     if (just_pressed & 0x1) { // mode change
1043:iv.c          ****       return;
1044:iv.c          ****     }
1045:iv.c          ****     if (just_pressed & 0x2) {
1046:iv.c          ****       just_pressed = 0;
1047:iv.c          ****       if (mode == SHOW_MENU) {
1048:iv.c          **** 	// start!
1049:iv.c          **** 	mode = SET_VOL;
1050:iv.c          **** 	// display volume
1051:iv.c          **** 	if (volume) {
1052:iv.c          **** 	  display_str("vol high");
1053:iv.c          **** 	  display[5] |= 0x1;
1054:iv.c          **** 	} else {
1055:iv.c          **** 	  display_str("vol  low");
1056:iv.c          **** 	}
1057:iv.c          **** 	display[6] |= 0x1;
1058:iv.c          **** 	display[7] |= 0x1;
1059:iv.c          **** 	display[8] |= 0x1;
1060:iv.c          ****       } else {	
1061:iv.c          **** 	displaymode = SHOW_TIME;
1062:iv.c          **** 	return;
1063:iv.c          ****       }
1064:iv.c          ****     }
1065:iv.c          ****     if (just_pressed & 0x4) {
1066:iv.c          ****       just_pressed = 0;
1067:iv.c          ****       if (mode == SET_VOL) {
1068:iv.c          **** 	volume = !volume;
1069:iv.c          **** 	if (volume) {
1070:iv.c          **** 	  display_str("vol high");
1071:iv.c          **** 	  display[5] |= 0x1;
1072:iv.c          **** 	} else {
1073:iv.c          **** 	  display_str("vol  low");
1074:iv.c          **** 	}
1075:iv.c          **** 	display[6] |= 0x1;
1076:iv.c          **** 	display[7] |= 0x1;
1077:iv.c          **** 	display[8] |= 0x1;
1078:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_VOLUME, volume);
1079:iv.c          **** 	speaker_init();
1080:iv.c          **** 	beep(4000, 1);
1081:iv.c          ****       }
1082:iv.c          ****     }
1083:iv.c          ****   }
1084:iv.c          **** }
1085:iv.c          **** 
1086:iv.c          **** 
1087:iv.c          **** 
1088:iv.c          **** 
1089:iv.c          **** void set_region(void) {
1090:iv.c          ****   uint8_t mode = SHOW_MENU;
1091:iv.c          **** 
1092:iv.c          ****   timeoutcounter = INACTIVITYTIMEOUT;;  
1093:iv.c          ****   region = eeprom_read_byte((uint8_t *)EE_REGION);
1094:iv.c          **** 
1095:iv.c          ****   while (1) {
1096:iv.c          ****     if (just_pressed || pressed) {
1097:iv.c          ****       timeoutcounter = INACTIVITYTIMEOUT;;  
1098:iv.c          ****       // timeout w/no buttons pressed after 3 seconds?
1099:iv.c          ****     } else if (!timeoutcounter) {
1100:iv.c          ****       //timed out!
1101:iv.c          ****       displaymode = SHOW_TIME;     
1102:iv.c          ****       return;
1103:iv.c          ****     }
1104:iv.c          ****     if (just_pressed & 0x1) { // mode change
1105:iv.c          ****       return;
1106:iv.c          ****     }
1107:iv.c          ****     if (just_pressed & 0x2) {
1108:iv.c          ****       just_pressed = 0;
1109:iv.c          ****       if (mode == SHOW_MENU) {
1110:iv.c          **** 	// start!
1111:iv.c          **** 	mode = SET_REG;
1112:iv.c          **** 	// display region
1113:iv.c          **** 	if (region == REGION_US) {
1114:iv.c          **** 	  display_str("usa-12hr");
1115:iv.c          **** 	} else {
1116:iv.c          **** 	  display_str("eur-24hr");
1117:iv.c          **** 	}
1118:iv.c          ****       } else {	
1119:iv.c          **** 	displaymode = SHOW_TIME;
1120:iv.c          **** 	return;
1121:iv.c          ****       }
1122:iv.c          ****     }
1123:iv.c          ****     if (just_pressed & 0x4) {
1124:iv.c          ****       just_pressed = 0;
1125:iv.c          ****       if (mode == SET_REG) {
1126:iv.c          **** 	region = !region;
1127:iv.c          **** 	if (region == REGION_US) {
1128:iv.c          **** 	  display_str("usa-12hr");
1129:iv.c          **** 	} else {
1130:iv.c          **** 	  display_str("eur-24hr");
1131:iv.c          **** 	}
1132:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_REGION, region);
1133:iv.c          ****       }
1134:iv.c          ****     }
1135:iv.c          ****   }
1136:iv.c          **** }
1137:iv.c          **** 
1138:iv.c          **** 
1139:iv.c          **** /*
1140:iv.c          **** void set_snooze(void) {
1141:iv.c          ****   uint8_t mode = SHOW_MENU;
1142:iv.c          ****   uint8_t snooze;
1143:iv.c          **** 
1144:iv.c          ****   timeoutcounter = INACTIVITYTIMEOUT;;  
1145:iv.c          ****   snooze = eeprom_read_byte((uint8_t *)EE_SNOOZE);
1146:iv.c          **** 
1147:iv.c          ****   while (1) {
1148:iv.c          ****     if (just_pressed || pressed) {
1149:iv.c          ****       timeoutcounter = INACTIVITYTIMEOUT;;  
1150:iv.c          ****       // timeout w/no buttons pressed after 3 seconds?
1151:iv.c          ****     } else if (!timeoutcounter) {
1152:iv.c          ****       //timed out!
1153:iv.c          ****       displaymode = SHOW_TIME;     
1154:iv.c          ****       return;
1155:iv.c          ****     }
1156:iv.c          ****     if (just_pressed & 0x1) { // mode change
1157:iv.c          ****       return;
1158:iv.c          ****     }
1159:iv.c          ****     if (just_pressed & 0x2) {
1160:iv.c          **** 
1161:iv.c          ****       just_pressed = 0;
1162:iv.c          ****       if (mode == SHOW_MENU) {
1163:iv.c          **** 	// start!
1164:iv.c          **** 	mode = SET_SNOOZE;
1165:iv.c          **** 	// display snooze
1166:iv.c          **** 	display_str("   minut");
1167:iv.c          **** 	display[1] = pgm_read_byte(numbertable + (snooze / 10)) | 0x1;
1168:iv.c          **** 	display[2] = pgm_read_byte(numbertable + (snooze % 10)) | 0x1;
1169:iv.c          ****       } else { 
1170:iv.c          **** 	displaymode = SHOW_TIME;
1171:iv.c          **** 	return;
1172:iv.c          ****       }
1173:iv.c          ****     }
1174:iv.c          ****     if ((just_pressed & 0x4) || (pressed & 0x4)) {
1175:iv.c          ****       just_pressed = 0;
1176:iv.c          ****       if (mode == SET_SNOOZE) {
1177:iv.c          ****         snooze ++;
1178:iv.c          **** 	if (snooze >= 100)
1179:iv.c          **** 	  snooze = 0;
1180:iv.c          **** 	display[1] = pgm_read_byte(numbertable + (snooze / 10)) | 0x1;
1181:iv.c          **** 	display[2] = pgm_read_byte(numbertable + (snooze % 10)) | 0x1;
1182:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_SNOOZE, snooze);
1183:iv.c          ****       }
1184:iv.c          **** 
1185:iv.c          ****       if (pressed & 0x4)
1186:iv.c          **** 	delayms(75);
1187:iv.c          **** 
1188:iv.c          ****     }
1189:iv.c          ****   }
1190:iv.c          **** }
1191:iv.c          **** */
1192:iv.c          **** 
1193:iv.c          **** 
1194:iv.c          **** /**************************** RTC & ALARM *****************************/
1195:iv.c          **** void clock_init(void) {
 484               	.LM64:
 485               	.LFBB6:
 486 0172 0F93      		push r16
 487 0174 1F93      		push r17
 488               	/* prologue: function */
 489               	/* frame size = 0 */
 490               	/* stack size = 2 */
 491               	.L__stack_usage = 2
1196:iv.c          ****   // we store the time in EEPROM when switching from power modes so its
1197:iv.c          ****   // reasonable to start with whats in memory
1198:iv.c          ****   time_h = eeprom_read_byte((uint8_t *)EE_HOUR) % 24;
 493               	.LM65:
 494 0176 84E0      		ldi r24,lo8(4)
 495 0178 90E0      		ldi r25,hi8(4)
 496 017a 0E94 0000 		call __eerd_byte_m328p
 497 017e 08E1      		ldi r16,lo8(24)
 498 0180 602F      		mov r22,r16
 499 0182 0E94 0000 		call __udivmodqi4
 500 0186 9093 0000 		sts time_h,r25
1199:iv.c          ****   time_m = eeprom_read_byte((uint8_t *)EE_MIN) % 60;
 502               	.LM66:
 503 018a 85E0      		ldi r24,lo8(5)
 504 018c 90E0      		ldi r25,hi8(5)
 505 018e 0E94 0000 		call __eerd_byte_m328p
 506 0192 1CE3      		ldi r17,lo8(60)
 507 0194 612F      		mov r22,r17
 508 0196 0E94 0000 		call __udivmodqi4
 509 019a 9093 0000 		sts time_m,r25
1200:iv.c          ****   time_s = eeprom_read_byte((uint8_t *)EE_SEC) % 60;
 511               	.LM67:
 512 019e 86E0      		ldi r24,lo8(6)
 513 01a0 90E0      		ldi r25,hi8(6)
 514 01a2 0E94 0000 		call __eerd_byte_m328p
 515 01a6 612F      		mov r22,r17
 516 01a8 0E94 0000 		call __udivmodqi4
 517 01ac 9093 0000 		sts time_s,r25
1201:iv.c          **** 
1202:iv.c          ****   /*
1203:iv.c          ****     // if you're debugging, having the makefile set the right
1204:iv.c          ****     // time automatically will be very handy. Otherwise don't use this
1205:iv.c          ****   time_h = TIMEHOUR;
1206:iv.c          ****   time_m = TIMEMIN;
1207:iv.c          ****   time_s = TIMESEC + 10;
1208:iv.c          ****   */
1209:iv.c          **** 
1210:iv.c          ****   // Set up the stored alarm time and date
1211:iv.c          ****   alarm_m = eeprom_read_byte((uint8_t *)EE_ALARM_MIN) % 60;
 519               	.LM68:
 520 01b0 88E0      		ldi r24,lo8(8)
 521 01b2 90E0      		ldi r25,hi8(8)
 522 01b4 0E94 0000 		call __eerd_byte_m328p
 523 01b8 612F      		mov r22,r17
 524 01ba 0E94 0000 		call __udivmodqi4
 525 01be 9093 0000 		sts alarm_m,r25
1212:iv.c          ****   alarm_h = eeprom_read_byte((uint8_t *)EE_ALARM_HOUR) % 24;
 527               	.LM69:
 528 01c2 87E0      		ldi r24,lo8(7)
 529 01c4 90E0      		ldi r25,hi8(7)
 530 01c6 0E94 0000 		call __eerd_byte_m328p
 531 01ca 602F      		mov r22,r16
 532 01cc 0E94 0000 		call __udivmodqi4
 533 01d0 9093 0000 		sts alarm_h,r25
1213:iv.c          **** 
1214:iv.c          ****   date_y = eeprom_read_byte((uint8_t *)EE_YEAR) % 100;
 535               	.LM70:
 536 01d4 81E0      		ldi r24,lo8(1)
 537 01d6 90E0      		ldi r25,hi8(1)
 538 01d8 0E94 0000 		call __eerd_byte_m328p
 539 01dc 64E6      		ldi r22,lo8(100)
 540 01de 0E94 0000 		call __udivmodqi4
 541 01e2 9093 0000 		sts date_y,r25
1215:iv.c          ****   date_m = eeprom_read_byte((uint8_t *)EE_MONTH) % 13;
 543               	.LM71:
 544 01e6 82E0      		ldi r24,lo8(2)
 545 01e8 90E0      		ldi r25,hi8(2)
 546 01ea 0E94 0000 		call __eerd_byte_m328p
 547 01ee 6DE0      		ldi r22,lo8(13)
 548 01f0 0E94 0000 		call __udivmodqi4
 549 01f4 9093 0000 		sts date_m,r25
1216:iv.c          ****   date_d = eeprom_read_byte((uint8_t *)EE_DAY) % 32;
 551               	.LM72:
 552 01f8 83E0      		ldi r24,lo8(3)
 553 01fa 90E0      		ldi r25,hi8(3)
 554 01fc 0E94 0000 		call __eerd_byte_m328p
 555 0200 8F71      		andi r24,lo8(31)
 556 0202 8093 0000 		sts date_d,r24
1217:iv.c          **** 
1218:iv.c          ****   restored = 1;
 558               	.LM73:
 559 0206 91E0      		ldi r25,lo8(1)
 560 0208 9093 0000 		sts restored,r25
1219:iv.c          **** 
1220:iv.c          ****   // Turn on the RTC by selecting the external 32khz crystal
1221:iv.c          ****   // 32.768 / 128 = 256 which is exactly an 8-bit timer overflow
1222:iv.c          ****   ASSR |= _BV(AS2); // use crystal
 562               	.LM74:
 563 020c E6EB      		ldi r30,lo8(182)
 564 020e F0E0      		ldi r31,hi8(182)
 565 0210 8081      		ld r24,Z
 566 0212 8062      		ori r24,lo8(32)
 567 0214 8083      		st Z,r24
1223:iv.c          ****   TCCR2B = _BV(CS22) | _BV(CS20); // div by 128
 569               	.LM75:
 570 0216 85E0      		ldi r24,lo8(5)
 571 0218 8093 B100 		sts 177,r24
1224:iv.c          ****   // We will overflow once a second, and call an interrupt
1225:iv.c          **** 
1226:iv.c          ****   // enable interrupt
1227:iv.c          ****   TIMSK2 = _BV(TOIE2);
 573               	.LM76:
 574 021c 9093 7000 		sts 112,r25
1228:iv.c          **** 
1229:iv.c          ****   // enable all interrupts!
1230:iv.c          ****   sei();
 576               	.LM77:
 577               	/* #APP */
 578               	 ;  1230 "iv.c" 1
 579 0220 7894      		sei
 580               	 ;  0 "" 2
 581               	/* epilogue start */
1231:iv.c          **** }
 583               	.LM78:
 584               	/* #NOAPP */
 585 0222 1F91      		pop r17
 586 0224 0F91      		pop r16
 587 0226 0895      		ret
 589               	.Lscope6:
 591               		.stabd	78,0,0
 594               	.global	_Z8leapyearj
 596               	_Z8leapyearj:
 597               		.stabd	46,0,0
1232:iv.c          **** 
1233:iv.c          **** // This turns on/off the alarm when the switch has been
1234:iv.c          **** // set. It also displays the alarm time
1235:iv.c          **** void setalarmstate(void) {
1236:iv.c          ****   if (ALARM_PIN & _BV(ALARM)) { 
1237:iv.c          ****     // Don't display the alarm/beep if we already have
1238:iv.c          ****     if  (!alarm_on) {
1239:iv.c          ****       // alarm on!
1240:iv.c          ****       alarm_on = 1;
1241:iv.c          ****       // reset snoozing
1242:iv.c          ****       snoozetimer = 0;
1243:iv.c          ****       // show the status on the VFD tube
1244:iv.c          ****       display_str("alarm on");
1245:iv.c          ****       // its not actually SHOW_SNOOZE but just anything but SHOW_TIME
1246:iv.c          ****       displaymode = SHOW_SNOOZE;
1247:iv.c          ****       delayms(1000);
1248:iv.c          ****       // show the current alarm time set
1249:iv.c          ****       display_alarm(alarm_h, alarm_m);
1250:iv.c          ****       delayms(1000);
1251:iv.c          ****       // after a second, go back to clock mode
1252:iv.c          ****       displaymode = SHOW_TIME;
1253:iv.c          ****     }
1254:iv.c          ****   } else {
1255:iv.c          ****     if (alarm_on) {
1256:iv.c          ****       // turn off the alarm
1257:iv.c          ****       alarm_on = 0;
1258:iv.c          ****       snoozetimer = 0;
1259:iv.c          ****       if (alarming) {
1260:iv.c          **** 	// if the alarm is going off, we should turn it off
1261:iv.c          **** 	// and quiet the speaker
1262:iv.c          **** 	DEBUGP("alarm off");
1263:iv.c          **** 	alarming = 0;
1264:iv.c          **** 	TCCR1B &= ~_BV(CS11); // turn it off!
1265:iv.c          **** 	PORTB |= _BV(SPK1) | _BV(SPK2);
1266:iv.c          ****       } 
1267:iv.c          ****     }
1268:iv.c          ****   }
1269:iv.c          **** }
1270:iv.c          **** 
1271:iv.c          **** // This will calculate leapyears, give it the year
1272:iv.c          **** // and it will return 1 (true) or 0 (false)
1273:iv.c          **** uint8_t leapyear(uint16_t y) {
 599               	.LM79:
 600               	.LFBB7:
 601               	/* prologue: function */
 602               	/* frame size = 0 */
 603               	/* stack size = 0 */
 604               	.L__stack_usage = 0
 605 0228 9C01      		movw r18,r24
1274:iv.c          ****   return ( (!(y % 4) && (y % 100)) || !(y % 400));
 607               	.LM80:
 608 022a 8370      		andi r24,lo8(3)
 609 022c 9070      		andi r25,hi8(3)
 610 022e 0097      		sbiw r24,0
 611 0230 01F4      		brne .L15
 613               	.LM81:
 614 0232 C901      		movw r24,r18
 615 0234 64E6      		ldi r22,lo8(100)
 616 0236 70E0      		ldi r23,hi8(100)
 617 0238 0E94 0000 		call __udivmodhi4
 618 023c 0097      		sbiw r24,0
 619 023e 01F4      		brne .L18
 620               	.L15:
 622               	.LM82:
 623 0240 C901      		movw r24,r18
 624 0242 60E9      		ldi r22,lo8(400)
 625 0244 71E0      		ldi r23,hi8(400)
 626 0246 0E94 0000 		call __udivmodhi4
 627 024a 9C01      		movw r18,r24
1273:iv.c          **** uint8_t leapyear(uint16_t y) {
 629               	.LM83:
 630 024c 81E0      		ldi r24,lo8(1)
 631 024e 2115      		cp r18,__zero_reg__
 632 0250 3105      		cpc r19,__zero_reg__
 633 0252 01F0      		breq .L16
 634 0254 80E0      		ldi r24,lo8(0)
 635 0256 0895      		ret
 636               	.L18:
 638               	.LM84:
 639 0258 81E0      		ldi r24,lo8(1)
 640               	.L16:
1275:iv.c          **** }
 642               	.LM85:
 643 025a 0895      		ret
 645               	.Lscope7:
 647               		.stabd	78,0,0
 649               	.global	_Z12speaker_initv
 651               	_Z12speaker_initv:
 652               		.stabd	46,0,0
1276:iv.c          **** 
1277:iv.c          **** 
1278:iv.c          **** /**************************** SPEAKER *****************************/
1279:iv.c          **** // Set up the speaker to prepare for beeping!
1280:iv.c          **** void speaker_init(void) {
 654               	.LM86:
 655               	.LFBB8:
 656               	/* prologue: function */
 657               	/* frame size = 0 */
 658               	/* stack size = 0 */
 659               	.L__stack_usage = 0
1281:iv.c          **** 
1282:iv.c          ****   // read the preferences for high/low volume
1283:iv.c          ****   volume = eeprom_read_byte((uint8_t *)EE_VOLUME);
 661               	.LM87:
 662 025c 8AE0      		ldi r24,lo8(10)
 663 025e 90E0      		ldi r25,hi8(10)
 664 0260 0E94 0000 		call __eerd_byte_m328p
 665 0264 8093 0000 		sts volume,r24
1284:iv.c          **** 
1285:iv.c          ****   // We use the built-in fast PWM, 8 bit timer
1286:iv.c          ****   PORTB |= _BV(SPK1) | _BV(SPK2); 
 667               	.LM88:
 668 0268 85B1      		in r24,37-32
 669 026a 8660      		ori r24,lo8(6)
 670 026c 85B9      		out 37-32,r24
1287:iv.c          **** 
1288:iv.c          ****   // Turn on PWM outputs for both pins
1289:iv.c          ****   TCCR1A = _BV(COM1B1) | _BV(COM1B0) | _BV(WGM11);
 672               	.LM89:
 673 026e 82E3      		ldi r24,lo8(50)
 674 0270 8093 8000 		sts 128,r24
1290:iv.c          ****   if (volume) {
 676               	.LM90:
 677 0274 8091 0000 		lds r24,volume
 678 0278 8823      		tst r24
 679 027a 01F0      		breq .L20
1291:iv.c          ****     TCCR1A |= _BV(COM1A1);
 681               	.LM91:
 682 027c 8091 8000 		lds r24,128
 683 0280 8068      		ori r24,lo8(-128)
 684 0282 8093 8000 		sts 128,r24
 685               	.L20:
1292:iv.c          ****   } 
1293:iv.c          ****   TCCR1B = _BV(WGM13) | _BV(WGM12);
 687               	.LM92:
 688 0286 88E1      		ldi r24,lo8(24)
 689 0288 8093 8100 		sts 129,r24
1294:iv.c          **** 
1295:iv.c          ****   // start at 4khz:  250 * 8 multiplier * 4000 = 8mhz
1296:iv.c          ****   ICR1 = 250;
 691               	.LM93:
 692 028c 8AEF      		ldi r24,lo8(250)
 693 028e 90E0      		ldi r25,hi8(250)
 694 0290 9093 8700 		sts 134+1,r25
 695 0294 8093 8600 		sts 134,r24
1297:iv.c          ****   OCR1B = OCR1A = ICR1 / 2;
 697               	.LM94:
 698 0298 8091 8600 		lds r24,134
 699 029c 9091 8700 		lds r25,134+1
 700 02a0 9695      		lsr r25
 701 02a2 8795      		ror r24
 702 02a4 9093 8900 		sts 136+1,r25
 703 02a8 8093 8800 		sts 136,r24
 704 02ac 8091 8800 		lds r24,136
 705 02b0 9091 8900 		lds r25,136+1
 706 02b4 9093 8B00 		sts 138+1,r25
 707 02b8 8093 8A00 		sts 138,r24
 708               	/* epilogue start */
1298:iv.c          **** }
 710               	.LM95:
 711 02bc 0895      		ret
 713               	.Lscope8:
 715               		.stabd	78,0,0
 717               	.global	_Z4tickv
 719               	_Z4tickv:
 720               		.stabd	46,0,0
1299:iv.c          **** 
1300:iv.c          **** // This makes the speaker tick, it doesnt use PWM
1301:iv.c          **** // instead it just flicks the piezo
1302:iv.c          **** void tick(void) {
 722               	.LM96:
 723               	.LFBB9:
 724 02be 0F93      		push r16
 725 02c0 1F93      		push r17
 726 02c2 CF93      		push r28
 727 02c4 DF93      		push r29
 728               	/* prologue: function */
 729               	/* frame size = 0 */
 730               	/* stack size = 4 */
 731               	.L__stack_usage = 4
1303:iv.c          ****   TCCR1A = 0;
 733               	.LM97:
 734 02c6 00E8      		ldi r16,lo8(128)
 735 02c8 10E0      		ldi r17,hi8(128)
 736 02ca F801      		movw r30,r16
 737 02cc 1082      		st Z,__zero_reg__
1304:iv.c          ****   TCCR1B = 0;
 739               	.LM98:
 740 02ce C1E8      		ldi r28,lo8(129)
 741 02d0 D0E0      		ldi r29,hi8(129)
 742 02d2 1882      		st Y,__zero_reg__
1305:iv.c          **** 
1306:iv.c          ****   // Send a pulse thru both pins, alternating
1307:iv.c          ****   SPK_PORT |= _BV(SPK1);
 744               	.LM99:
 745 02d4 299A      		sbi 37-32,1
1308:iv.c          ****   SPK_PORT &= ~_BV(SPK2);
 747               	.LM100:
 748 02d6 2A98      		cbi 37-32,2
1309:iv.c          ****   delayms(10);
 750               	.LM101:
 751 02d8 8AE0      		ldi r24,lo8(10)
 752 02da 90E0      		ldi r25,hi8(10)
 753 02dc 0E94 0000 		call _Z7delaymsj
1310:iv.c          ****   SPK_PORT |= _BV(SPK2);
 755               	.LM102:
 756 02e0 2A9A      		sbi 37-32,2
1311:iv.c          ****   SPK_PORT &= ~_BV(SPK1);
 758               	.LM103:
 759 02e2 2998      		cbi 37-32,1
1312:iv.c          ****   delayms(10);
 761               	.LM104:
 762 02e4 8AE0      		ldi r24,lo8(10)
 763 02e6 90E0      		ldi r25,hi8(10)
 764 02e8 0E94 0000 		call _Z7delaymsj
1313:iv.c          ****   // turn them both off
1314:iv.c          ****   SPK_PORT &= ~_BV(SPK1) & ~_BV(SPK2);
 766               	.LM105:
 767 02ec 85B1      		in r24,37-32
 768 02ee 897F      		andi r24,lo8(-7)
 769 02f0 85B9      		out 37-32,r24
1315:iv.c          **** 
1316:iv.c          ****   TCCR1A = _BV(COM1A1) | _BV(COM1B1) | _BV(COM1B0) | _BV(WGM11);
 771               	.LM106:
 772 02f2 82EB      		ldi r24,lo8(-78)
 773 02f4 F801      		movw r30,r16
 774 02f6 8083      		st Z,r24
1317:iv.c          ****   TCCR1B = _BV(WGM13) | _BV(WGM12);
 776               	.LM107:
 777 02f8 88E1      		ldi r24,lo8(24)
 778 02fa 8883      		st Y,r24
 779               	/* epilogue start */
1318:iv.c          **** }
 781               	.LM108:
 782 02fc DF91      		pop r29
 783 02fe CF91      		pop r28
 784 0300 1F91      		pop r17
 785 0302 0F91      		pop r16
 786 0304 0895      		ret
 788               	.Lscope9:
 790               		.stabd	78,0,0
 794               	.global	_Z4beepjh
 796               	_Z4beepjh:
 797               		.stabd	46,0,0
1319:iv.c          **** 
1320:iv.c          **** // We can play short beeps!
1321:iv.c          **** void beep(uint16_t freq, uint8_t times) {
 799               	.LM109:
 800               	.LFBB10:
 801 0306 1F93      		push r17
 802               	/* prologue: function */
 803               	/* frame size = 0 */
 804               	/* stack size = 1 */
 805               	.L__stack_usage = 1
 806 0308 162F      		mov r17,r22
1322:iv.c          ****   // set the PWM output to match the desired frequency
1323:iv.c          ****   ICR1 = (F_CPU/8)/freq;
 808               	.LM110:
 809 030a 9C01      		movw r18,r24
 810 030c 40E0      		ldi r20,lo8(0)
 811 030e 50E0      		ldi r21,hi8(0)
 812 0310 60E4      		ldi r22,lo8(1000000)
 813 0312 72E4      		ldi r23,hi8(1000000)
 814 0314 8FE0      		ldi r24,hlo8(1000000)
 815 0316 90E0      		ldi r25,hhi8(1000000)
 816 0318 0E94 0000 		call __divmodsi4
 817 031c 3093 8700 		sts 134+1,r19
 818 0320 2093 8600 		sts 134,r18
1324:iv.c          ****   // we want 50% duty cycle square wave
1325:iv.c          ****   OCR1A = OCR1B = ICR1/2;
 820               	.LM111:
 821 0324 8091 8600 		lds r24,134
 822 0328 9091 8700 		lds r25,134+1
 823 032c 9695      		lsr r25
 824 032e 8795      		ror r24
 825 0330 9093 8B00 		sts 138+1,r25
 826 0334 8093 8A00 		sts 138,r24
 827 0338 8091 8A00 		lds r24,138
 828 033c 9091 8B00 		lds r25,138+1
 829 0340 9093 8900 		sts 136+1,r25
 830 0344 8093 8800 		sts 136,r24
1326:iv.c          ****    
1327:iv.c          ****   while (times--) {
 832               	.LM112:
 833 0348 00C0      		rjmp .L23
 834               	.L24:
1328:iv.c          ****     TCCR1B |= _BV(CS11); // turn it on!
 836               	.LM113:
 837 034a 8091 8100 		lds r24,129
 838 034e 8260      		ori r24,lo8(2)
 839 0350 8093 8100 		sts 129,r24
 840               	.LBB66:
 841               	.LBB67:
 843               	.Ltext1:
   1:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
   6:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
   9:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  12:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****      distribution.
  16:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  17:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  21:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  33:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** /* $Id: delay.h.in 2189 2010-10-13 09:39:34Z aboyapati $ */
  34:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  35:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  38:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #endif
  41:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  42:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  46:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** /** \file */
  47:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     \code
  49:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     \endcode
  53:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  54:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     used.
  58:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  59:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  68:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  77:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  81:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** */
  82:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  83:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #endif
  87:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  88:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #endif
  93:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  94:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #endif
  97:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  98:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** /**
  99:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    \ingroup util_delay
 100:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 101:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 102:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 103:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 104:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 105:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 106:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 107:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 108:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 109:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 110:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 111:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 112:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 113:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 114:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 115:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 116:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 117:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    no delay i.e., 0ms.
 118:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 119:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 120:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 121:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 122:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 123:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 124:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 125:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 126:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 127:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 128:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay
 129:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    although this will be deprecated in future.
 130:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 131:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****  */
 132:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** void
 133:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 134:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** {
 135:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 136:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	double __tmp ; 
 137:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && !defined(__DELAY_BACKWARD_COMPATIBLE__)
 138:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 139:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 140:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 141:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 142:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 143:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 144:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 145:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 146:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 147:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 148:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	#else
 149:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 		//round up by default
 150:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 151:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	#endif
 152:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 153:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 845               	.LM114:
 846 0354 8FEF      		 ldi r24,lo8(319999)
 847 0356 91EE      	    ldi r25,hi8(319999)
 848 0358 A4E0      	    ldi r26,hlo8(319999)
 849 035a 8150      	    1:subi r24,1
 850 035c 9040      	    sbci r25,0
 851 035e A040      	    sbci r26,0
 852 0360 01F4      	    brne 1b
 853 0362 00C0      		rjmp .
 854 0364 0000      		nop
 855               	.LBE67:
 856               	.LBE66:
 858               	.Ltext2:
1329:iv.c          ****     // beeps are 200ms long on
1330:iv.c          ****     _delay_ms(200);
1331:iv.c          ****     TCCR1B &= ~_BV(CS11); // turn it off!
 860               	.LM115:
 861 0366 8091 8100 		lds r24,129
 862 036a 8D7F      		andi r24,lo8(-3)
 863 036c 8093 8100 		sts 129,r24
1332:iv.c          ****     PORTB &= ~_BV(SPK1) & ~_BV(SPK2);
 865               	.LM116:
 866 0370 85B1      		in r24,37-32
 867 0372 897F      		andi r24,lo8(-7)
 868 0374 85B9      		out 37-32,r24
 869               	.LBB68:
 870               	.LBB69:
 872               	.Ltext3:
 874               	.LM117:
 875 0376 8FEF      		 ldi r24,lo8(319999)
 876 0378 91EE      	    ldi r25,hi8(319999)
 877 037a A4E0      	    ldi r26,hlo8(319999)
 878 037c 8150      	    1:subi r24,1
 879 037e 9040      	    sbci r25,0
 880 0380 A040      	    sbci r26,0
 881 0382 01F4      	    brne 1b
 882 0384 00C0      		rjmp .
 883 0386 0000      		nop
 884 0388 1150      		subi r17,lo8(-(-1))
 885               	.L23:
 886               	.LBE69:
 887               	.LBE68:
 889               	.Ltext4:
1327:iv.c          ****   while (times--) {
 891               	.LM118:
 892 038a 1123      		tst r17
 893 038c 01F4      		brne .L24
1333:iv.c          ****     // beeps are 200ms long off
1334:iv.c          ****     _delay_ms(200);
1335:iv.c          ****   }
1336:iv.c          ****   // turn speaker off
1337:iv.c          ****   PORTB &= ~_BV(SPK1) & ~_BV(SPK2);
 895               	.LM119:
 896 038e 85B1      		in r24,37-32
 897 0390 897F      		andi r24,lo8(-7)
 898 0392 85B9      		out 37-32,r24
 899               	/* epilogue start */
1338:iv.c          **** }
 901               	.LM120:
 902 0394 1F91      		pop r17
 903 0396 0895      		ret
 905               	.Lscope10:
 907               		.stabd	78,0,0
 910               	.global	_Z10boost_inith
 912               	_Z10boost_inith:
 913               		.stabd	46,0,0
1339:iv.c          **** 
1340:iv.c          **** 
1341:iv.c          **** 
1342:iv.c          **** /**************************** BOOST *****************************/
1343:iv.c          **** 
1344:iv.c          **** // We control the boost converter by changing the PWM output
1345:iv.c          **** // pins
1346:iv.c          **** void boost_init(uint8_t brightness) {
 915               	.LM121:
 916               	.LFBB11:
 917               	/* prologue: function */
 918               	/* frame size = 0 */
 919               	/* stack size = 0 */
 920               	.L__stack_usage = 0
1347:iv.c          ****   // Set PWM value, don't set it so high that
1348:iv.c          ****   // we could damage the MAX chip or display
1349:iv.c          ****   if (brightness > 90)
 922               	.LM122:
 923 0398 8B35      		cpi r24,lo8(91)
 924 039a 00F4      		brsh .L39
1350:iv.c          ****     brightness = 90;
1351:iv.c          **** 
1352:iv.c          ****   // Or so low its not visible
1353:iv.c          ****   if (brightness < 30)
 926               	.LM123:
 927 039c 8E31      		cpi r24,lo8(30)
 928 039e 00F0      		brlo .L27
1354:iv.c          ****     brightness = 30;
1355:iv.c          **** 
1356:iv.c          ****   if (brightness <= 30) {
 930               	.LM124:
 931 03a0 8E31      		cpi r24,lo8(30)
 932 03a2 01F4      		brne .L28
 933               	.L27:
1357:iv.c          ****     OCR0A = 30; 
 935               	.LM125:
 936 03a4 8EE1      		ldi r24,lo8(30)
 937 03a6 00C0      		rjmp .L41
 938               	.L28:
1358:iv.c          ****   } else if (brightness <= 35) {
 940               	.LM126:
 941 03a8 8432      		cpi r24,lo8(36)
 942 03aa 00F4      		brsh .L30
1359:iv.c          ****     OCR0A = 35;
 944               	.LM127:
 945 03ac 83E2      		ldi r24,lo8(35)
 946 03ae 00C0      		rjmp .L41
 947               	.L30:
1360:iv.c          ****   } else if (brightness <= 40) {
 949               	.LM128:
 950 03b0 8932      		cpi r24,lo8(41)
 951 03b2 00F4      		brsh .L26
1361:iv.c          ****     OCR0A = 40;
 953               	.LM129:
 954 03b4 88E2      		ldi r24,lo8(40)
 955 03b6 00C0      		rjmp .L41
 956               	.L26:
1362:iv.c          ****   } else if (brightness <= 45) {
 958               	.LM130:
 959 03b8 8E32      		cpi r24,lo8(46)
 960 03ba 00F4      		brsh .L31
1363:iv.c          ****     OCR0A = 45;
 962               	.LM131:
 963 03bc 8DE2      		ldi r24,lo8(45)
 964 03be 00C0      		rjmp .L41
 965               	.L31:
1364:iv.c          ****   } else if (brightness <= 50) {
 967               	.LM132:
 968 03c0 8333      		cpi r24,lo8(51)
 969 03c2 00F4      		brsh .L32
1365:iv.c          ****     OCR0A = 50;
 971               	.LM133:
 972 03c4 82E3      		ldi r24,lo8(50)
 973 03c6 00C0      		rjmp .L41
 974               	.L32:
1366:iv.c          ****   } else if (brightness <= 55) {
 976               	.LM134:
 977 03c8 8833      		cpi r24,lo8(56)
 978 03ca 00F4      		brsh .L33
1367:iv.c          ****     OCR0A = 55;
 980               	.LM135:
 981 03cc 87E3      		ldi r24,lo8(55)
 982 03ce 00C0      		rjmp .L41
 983               	.L33:
1368:iv.c          ****   } else if (brightness <= 60) {
 985               	.LM136:
 986 03d0 8D33      		cpi r24,lo8(61)
 987 03d2 00F4      		brsh .L34
1369:iv.c          ****     OCR0A = 60;
 989               	.LM137:
 990 03d4 8CE3      		ldi r24,lo8(60)
 991 03d6 00C0      		rjmp .L41
 992               	.L34:
1370:iv.c          ****   } else if (brightness <= 65) {
 994               	.LM138:
 995 03d8 8234      		cpi r24,lo8(66)
 996 03da 00F4      		brsh .L35
1371:iv.c          ****     OCR0A = 65;
 998               	.LM139:
 999 03dc 81E4      		ldi r24,lo8(65)
 1000 03de 00C0      		rjmp .L41
 1001               	.L35:
1372:iv.c          ****   } else if (brightness <= 70) {
 1003               	.LM140:
 1004 03e0 8734      		cpi r24,lo8(71)
 1005 03e2 00F4      		brsh .L36
1373:iv.c          ****     OCR0A = 70;
 1007               	.LM141:
 1008 03e4 86E4      		ldi r24,lo8(70)
 1009 03e6 00C0      		rjmp .L41
 1010               	.L36:
1374:iv.c          ****   } else if (brightness <= 75) {
 1012               	.LM142:
 1013 03e8 8C34      		cpi r24,lo8(76)
 1014 03ea 00F4      		brsh .L37
1375:iv.c          ****     OCR0A = 75;
 1016               	.LM143:
 1017 03ec 8BE4      		ldi r24,lo8(75)
 1018 03ee 00C0      		rjmp .L41
 1019               	.L37:
1376:iv.c          ****   } else if (brightness <= 80) {
 1021               	.LM144:
 1022 03f0 8135      		cpi r24,lo8(81)
 1023 03f2 00F4      		brsh .L38
1377:iv.c          ****     OCR0A = 80;
 1025               	.LM145:
 1026 03f4 80E5      		ldi r24,lo8(80)
 1027 03f6 00C0      		rjmp .L41
 1028               	.L38:
1378:iv.c          ****   } else if (brightness <= 85) {
 1030               	.LM146:
 1031 03f8 8635      		cpi r24,lo8(86)
 1032 03fa 00F4      		brsh .L39
1379:iv.c          ****     OCR0A = 85;
 1034               	.LM147:
 1035 03fc 85E5      		ldi r24,lo8(85)
 1036 03fe 00C0      		rjmp .L41
 1037               	.L39:
1380:iv.c          ****   } else if (brightness <= 90) {
1381:iv.c          ****     OCR0A = 90;
 1039               	.LM148:
 1040 0400 8AE5      		ldi r24,lo8(90)
 1041               	.L41:
 1042 0402 87BD      		out 71-32,r24
1382:iv.c          ****   } else {
1383:iv.c          ****     OCR0A = 30;
1384:iv.c          ****   }
1385:iv.c          **** 
1386:iv.c          ****   // fast PWM, set OC0A (boost output pin) on match
1387:iv.c          ****   TCCR0A = _BV(WGM00) | _BV(WGM01);  
 1044               	.LM149:
 1045 0404 83E0      		ldi r24,lo8(3)
 1046 0406 84BD      		out 68-32,r24
1388:iv.c          **** 
1389:iv.c          ****   // Use the fastest clock
1390:iv.c          ****   TCCR0B = _BV(CS00);
 1048               	.LM150:
 1049 0408 81E0      		ldi r24,lo8(1)
 1050 040a 85BD      		out 69-32,r24
1391:iv.c          ****  
1392:iv.c          ****   TCCR0A |= _BV(COM0A1);
 1052               	.LM151:
 1053 040c 84B5      		in r24,68-32
 1054 040e 8068      		ori r24,lo8(-128)
 1055 0410 84BD      		out 68-32,r24
1393:iv.c          ****   TIMSK0 |= _BV(TOIE0); // turn on the interrupt for muxing
 1057               	.LM152:
 1058 0412 8091 6E00 		lds r24,110
 1059 0416 8160      		ori r24,lo8(1)
 1060 0418 8093 6E00 		sts 110,r24
1394:iv.c          ****   sei();
 1062               	.LM153:
 1063               	/* #APP */
 1064               	 ;  1394 "iv.c" 1
 1065 041c 7894      		sei
 1066               	 ;  0 "" 2
 1067               	/* epilogue start */
1395:iv.c          **** }
 1069               	.LM154:
 1070               	/* #NOAPP */
 1071 041e 0895      		ret
 1073               	.Lscope11:
 1075               		.stabd	78,0,0
 1080               	.global	_Z12display_timehhh
 1082               	_Z12display_timehhh:
 1083               		.stabd	46,0,0
1396:iv.c          **** 
1397:iv.c          **** /**************************** DISPLAY *****************************/
1398:iv.c          **** 
1399:iv.c          **** // We can display the current date!
1400:iv.c          **** void display_date(uint8_t style) {
1401:iv.c          **** 
1402:iv.c          ****   // This type is mm-dd-yy OR dd-mm-yy depending on our pref.
1403:iv.c          ****   if (style == DATE) {
1404:iv.c          ****     display[0] = 0;
1405:iv.c          ****     display[6] = display[3] = 0x02;     // put dashes between num
1406:iv.c          **** 
1407:iv.c          ****     if (region == REGION_US) {
1408:iv.c          ****       // mm-dd-yy
1409:iv.c          ****       display[1] = pgm_read_byte(numbertable + (date_m / 10));
1410:iv.c          ****       display[2] = pgm_read_byte(numbertable + (date_m % 10));
1411:iv.c          ****       display[4] = pgm_read_byte(numbertable + (date_d / 10));
1412:iv.c          ****       display[5] = pgm_read_byte(numbertable + (date_d % 10));
1413:iv.c          ****     } else {
1414:iv.c          ****       // dd-mm-yy
1415:iv.c          ****       display[1] = pgm_read_byte(numbertable + (date_d / 10));
1416:iv.c          ****       display[2] = pgm_read_byte(numbertable + (date_d % 10));
1417:iv.c          ****       display[4] = pgm_read_byte(numbertable + (date_m / 10));
1418:iv.c          ****       display[5] = pgm_read_byte(numbertable + (date_m % 10));
1419:iv.c          ****     }
1420:iv.c          ****     // the yy part is the same
1421:iv.c          ****     display[7] = pgm_read_byte(numbertable + (date_y / 10));
1422:iv.c          ****     display[8] = pgm_read_byte(numbertable + (date_y % 10));
1423:iv.c          **** 
1424:iv.c          ****   } else if (style == DAY) {
1425:iv.c          ****     // This is more "Sunday June 21" style
1426:iv.c          **** 
1427:iv.c          ****     uint16_t month, year;
1428:iv.c          ****     uint8_t dotw;
1429:iv.c          **** 
1430:iv.c          ****     // Calculate day of the week
1431:iv.c          ****     
1432:iv.c          ****     month = date_m;
1433:iv.c          ****     year = 2000 + date_y;
1434:iv.c          ****     if (date_m < 3)  {
1435:iv.c          ****       month += 12;
1436:iv.c          ****       year -= 1;
1437:iv.c          ****     }
1438:iv.c          ****     dotw = (date_d + (2 * month) + (6 * (month+1)/10) + year + (year/4) - (year/100) + (year/400) +
1439:iv.c          **** 
1440:iv.c          ****     // Display the day first
1441:iv.c          ****     display[8] = display[7] = 0;
1442:iv.c          ****     switch (dotw) {
1443:iv.c          ****     case 0:
1444:iv.c          ****       display_str("sunday"); break;
1445:iv.c          ****     case 1:
1446:iv.c          ****       display_str("monday"); break;
1447:iv.c          ****     case 2:
1448:iv.c          ****       display_str("tuesday"); break;
1449:iv.c          ****     case 3:
1450:iv.c          ****       display_str("wednsday"); break;
1451:iv.c          ****     case 4:
1452:iv.c          ****       display_str("thursday"); break;
1453:iv.c          ****     case 5:
1454:iv.c          ****       display_str("friday"); break;
1455:iv.c          ****     case 6:
1456:iv.c          ****       display_str("saturday"); break;
1457:iv.c          ****     }
1458:iv.c          ****     
1459:iv.c          ****     // wait one seconds about
1460:iv.c          ****     delayms(1000);
1461:iv.c          **** 
1462:iv.c          ****     // Then display the month and date
1463:iv.c          ****     display[6] = display[5] = display[4] = 0;
1464:iv.c          ****     switch (date_m) {
1465:iv.c          ****     case 1:
1466:iv.c          ****       display_str("jan"); break;
1467:iv.c          ****     case 2:
1468:iv.c          ****       display_str("feb"); break;
1469:iv.c          ****     case 3:
1470:iv.c          ****       display_str("march"); break;
1471:iv.c          ****     case 4:
1472:iv.c          ****       display_str("april"); break;
1473:iv.c          ****     case 5:
1474:iv.c          ****       display_str("may"); break;
1475:iv.c          ****     case 6:
1476:iv.c          ****       display_str("june"); break;
1477:iv.c          ****     case 7:
1478:iv.c          ****       display_str("july"); break;
1479:iv.c          ****     case 8:
1480:iv.c          ****       display_str("augst"); break;
1481:iv.c          ****     case 9:
1482:iv.c          ****       display_str("sept"); break;
1483:iv.c          ****     case 10:
1484:iv.c          ****       display_str("octob"); break;
1485:iv.c          ****     case 11:
1486:iv.c          ****       display_str("novem"); break;
1487:iv.c          ****     case 12:
1488:iv.c          ****       display_str("decem"); break;
1489:iv.c          ****     }
1490:iv.c          ****     display[7] = pgm_read_byte(numbertable + (date_d / 10));
1491:iv.c          ****     display[8] = pgm_read_byte(numbertable + (date_d % 10));
1492:iv.c          ****     
1493:iv.c          ****   }
1494:iv.c          **** }
1495:iv.c          **** 
1496:iv.c          **** // This displays a time on the clock
1497:iv.c          **** void display_time(uint8_t h, uint8_t m, uint8_t s) {
 1085               	.LM155:
 1086               	.LFBB12:
 1087 0420 1F93      		push r17
 1088               	/* prologue: function */
 1089               	/* frame size = 0 */
 1090               	/* stack size = 1 */
 1091               	.L__stack_usage = 1
 1092 0422 182F      		mov r17,r24
 1093 0424 262F      		mov r18,r22
 1094 0426 842F      		mov r24,r20
 1095               	.LBB70:
 1096               	.LBB71:
1498:iv.c          ****   
1499:iv.c          ****   // seconds and minutes are at the end
1500:iv.c          ****   display[8] =  pgm_read_byte(numbertable + (s % 10));
 1098               	.LM156:
 1099 0428 3AE0      		ldi r19,lo8(10)
 1100 042a 632F      		mov r22,r19
 1101 042c 0E94 0000 		call __udivmodqi4
 1102 0430 E92F      		mov r30,r25
 1103 0432 F0E0      		ldi r31,lo8(0)
 1104 0434 E050      		subi r30,lo8(-(_ZL11numbertable))
 1105 0436 F040      		sbci r31,hi8(-(_ZL11numbertable))
 1106               	/* #APP */
 1107               	 ;  1500 "iv.c" 1
 1108 0438 E491      		lpm r30, Z
 1109               		
 1110               	 ;  0 "" 2
 1111               	/* #NOAPP */
 1112 043a E093 0000 		sts display+8,r30
 1113               	.LBE71:
 1114               	.LBB72:
1501:iv.c          ****   display[7] =  pgm_read_byte(numbertable + (s / 10));
 1116               	.LM157:
 1117 043e E82F      		mov r30,r24
 1118 0440 F0E0      		ldi r31,lo8(0)
 1119 0442 E050      		subi r30,lo8(-(_ZL11numbertable))
 1120 0444 F040      		sbci r31,hi8(-(_ZL11numbertable))
 1121               	/* #APP */
 1122               	 ;  1501 "iv.c" 1
 1123 0446 E491      		lpm r30, Z
 1124               		
 1125               	 ;  0 "" 2
 1126               	/* #NOAPP */
 1127 0448 E093 0000 		sts display+7,r30
 1128               	.LBE72:
1502:iv.c          ****   display[6] = 0;
 1130               	.LM158:
 1131 044c 1092 0000 		sts display+6,__zero_reg__
 1132               	.LBB73:
1503:iv.c          ****   display[5] =  pgm_read_byte(numbertable + (m % 10));
 1134               	.LM159:
 1135 0450 822F      		mov r24,r18
 1136 0452 0E94 0000 		call __udivmodqi4
 1137 0456 E92F      		mov r30,r25
 1138 0458 F0E0      		ldi r31,lo8(0)
 1139 045a E050      		subi r30,lo8(-(_ZL11numbertable))
 1140 045c F040      		sbci r31,hi8(-(_ZL11numbertable))
 1141               	/* #APP */
 1142               	 ;  1503 "iv.c" 1
 1143 045e E491      		lpm r30, Z
 1144               		
 1145               	 ;  0 "" 2
 1146               	/* #NOAPP */
 1147 0460 E093 0000 		sts display+5,r30
 1148               	.LBE73:
 1149               	.LBB74:
1504:iv.c          ****   display[4] =  pgm_read_byte(numbertable + (m / 10)); 
 1151               	.LM160:
 1152 0464 E82F      		mov r30,r24
 1153 0466 F0E0      		ldi r31,lo8(0)
 1154 0468 E050      		subi r30,lo8(-(_ZL11numbertable))
 1155 046a F040      		sbci r31,hi8(-(_ZL11numbertable))
 1156               	/* #APP */
 1157               	 ;  1504 "iv.c" 1
 1158 046c E491      		lpm r30, Z
 1159               		
 1160               	 ;  0 "" 2
 1161               	/* #NOAPP */
 1162 046e E093 0000 		sts display+4,r30
 1163               	.LBE74:
1505:iv.c          ****   display[3] = 0;
 1165               	.LM161:
 1166 0472 1092 0000 		sts display+3,__zero_reg__
 1167               	.LBB75:
1506:iv.c          **** 
1507:iv.c          ****   // check euro (24h) or US (12h) style time
1508:iv.c          ****   if (region == REGION_US) {
 1169               	.LM162:
 1170 0476 8091 0000 		lds r24,region
 1171 047a 8823      		tst r24
 1172 047c 01F4      		brne .L43
 1173               	.LBB76:
 1174               	.LBB77:
1509:iv.c          ****     display[2] =  pgm_read_byte(numbertable + ( (((h+11)%12)+1) % 10));
 1176               	.LM163:
 1177 047e 812F      		mov r24,r17
 1178 0480 90E0      		ldi r25,lo8(0)
 1179 0482 0B96      		adiw r24,11
 1180 0484 6CE0      		ldi r22,lo8(12)
 1181 0486 70E0      		ldi r23,hi8(12)
 1182 0488 0E94 0000 		call __divmodhi4
 1183 048c 9C01      		movw r18,r24
 1184 048e 2F5F      		subi r18,lo8(-(1))
 1185 0490 3F4F      		sbci r19,hi8(-(1))
 1186 0492 C901      		movw r24,r18
 1187 0494 6AE0      		ldi r22,lo8(10)
 1188 0496 70E0      		ldi r23,hi8(10)
 1189 0498 0E94 0000 		call __divmodhi4
 1190 049c FC01      		movw r30,r24
 1191 049e E050      		subi r30,lo8(-(_ZL11numbertable))
 1192 04a0 F040      		sbci r31,hi8(-(_ZL11numbertable))
 1193               	/* #APP */
 1194               	 ;  1509 "iv.c" 1
 1195 04a2 E491      		lpm r30, Z
 1196               		
 1197               	 ;  0 "" 2
 1198               	/* #NOAPP */
 1199 04a4 E093 0000 		sts display+2,r30
 1200               	.LBE77:
 1201               	.LBB78:
1510:iv.c          ****     display[1] =  pgm_read_byte(numbertable + ( (((h+11)%12)+1) / 10));
 1203               	.LM164:
 1204 04a8 6050      		subi r22,lo8(-(_ZL11numbertable))
 1205 04aa 7040      		sbci r23,hi8(-(_ZL11numbertable))
 1206 04ac FB01      		movw r30,r22
 1207               	/* #APP */
 1208               	 ;  1510 "iv.c" 1
 1209 04ae 6491      		lpm r22, Z
 1210               		
 1211               	 ;  0 "" 2
 1212               	/* #NOAPP */
 1213 04b0 6093 0000 		sts display+1,r22
 1214               	.LBE78:
1511:iv.c          **** 
1512:iv.c          ****     // We use the '*' as an am/pm notice
1513:iv.c          ****     if (h >= 12)
 1216               	.LM165:
 1217 04b4 1C30      		cpi r17,lo8(12)
 1218 04b6 00F0      		brlo .L44
1514:iv.c          ****       display[0] |= 0x1;  // 'pm' notice
 1220               	.LM166:
 1221 04b8 8091 0000 		lds r24,display
 1222 04bc 8160      		ori r24,lo8(1)
 1223 04be 00C0      		rjmp .L46
 1224               	.L44:
1515:iv.c          ****     else 
1516:iv.c          ****       display[0] &= ~0x1;  // 'pm' notice
 1226               	.LM167:
 1227 04c0 8091 0000 		lds r24,display
 1228 04c4 8E7F      		andi r24,lo8(-2)
 1229               	.L46:
 1230 04c6 8093 0000 		sts display,r24
 1231 04ca 00C0      		rjmp .L42
 1232               	.L43:
 1233               	.LBE76:
 1234               	.LBB79:
1517:iv.c          ****   } else {
1518:iv.c          ****     display[2] =  pgm_read_byte(numbertable + ( (h%24) % 10));
 1236               	.LM168:
 1237 04cc 812F      		mov r24,r17
 1238 04ce 68E1      		ldi r22,lo8(24)
 1239 04d0 0E94 0000 		call __udivmodqi4
 1240 04d4 892F      		mov r24,r25
 1241 04d6 632F      		mov r22,r19
 1242 04d8 0E94 0000 		call __udivmodqi4
 1243 04dc E92F      		mov r30,r25
 1244 04de F0E0      		ldi r31,lo8(0)
 1245 04e0 E050      		subi r30,lo8(-(_ZL11numbertable))
 1246 04e2 F040      		sbci r31,hi8(-(_ZL11numbertable))
 1247               	/* #APP */
 1248               	 ;  1518 "iv.c" 1
 1249 04e4 E491      		lpm r30, Z
 1250               		
 1251               	 ;  0 "" 2
 1252               	/* #NOAPP */
 1253 04e6 E093 0000 		sts display+2,r30
 1254               	.LBE79:
 1255               	.LBB80:
1519:iv.c          ****     display[1] =  pgm_read_byte(numbertable + ( (h%24) / 10));
 1257               	.LM169:
 1258 04ea E82F      		mov r30,r24
 1259 04ec F0E0      		ldi r31,lo8(0)
 1260 04ee E050      		subi r30,lo8(-(_ZL11numbertable))
 1261 04f0 F040      		sbci r31,hi8(-(_ZL11numbertable))
 1262               	/* #APP */
 1263               	 ;  1519 "iv.c" 1
 1264 04f2 E491      		lpm r30, Z
 1265               		
 1266               	 ;  0 "" 2
 1267               	/* #NOAPP */
 1268 04f4 E093 0000 		sts display+1,r30
 1269               	.L42:
 1270               	/* epilogue start */
 1271               	.LBE80:
 1272               	.LBE75:
 1273               	.LBE70:
1520:iv.c          ****   }
1521:iv.c          **** }
 1275               	.LM170:
 1276 04f8 1F91      		pop r17
 1277 04fa 0895      		ret
 1279               	.Lscope12:
 1281               		.stabd	78,0,0
 1283               	.global	_Z8set_timev
 1285               	_Z8set_timev:
 1286               		.stabd	46,0,0
 756:iv.c          **** {
 1288               	.LM171:
 1289               	.LFBB13:
 1290 04fc 8F92      		push r8
 1291 04fe 9F92      		push r9
 1292 0500 BF92      		push r11
 1293 0502 CF92      		push r12
 1294 0504 DF92      		push r13
 1295 0506 EF92      		push r14
 1296 0508 FF92      		push r15
 1297 050a 0F93      		push r16
 1298 050c 1F93      		push r17
 1299 050e DF93      		push r29
 1300 0510 CF93      		push r28
 1301 0512 0F92      		push __tmp_reg__
 1302 0514 CDB7      		in r28,__SP_L__
 1303 0516 DEB7      		in r29,__SP_H__
 1304               	/* prologue: function */
 1305               	/* frame size = 1 */
 1306               	/* stack size = 12 */
 1307               	.L__stack_usage = 12
 1308               	.LBB81:
 760:iv.c          ****   hour = time_h;
 1310               	.LM172:
 1311 0518 D090 0000 		lds r13,time_h
 761:iv.c          ****   min = time_m;
 1313               	.LM173:
 1314 051c E090 0000 		lds r14,time_m
 762:iv.c          ****   sec = time_s;
 1316               	.LM174:
 1317 0520 F090 0000 		lds r15,time_s
 765:iv.c          ****   timeoutcounter = INACTIVITYTIMEOUT;
 1319               	.LM175:
 1320 0524 8AE0      		ldi r24,lo8(10)
 1321 0526 8093 0000 		sts timeoutcounter,r24
 763:iv.c          ****   mode = SHOW_MENU;
 1323               	.LM176:
 1324 052a 20E0      		ldi r18,lo8(0)
 772:iv.c          ****       timeoutcounter = INACTIVITYTIMEOUT;  
 1326               	.LM177:
 1327 052c 5AE0      		ldi r21,lo8(10)
 1328 052e C52E      		mov r12,r21
 830:iv.c          **** 	sec = (sec+1) % 60;
 1330               	.LM178:
 1331 0530 4CE3      		ldi r20,lo8(60)
 1332 0532 842E      		mov r8,r20
 1333 0534 912C      		mov r9,__zero_reg__
 814:iv.c          **** 	hour = (hour+1) % 24;
 1335               	.LM179:
 1336 0536 08E1      		ldi r16,lo8(24)
 1337 0538 10E0      		ldi r17,hi8(24)
 1338               	.L65:
 768:iv.c          ****     if (just_pressed & 0x1) { // mode change
 1340               	.LM180:
 1341 053a 8091 0000 		lds r24,just_pressed
 1342 053e 80FD      		sbrc r24,0
 1343 0540 00C0      		rjmp .L47
 771:iv.c          ****     if (just_pressed || pressed) {
 1345               	.LM181:
 1346 0542 8091 0000 		lds r24,just_pressed
 1347 0546 8823      		tst r24
 1348 0548 01F4      		brne .L50
 771:iv.c          ****     if (just_pressed || pressed) {
 1350               	.LM182:
 1351 054a 8091 0000 		lds r24,pressed
 1352 054e 8823      		tst r24
 1353 0550 01F4      		brne .+2
 1354 0552 00C0      		rjmp .L51
 1355               	.L50:
 772:iv.c          ****       timeoutcounter = INACTIVITYTIMEOUT;  
 1357               	.LM183:
 1358 0554 C092 0000 		sts timeoutcounter,r12
 1359               	.L52:
 779:iv.c          ****     if (just_pressed & 0x2) {
 1361               	.LM184:
 1362 0558 8091 0000 		lds r24,just_pressed
 1363 055c 81FF      		sbrs r24,1
 1364 055e 00C0      		rjmp .L53
 780:iv.c          ****       just_pressed = 0;
 1366               	.LM185:
 1367 0560 1092 0000 		sts just_pressed,__zero_reg__
 781:iv.c          ****       if (mode == SHOW_MENU) {
 1369               	.LM186:
 1370 0564 2223      		tst r18
 1371 0566 01F4      		brne .L54
 782:iv.c          **** 	hour = time_h;
 1373               	.LM187:
 1374 0568 D090 0000 		lds r13,time_h
 783:iv.c          **** 	min = time_m;
 1376               	.LM188:
 1377 056c E090 0000 		lds r14,time_m
 784:iv.c          **** 	sec = time_s;
 1379               	.LM189:
 1380 0570 F090 0000 		lds r15,time_s
 788:iv.c          **** 	display_time(hour, min, sec);
 1382               	.LM190:
 1383 0574 8D2D      		mov r24,r13
 1384 0576 6E2D      		mov r22,r14
 1385 0578 4F2D      		mov r20,r15
 1386 057a 0E94 0000 		call _Z12display_timehhh
 789:iv.c          **** 	display[1] |= 0x1;
 1388               	.LM191:
 1389 057e 8091 0000 		lds r24,display+1
 1390 0582 8160      		ori r24,lo8(1)
 1391 0584 8093 0000 		sts display+1,r24
 790:iv.c          **** 	display[2] |= 0x1;	
 1393               	.LM192:
 1394 0588 8091 0000 		lds r24,display+2
 1395 058c 8160      		ori r24,lo8(1)
 1396 058e 8093 0000 		sts display+2,r24
 787:iv.c          **** 	mode = SET_HOUR;
 1398               	.LM193:
 1399 0592 21E0      		ldi r18,lo8(1)
 1400 0594 00C0      		rjmp .L53
 1401               	.L54:
 791:iv.c          ****       } else if (mode == SET_HOUR) {
 1403               	.LM194:
 1404 0596 2130      		cpi r18,lo8(1)
 1405 0598 01F4      		brne .L55
 793:iv.c          **** 	display_time(hour, min, sec);
 1407               	.LM195:
 1408 059a 8D2D      		mov r24,r13
 1409 059c 6E2D      		mov r22,r14
 1410 059e 4F2D      		mov r20,r15
 1411 05a0 0E94 0000 		call _Z12display_timehhh
 794:iv.c          **** 	display[4] |= 0x1;
 1413               	.LM196:
 1414 05a4 8091 0000 		lds r24,display+4
 1415 05a8 8160      		ori r24,lo8(1)
 1416 05aa 8093 0000 		sts display+4,r24
 795:iv.c          **** 	display[5] |= 0x1;
 1418               	.LM197:
 1419 05ae 8091 0000 		lds r24,display+5
 1420 05b2 8160      		ori r24,lo8(1)
 1421 05b4 8093 0000 		sts display+5,r24
 792:iv.c          **** 	mode = SET_MIN;
 1423               	.LM198:
 1424 05b8 22E0      		ldi r18,lo8(2)
 1425 05ba 00C0      		rjmp .L53
 1426               	.L55:
 796:iv.c          ****       } else if (mode == SET_MIN) {
 1428               	.LM199:
 1429 05bc 2230      		cpi r18,lo8(2)
 1430 05be 01F4      		brne .L56
 798:iv.c          **** 	display_time(hour, min, sec);
 1432               	.LM200:
 1433 05c0 8D2D      		mov r24,r13
 1434 05c2 6E2D      		mov r22,r14
 1435 05c4 4F2D      		mov r20,r15
 1436 05c6 0E94 0000 		call _Z12display_timehhh
 799:iv.c          **** 	display[7] |= 0x1;
 1438               	.LM201:
 1439 05ca 8091 0000 		lds r24,display+7
 1440 05ce 8160      		ori r24,lo8(1)
 1441 05d0 8093 0000 		sts display+7,r24
 800:iv.c          **** 	display[8] |= 0x1;
 1443               	.LM202:
 1444 05d4 8091 0000 		lds r24,display+8
 1445 05d8 8160      		ori r24,lo8(1)
 1446 05da 8093 0000 		sts display+8,r24
 797:iv.c          **** 	mode = SET_SEC;
 1448               	.LM203:
 1449 05de 23E0      		ldi r18,lo8(3)
 1450 05e0 00C0      		rjmp .L53
 1451               	.L56:
 803:iv.c          **** 	time_h = hour;
 1453               	.LM204:
 1454 05e2 D092 0000 		sts time_h,r13
 804:iv.c          **** 	time_m = min;
 1456               	.LM205:
 1457 05e6 E092 0000 		sts time_m,r14
 805:iv.c          **** 	time_s = sec;
 1459               	.LM206:
 1460 05ea F092 0000 		sts time_s,r15
 1461               	.L67:
 806:iv.c          **** 	displaymode = SHOW_TIME;
 1463               	.LM207:
 1464 05ee 1092 0000 		sts displaymode,__zero_reg__
 1465 05f2 00C0      		rjmp .L47
 1466               	.L53:
 810:iv.c          ****     if ((just_pressed & 0x4) || (pressed & 0x4)) {
 1468               	.LM208:
 1469 05f4 8091 0000 		lds r24,just_pressed
 1470 05f8 82FD      		sbrc r24,2
 1471 05fa 00C0      		rjmp .L57
 810:iv.c          ****     if ((just_pressed & 0x4) || (pressed & 0x4)) {
 1473               	.LM209:
 1474 05fc 8091 0000 		lds r24,pressed
 1475 0600 82FF      		sbrs r24,2
 1476 0602 00C0      		rjmp .L65
 1477               	.L57:
 811:iv.c          ****       just_pressed = 0;
 1479               	.LM210:
 1480 0604 1092 0000 		sts just_pressed,__zero_reg__
 813:iv.c          ****       if (mode == SET_HOUR) {
 1482               	.LM211:
 1483 0608 2130      		cpi r18,lo8(1)
 1484 060a 01F4      		brne .L59
 814:iv.c          **** 	hour = (hour+1) % 24;
 1486               	.LM212:
 1487 060c 8D2D      		mov r24,r13
 1488 060e 90E0      		ldi r25,lo8(0)
 1489 0610 0196      		adiw r24,1
 1490 0612 B801      		movw r22,r16
 1491 0614 0E94 0000 		call __divmodhi4
 1492 0618 B82E      		mov r11,r24
 1493 061a D82E      		mov r13,r24
 815:iv.c          **** 	display_time(hour, min, sec);
 1495               	.LM213:
 1496 061c 6E2D      		mov r22,r14
 1497 061e 4F2D      		mov r20,r15
 1498 0620 2983      		std Y+1,r18
 1499 0622 0E94 0000 		call _Z12display_timehhh
 816:iv.c          **** 	display[1] |= 0x1;
 1501               	.LM214:
 1502 0626 8091 0000 		lds r24,display+1
 1503 062a 8160      		ori r24,lo8(1)
 1504 062c 8093 0000 		sts display+1,r24
 817:iv.c          **** 	display[2] |= 0x1;
 1506               	.LM215:
 1507 0630 8091 0000 		lds r24,display+2
 1508 0634 8160      		ori r24,lo8(1)
 1509 0636 8093 0000 		sts display+2,r24
 818:iv.c          **** 	time_h = hour;
 1511               	.LM216:
 1512 063a B092 0000 		sts time_h,r11
 819:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_HOUR, time_h);    
 1514               	.LM217:
 1515 063e 6091 0000 		lds r22,time_h
 1516 0642 84E0      		ldi r24,lo8(4)
 1517 0644 90E0      		ldi r25,hi8(4)
 1518 0646 0E94 0000 		call __eewr_byte_m328p
 1519 064a 00C0      		rjmp .L66
 1520               	.L59:
 821:iv.c          ****       if (mode == SET_MIN) {
 1522               	.LM218:
 1523 064c 2230      		cpi r18,lo8(2)
 1524 064e 01F4      		brne .L61
 822:iv.c          **** 	min = (min+1) % 60;
 1526               	.LM219:
 1527 0650 8E2D      		mov r24,r14
 1528 0652 90E0      		ldi r25,lo8(0)
 1529 0654 0196      		adiw r24,1
 1530 0656 B401      		movw r22,r8
 1531 0658 0E94 0000 		call __divmodhi4
 1532 065c B82E      		mov r11,r24
 1533 065e E82E      		mov r14,r24
 823:iv.c          **** 	display_time(hour, min, sec);
 1535               	.LM220:
 1536 0660 8D2D      		mov r24,r13
 1537 0662 6B2D      		mov r22,r11
 1538 0664 4F2D      		mov r20,r15
 1539 0666 2983      		std Y+1,r18
 1540 0668 0E94 0000 		call _Z12display_timehhh
 824:iv.c          **** 	display[4] |= 0x1;
 1542               	.LM221:
 1543 066c 8091 0000 		lds r24,display+4
 1544 0670 8160      		ori r24,lo8(1)
 1545 0672 8093 0000 		sts display+4,r24
 825:iv.c          **** 	display[5] |= 0x1;
 1547               	.LM222:
 1548 0676 8091 0000 		lds r24,display+5
 1549 067a 8160      		ori r24,lo8(1)
 1550 067c 8093 0000 		sts display+5,r24
 826:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_MIN, time_m);
 1552               	.LM223:
 1553 0680 6091 0000 		lds r22,time_m
 1554 0684 85E0      		ldi r24,lo8(5)
 1555 0686 90E0      		ldi r25,hi8(5)
 1556 0688 0E94 0000 		call __eewr_byte_m328p
 827:iv.c          **** 	time_m = min;
 1558               	.LM224:
 1559 068c B092 0000 		sts time_m,r11
 1560 0690 00C0      		rjmp .L66
 1561               	.L61:
 829:iv.c          ****       if ((mode == SET_SEC) ) {
 1563               	.LM225:
 1564 0692 2330      		cpi r18,lo8(3)
 1565 0694 01F4      		brne .L60
 830:iv.c          **** 	sec = (sec+1) % 60;
 1567               	.LM226:
 1568 0696 8F2D      		mov r24,r15
 1569 0698 90E0      		ldi r25,lo8(0)
 1570 069a 0196      		adiw r24,1
 1571 069c B401      		movw r22,r8
 1572 069e 0E94 0000 		call __divmodhi4
 1573 06a2 B82E      		mov r11,r24
 1574 06a4 F82E      		mov r15,r24
 831:iv.c          **** 	display_time(hour, min, sec);
 1576               	.LM227:
 1577 06a6 8D2D      		mov r24,r13
 1578 06a8 6E2D      		mov r22,r14
 1579 06aa 4B2D      		mov r20,r11
 1580 06ac 2983      		std Y+1,r18
 1581 06ae 0E94 0000 		call _Z12display_timehhh
 832:iv.c          **** 	display[7] |= 0x1;
 1583               	.LM228:
 1584 06b2 8091 0000 		lds r24,display+7
 1585 06b6 8160      		ori r24,lo8(1)
 1586 06b8 8093 0000 		sts display+7,r24
 833:iv.c          **** 	display[8] |= 0x1;
 1588               	.LM229:
 1589 06bc 8091 0000 		lds r24,display+8
 1590 06c0 8160      		ori r24,lo8(1)
 1591 06c2 8093 0000 		sts display+8,r24
 834:iv.c          **** 	time_s = sec;
 1593               	.LM230:
 1594 06c6 B092 0000 		sts time_s,r11
 1595               	.L66:
 1596 06ca 2981      		ldd r18,Y+1
 1597               	.L60:
 837:iv.c          ****       if (pressed & 0x4)
 1599               	.LM231:
 1600 06cc 8091 0000 		lds r24,pressed
 1601 06d0 82FF      		sbrs r24,2
 1602 06d2 00C0      		rjmp .L65
 838:iv.c          **** 	delayms(75);
 1604               	.LM232:
 1605 06d4 8BE4      		ldi r24,lo8(75)
 1606 06d6 90E0      		ldi r25,hi8(75)
 1607 06d8 2983      		std Y+1,r18
 1608 06da 0E94 0000 		call _Z7delaymsj
 1609 06de 2981      		ldd r18,Y+1
 1610 06e0 00C0      		rjmp .L65
 1611               	.L51:
 774:iv.c          ****     } else if (!timeoutcounter) {
 1613               	.LM233:
 1614 06e2 8091 0000 		lds r24,timeoutcounter
 1615 06e6 8823      		tst r24
 1616 06e8 01F0      		breq .+2
 1617 06ea 00C0      		rjmp .L52
 1618 06ec 00C0      		rjmp .L67
 1619               	.L47:
 1620               	/* epilogue start */
 1621               	.LBE81:
 841:iv.c          **** }
 1623               	.LM234:
 1624 06ee 0F90      		pop __tmp_reg__
 1625 06f0 CF91      		pop r28
 1626 06f2 DF91      		pop r29
 1627 06f4 1F91      		pop r17
 1628 06f6 0F91      		pop r16
 1629 06f8 FF90      		pop r15
 1630 06fa EF90      		pop r14
 1631 06fc DF90      		pop r13
 1632 06fe CF90      		pop r12
 1633 0700 BF90      		pop r11
 1634 0702 9F90      		pop r9
 1635 0704 8F90      		pop r8
 1636 0706 0895      		ret
 1644               	.Lscope13:
 1646               		.stabd	78,0,0
 1650               	.global	_Z13display_alarmhh
 1652               	_Z13display_alarmhh:
 1653               		.stabd	46,0,0
1522:iv.c          **** 
1523:iv.c          **** // Kinda like display_time but just hours and minutes
1524:iv.c          **** void display_alarm(uint8_t h, uint8_t m){ 
 1655               	.LM235:
 1656               	.LFBB14:
 1657               	/* prologue: function */
 1658               	/* frame size = 0 */
 1659               	/* stack size = 0 */
 1660               	.L__stack_usage = 0
 1661 0708 282F      		mov r18,r24
 1662 070a 862F      		mov r24,r22
 1663               	.LBB82:
1525:iv.c          ****   display[8] = 0;
 1665               	.LM236:
 1666 070c 1092 0000 		sts display+8,__zero_reg__
1526:iv.c          ****   display[7] = 0;
 1668               	.LM237:
 1669 0710 1092 0000 		sts display+7,__zero_reg__
1527:iv.c          ****   display[6] = 0;
 1671               	.LM238:
 1672 0714 1092 0000 		sts display+6,__zero_reg__
 1673               	.LBB83:
1528:iv.c          ****   display[5] = pgm_read_byte(numbertable + (m % 10));
 1675               	.LM239:
 1676 0718 6AE0      		ldi r22,lo8(10)
 1677 071a 0E94 0000 		call __udivmodqi4
 1678 071e E92F      		mov r30,r25
 1679 0720 F0E0      		ldi r31,lo8(0)
 1680 0722 E050      		subi r30,lo8(-(_ZL11numbertable))
 1681 0724 F040      		sbci r31,hi8(-(_ZL11numbertable))
 1682               	/* #APP */
 1683               	 ;  1528 "iv.c" 1
 1684 0726 E491      		lpm r30, Z
 1685               		
 1686               	 ;  0 "" 2
 1687               	/* #NOAPP */
 1688 0728 E093 0000 		sts display+5,r30
 1689               	.LBE83:
 1690               	.LBB84:
1529:iv.c          ****   display[4] = pgm_read_byte(numbertable + (m / 10)); 
 1692               	.LM240:
 1693 072c E82F      		mov r30,r24
 1694 072e F0E0      		ldi r31,lo8(0)
 1695 0730 E050      		subi r30,lo8(-(_ZL11numbertable))
 1696 0732 F040      		sbci r31,hi8(-(_ZL11numbertable))
 1697               	/* #APP */
 1698               	 ;  1529 "iv.c" 1
 1699 0734 E491      		lpm r30, Z
 1700               		
 1701               	 ;  0 "" 2
 1702               	/* #NOAPP */
 1703 0736 E093 0000 		sts display+4,r30
 1704               	.LBE84:
1530:iv.c          ****   display[3] = 0;
 1706               	.LM241:
 1707 073a 1092 0000 		sts display+3,__zero_reg__
 1708               	.LBB85:
1531:iv.c          **** 
1532:iv.c          ****   // check euro or US style time
1533:iv.c          ****   if (region == REGION_US) {
 1710               	.LM242:
 1711 073e 8091 0000 		lds r24,region
 1712 0742 8823      		tst r24
 1713 0744 01F4      		brne .L69
 1714               	.LBB86:
1534:iv.c          ****     if (h >= 12) {
 1716               	.LM243:
 1717 0746 2C30      		cpi r18,lo8(12)
 1718 0748 00F0      		brlo .L70
 1719               	.LBB87:
1535:iv.c          ****       display[0] |= 0x1;  // 'pm' notice
 1721               	.LM244:
 1722 074a 8091 0000 		lds r24,display
 1723 074e 8160      		ori r24,lo8(1)
 1724 0750 8093 0000 		sts display,r24
 1725               	.LBB88:
1536:iv.c          ****       display[7] = pgm_read_byte(alphatable + 'p' - 'a');
 1727               	.LM245:
 1728 0754 E0E0      		ldi r30,lo8(_ZL10alphatable+15)
 1729 0756 F0E0      		ldi r31,hi8(_ZL10alphatable+15)
 1730               	/* #APP */
 1731               	 ;  1536 "iv.c" 1
 1732 0758 E491      		lpm r30, Z
 1733               		
 1734               	 ;  0 "" 2
 1735               	/* #NOAPP */
 1736 075a E093 0000 		sts display+7,r30
 1737 075e 00C0      		rjmp .L71
 1738               	.L70:
 1739               	.LBE88:
 1740               	.LBE87:
 1741               	.LBB89:
 1742               	.LBB90:
1537:iv.c          ****     } else {
1538:iv.c          ****       display[7] = pgm_read_byte(alphatable + 'a' - 'a');
 1744               	.LM246:
 1745 0760 E0E0      		ldi r30,lo8(_ZL10alphatable)
 1746 0762 F0E0      		ldi r31,hi8(_ZL10alphatable)
 1747               	/* #APP */
 1748               	 ;  1538 "iv.c" 1
 1749 0764 E491      		lpm r30, Z
 1750               		
 1751               	 ;  0 "" 2
 1752               	/* #NOAPP */
 1753 0766 E093 0000 		sts display+7,r30
 1754               	.LBE90:
1539:iv.c          ****       display[0] &= ~0x1;  // 'am' notice
 1756               	.LM247:
 1757 076a 8091 0000 		lds r24,display
 1758 076e 8E7F      		andi r24,lo8(-2)
 1759 0770 8093 0000 		sts display,r24
 1760               	.L71:
 1761               	.LBE89:
 1762               	.LBE86:
 1763               	.LBB91:
1540:iv.c          ****     }
1541:iv.c          ****     display[8] = pgm_read_byte(alphatable + 'm' - 'a');
 1765               	.LM248:
 1766 0774 E0E0      		ldi r30,lo8(_ZL10alphatable+12)
 1767 0776 F0E0      		ldi r31,hi8(_ZL10alphatable+12)
 1768               	/* #APP */
 1769               	 ;  1541 "iv.c" 1
 1770 0778 E491      		lpm r30, Z
 1771               		
 1772               	 ;  0 "" 2
 1773               	/* #NOAPP */
 1774 077a E093 0000 		sts display+8,r30
 1775               	.LBE91:
 1776               	.LBB92:
1542:iv.c          **** 
1543:iv.c          ****     display[2] =  pgm_read_byte(numbertable + ( (((h+11)%12)+1) % 10));
 1778               	.LM249:
 1779 077e 822F      		mov r24,r18
 1780 0780 90E0      		ldi r25,lo8(0)
 1781 0782 0B96      		adiw r24,11
 1782 0784 6CE0      		ldi r22,lo8(12)
 1783 0786 70E0      		ldi r23,hi8(12)
 1784 0788 00C0      		rjmp .L73
 1785               	.L69:
 1786               	.LBE92:
 1787               	.LBB93:
1544:iv.c          ****     display[1] =  pgm_read_byte(numbertable + ( (((h+11)%12)+1) / 10));
1545:iv.c          ****   } else {
1546:iv.c          ****       display[2] =  pgm_read_byte(numbertable + ( (((h+23)%24)+1) % 10));
 1789               	.LM250:
 1790 078a 822F      		mov r24,r18
 1791 078c 90E0      		ldi r25,lo8(0)
 1792 078e 4796      		adiw r24,23
 1793 0790 68E1      		ldi r22,lo8(24)
 1794 0792 70E0      		ldi r23,hi8(24)
 1795               	.L73:
 1796 0794 0E94 0000 		call __divmodhi4
 1797 0798 0196      		adiw r24,1
 1798 079a 6AE0      		ldi r22,lo8(10)
 1799 079c 70E0      		ldi r23,hi8(10)
 1800 079e 0E94 0000 		call __divmodhi4
 1801 07a2 FC01      		movw r30,r24
 1802 07a4 E050      		subi r30,lo8(-(_ZL11numbertable))
 1803 07a6 F040      		sbci r31,hi8(-(_ZL11numbertable))
 1804               	/* #APP */
 1805               	 ;  1546 "iv.c" 1
 1806 07a8 E491      		lpm r30, Z
 1807               		
 1808               	 ;  0 "" 2
 1809               	/* #NOAPP */
 1810 07aa E093 0000 		sts display+2,r30
 1811               	.LBE93:
 1812               	.LBB94:
1547:iv.c          ****     display[1] =  pgm_read_byte(numbertable + ( (((h+23)%24)+1) / 10));
 1814               	.LM251:
 1815 07ae 6050      		subi r22,lo8(-(_ZL11numbertable))
 1816 07b0 7040      		sbci r23,hi8(-(_ZL11numbertable))
 1817 07b2 FB01      		movw r30,r22
 1818               	/* #APP */
 1819               	 ;  1547 "iv.c" 1
 1820 07b4 6491      		lpm r22, Z
 1821               		
 1822               	 ;  0 "" 2
 1823               	/* #NOAPP */
 1824 07b6 6093 0000 		sts display+1,r22
 1825 07ba 0895      		ret
 1826               	.LBE94:
 1827               	.LBE85:
 1828               	.LBE82:
 1830               	.Lscope14:
 1832               		.stabd	78,0,0
 1834               	.global	_Z9set_alarmv
 1836               	_Z9set_alarmv:
 1837               		.stabd	46,0,0
 681:iv.c          **** {
 1839               	.LM252:
 1840               	.LFBB15:
 1841 07bc AF92      		push r10
 1842 07be BF92      		push r11
 1843 07c0 DF92      		push r13
 1844 07c2 EF92      		push r14
 1845 07c4 FF92      		push r15
 1846 07c6 0F93      		push r16
 1847 07c8 1F93      		push r17
 1848 07ca DF93      		push r29
 1849 07cc CF93      		push r28
 1850 07ce 0F92      		push __tmp_reg__
 1851 07d0 CDB7      		in r28,__SP_L__
 1852 07d2 DEB7      		in r29,__SP_H__
 1853               	/* prologue: function */
 1854               	/* frame size = 1 */
 1855               	/* stack size = 10 */
 1856               	.L__stack_usage = 10
 1857               	.LBB95:
 688:iv.c          ****   hour = alarm_h;
 1859               	.LM253:
 1860 07d4 E090 0000 		lds r14,alarm_h
 689:iv.c          ****   min = alarm_m;
 1862               	.LM254:
 1863 07d8 D090 0000 		lds r13,alarm_m
 692:iv.c          ****   timeoutcounter = INACTIVITYTIMEOUT;
 1865               	.LM255:
 1866 07dc 8AE0      		ldi r24,lo8(10)
 1867 07de 8093 0000 		sts timeoutcounter,r24
 686:iv.c          ****   mode = SHOW_MENU;
 1869               	.LM256:
 1870 07e2 40E0      		ldi r20,lo8(0)
 699:iv.c          ****       timeoutcounter = INACTIVITYTIMEOUT;  
 1872               	.LM257:
 1873 07e4 7AE0      		ldi r23,lo8(10)
 1874 07e6 F72E      		mov r15,r23
 743:iv.c          **** 	min = (min+1) % 60;
 1876               	.LM258:
 1877 07e8 6CE3      		ldi r22,lo8(60)
 1878 07ea A62E      		mov r10,r22
 1879 07ec B12C      		mov r11,__zero_reg__
 737:iv.c          **** 	hour = (hour+1) % 24;
 1881               	.LM259:
 1882 07ee 08E1      		ldi r16,lo8(24)
 1883 07f0 10E0      		ldi r17,hi8(24)
 1884               	.L90:
 695:iv.c          ****     if (just_pressed & 0x1) { // mode change
 1886               	.LM260:
 1887 07f2 8091 0000 		lds r24,just_pressed
 1888 07f6 80FD      		sbrc r24,0
 1889 07f8 00C0      		rjmp .L74
 698:iv.c          ****     if (just_pressed || pressed) {
 1891               	.LM261:
 1892 07fa 8091 0000 		lds r24,just_pressed
 1893 07fe 8823      		tst r24
 1894 0800 01F4      		brne .L77
 698:iv.c          ****     if (just_pressed || pressed) {
 1896               	.LM262:
 1897 0802 8091 0000 		lds r24,pressed
 1898 0806 8823      		tst r24
 1899 0808 01F4      		brne .+2
 1900 080a 00C0      		rjmp .L78
 1901               	.L77:
 699:iv.c          ****       timeoutcounter = INACTIVITYTIMEOUT;  
 1903               	.LM263:
 1904 080c F092 0000 		sts timeoutcounter,r15
 1905 0810 00C0      		rjmp .L79
 1906               	.L92:
 703:iv.c          ****       displaymode = SHOW_TIME;     
 1908               	.LM264:
 1909 0812 1092 0000 		sts displaymode,__zero_reg__
 704:iv.c          ****       alarm_h = hour;
 1911               	.LM265:
 1912 0816 E092 0000 		sts alarm_h,r14
 705:iv.c          ****       alarm_m = min;
 1914               	.LM266:
 1915 081a D092 0000 		sts alarm_m,r13
 706:iv.c          ****       eeprom_write_byte((uint8_t *)EE_ALARM_HOUR, alarm_h);    
 1917               	.LM267:
 1918 081e 6091 0000 		lds r22,alarm_h
 1919 0822 87E0      		ldi r24,lo8(7)
 1920 0824 90E0      		ldi r25,hi8(7)
 1921 0826 0E94 0000 		call __eewr_byte_m328p
 707:iv.c          ****       eeprom_write_byte((uint8_t *)EE_ALARM_MIN, alarm_m);    
 1923               	.LM268:
 1924 082a 6091 0000 		lds r22,alarm_m
 1925 082e 88E0      		ldi r24,lo8(8)
 1926 0830 90E0      		ldi r25,hi8(8)
 1927 0832 0E94 0000 		call __eewr_byte_m328p
 708:iv.c          ****       return;
 1929               	.LM269:
 1930 0836 00C0      		rjmp .L74
 1931               	.L79:
 710:iv.c          ****     if (just_pressed & 0x2) {
 1933               	.LM270:
 1934 0838 8091 0000 		lds r24,just_pressed
 1935 083c 81FF      		sbrs r24,1
 1936 083e 00C0      		rjmp .L80
 711:iv.c          ****       just_pressed = 0;
 1938               	.LM271:
 1939 0840 1092 0000 		sts just_pressed,__zero_reg__
 712:iv.c          ****       if (mode == SHOW_MENU) {
 1941               	.LM272:
 1942 0844 4423      		tst r20
 1943 0846 01F4      		brne .L81
 715:iv.c          **** 	display_alarm(hour, min);
 1945               	.LM273:
 1946 0848 8E2D      		mov r24,r14
 1947 084a 6D2D      		mov r22,r13
 1948 084c 0E94 0000 		call _Z13display_alarmhh
 716:iv.c          **** 	display[1] |= 0x1;
 1950               	.LM274:
 1951 0850 8091 0000 		lds r24,display+1
 1952 0854 8160      		ori r24,lo8(1)
 1953 0856 8093 0000 		sts display+1,r24
 717:iv.c          **** 	display[2] |= 0x1;	
 1955               	.LM275:
 1956 085a 8091 0000 		lds r24,display+2
 1957 085e 8160      		ori r24,lo8(1)
 1958 0860 8093 0000 		sts display+2,r24
 714:iv.c          **** 	mode = SET_HOUR;
 1960               	.LM276:
 1961 0864 41E0      		ldi r20,lo8(1)
 1962 0866 00C0      		rjmp .L80
 1963               	.L81:
 718:iv.c          ****       } else if (mode == SET_HOUR) {
 1965               	.LM277:
 1966 0868 4130      		cpi r20,lo8(1)
 1967 086a 01F4      		brne .L82
 720:iv.c          **** 	display_alarm(hour, min);
 1969               	.LM278:
 1970 086c 8E2D      		mov r24,r14
 1971 086e 6D2D      		mov r22,r13
 1972 0870 0E94 0000 		call _Z13display_alarmhh
 721:iv.c          **** 	display[4] |= 0x1;
 1974               	.LM279:
 1975 0874 8091 0000 		lds r24,display+4
 1976 0878 8160      		ori r24,lo8(1)
 1977 087a 8093 0000 		sts display+4,r24
 722:iv.c          **** 	display[5] |= 0x1;
 1979               	.LM280:
 1980 087e 8091 0000 		lds r24,display+5
 1981 0882 8160      		ori r24,lo8(1)
 1982 0884 8093 0000 		sts display+5,r24
 719:iv.c          **** 	mode = SET_MIN;
 1984               	.LM281:
 1985 0888 42E0      		ldi r20,lo8(2)
 1986 088a 00C0      		rjmp .L80
 1987               	.L82:
 725:iv.c          **** 	alarm_h = hour;
 1989               	.LM282:
 1990 088c E092 0000 		sts alarm_h,r14
 726:iv.c          **** 	alarm_m = min;
 1992               	.LM283:
 1993 0890 D092 0000 		sts alarm_m,r13
 727:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_ALARM_HOUR, alarm_h);    
 1995               	.LM284:
 1996 0894 6091 0000 		lds r22,alarm_h
 1997 0898 87E0      		ldi r24,lo8(7)
 1998 089a 90E0      		ldi r25,hi8(7)
 1999 089c 0E94 0000 		call __eewr_byte_m328p
 728:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_ALARM_MIN, alarm_m);    
 2001               	.LM285:
 2002 08a0 6091 0000 		lds r22,alarm_m
 2003 08a4 88E0      		ldi r24,lo8(8)
 2004 08a6 90E0      		ldi r25,hi8(8)
 2005 08a8 0E94 0000 		call __eewr_byte_m328p
 729:iv.c          **** 	displaymode = SHOW_TIME;
 2007               	.LM286:
 2008 08ac 1092 0000 		sts displaymode,__zero_reg__
 2009 08b0 00C0      		rjmp .L74
 2010               	.L80:
 733:iv.c          ****     if ((just_pressed & 0x4) || (pressed & 0x4)) {
 2012               	.LM287:
 2013 08b2 8091 0000 		lds r24,just_pressed
 2014 08b6 82FD      		sbrc r24,2
 2015 08b8 00C0      		rjmp .L83
 733:iv.c          ****     if ((just_pressed & 0x4) || (pressed & 0x4)) {
 2017               	.LM288:
 2018 08ba 8091 0000 		lds r24,pressed
 2019 08be 82FF      		sbrs r24,2
 2020 08c0 00C0      		rjmp .L90
 2021               	.L83:
 734:iv.c          ****       just_pressed = 0;
 2023               	.LM289:
 2024 08c2 1092 0000 		sts just_pressed,__zero_reg__
 736:iv.c          ****       if (mode == SET_HOUR) {
 2026               	.LM290:
 2027 08c6 4130      		cpi r20,lo8(1)
 2028 08c8 01F4      		brne .L85
 737:iv.c          **** 	hour = (hour+1) % 24;
 2030               	.LM291:
 2031 08ca 8E2D      		mov r24,r14
 2032 08cc 90E0      		ldi r25,lo8(0)
 2033 08ce 0196      		adiw r24,1
 2034 08d0 B801      		movw r22,r16
 2035 08d2 0E94 0000 		call __divmodhi4
 2036 08d6 E82E      		mov r14,r24
 738:iv.c          **** 	display_alarm(hour, min);
 2038               	.LM292:
 2039 08d8 6D2D      		mov r22,r13
 2040 08da 4983      		std Y+1,r20
 2041 08dc 0E94 0000 		call _Z13display_alarmhh
 739:iv.c          **** 	display[1] |= 0x1;
 2043               	.LM293:
 2044 08e0 8091 0000 		lds r24,display+1
 2045 08e4 8160      		ori r24,lo8(1)
 2046 08e6 8093 0000 		sts display+1,r24
 740:iv.c          **** 	display[2] |= 0x1;
 2048               	.LM294:
 2049 08ea 8091 0000 		lds r24,display+2
 2050 08ee 8160      		ori r24,lo8(1)
 2051 08f0 8093 0000 		sts display+2,r24
 2052 08f4 00C0      		rjmp .L91
 2053               	.L85:
 742:iv.c          ****       if (mode == SET_MIN) {
 2055               	.LM295:
 2056 08f6 4230      		cpi r20,lo8(2)
 2057 08f8 01F4      		brne .L86
 743:iv.c          **** 	min = (min+1) % 60;
 2059               	.LM296:
 2060 08fa 8D2D      		mov r24,r13
 2061 08fc 90E0      		ldi r25,lo8(0)
 2062 08fe 0196      		adiw r24,1
 2063 0900 B501      		movw r22,r10
 2064 0902 0E94 0000 		call __divmodhi4
 2065 0906 682F      		mov r22,r24
 2066 0908 D82E      		mov r13,r24
 744:iv.c          **** 	display_alarm(hour, min);
 2068               	.LM297:
 2069 090a 8E2D      		mov r24,r14
 2070 090c 4983      		std Y+1,r20
 2071 090e 0E94 0000 		call _Z13display_alarmhh
 745:iv.c          **** 	display[4] |= 0x1;
 2073               	.LM298:
 2074 0912 8091 0000 		lds r24,display+4
 2075 0916 8160      		ori r24,lo8(1)
 2076 0918 8093 0000 		sts display+4,r24
 746:iv.c          **** 	display[5] |= 0x1;
 2078               	.LM299:
 2079 091c 8091 0000 		lds r24,display+5
 2080 0920 8160      		ori r24,lo8(1)
 2081 0922 8093 0000 		sts display+5,r24
 2082               	.L91:
 2083 0926 4981      		ldd r20,Y+1
 2084               	.L86:
 749:iv.c          ****       if (pressed & 0x4)
 2086               	.LM300:
 2087 0928 8091 0000 		lds r24,pressed
 2088 092c 82FF      		sbrs r24,2
 2089 092e 00C0      		rjmp .L90
 750:iv.c          **** 	delayms(75);
 2091               	.LM301:
 2092 0930 8BE4      		ldi r24,lo8(75)
 2093 0932 90E0      		ldi r25,hi8(75)
 2094 0934 4983      		std Y+1,r20
 2095 0936 0E94 0000 		call _Z7delaymsj
 2096 093a 4981      		ldd r20,Y+1
 2097 093c 00C0      		rjmp .L90
 2098               	.L78:
 701:iv.c          ****     } else if (!timeoutcounter) {
 2100               	.LM302:
 2101 093e 8091 0000 		lds r24,timeoutcounter
 2102 0942 8823      		tst r24
 2103 0944 01F0      		breq .+2
 2104 0946 00C0      		rjmp .L79
 2105 0948 00C0      		rjmp .L92
 2106               	.L74:
 2107               	/* epilogue start */
 2108               	.LBE95:
 753:iv.c          **** }
 2110               	.LM303:
 2111 094a 0F90      		pop __tmp_reg__
 2112 094c CF91      		pop r28
 2113 094e DF91      		pop r29
 2114 0950 1F91      		pop r17
 2115 0952 0F91      		pop r16
 2116 0954 FF90      		pop r15
 2117 0956 EF90      		pop r14
 2118 0958 DF90      		pop r13
 2119 095a BF90      		pop r11
 2120 095c AF90      		pop r10
 2121 095e 0895      		ret
 2128               	.Lscope15:
 2130               		.stabd	78,0,0
 2132               	.global	_Z11display_strPKc
 2134               	_Z11display_strPKc:
 2135               		.stabd	46,0,0
1548:iv.c          ****   }
1549:iv.c          **** }
1550:iv.c          **** 
1551:iv.c          **** // display words (menus, prompts, etc)
1552:iv.c          **** void display_str(const char s[]) {
 2137               	.LM304:
 2138               	.LFBB16:
 2139 0960 EF92      		push r14
 2140 0962 FF92      		push r15
 2141 0964 CF93      		push r28
 2142 0966 DF93      		push r29
 2143               	/* prologue: function */
 2144               	/* frame size = 0 */
 2145               	/* stack size = 4 */
 2146               	.L__stack_usage = 4
 2147               	.LBB96:
1553:iv.c          ****   uint8_t i;
1554:iv.c          **** 
1555:iv.c          ****   // don't use the lefthand dot/slash digit
1556:iv.c          ****   display[0] = 0;
 2149               	.LM305:
 2150 0968 1092 0000 		sts display,__zero_reg__
 2151 096c E82E      		mov r14,r24
 2152 096e E701      		movw r28,r14
 2153 0970 7E01      		movw r14,r28
 2154 0972 F92E      		mov r15,r25
 2155 0974 E701      		movw r28,r14
 2156 0976 A0E0      		ldi r26,lo8(display+1)
 2157 0978 B0E0      		ldi r27,hi8(display+1)
 2158               	.L98:
 2159               	.LBB97:
 2160               	.LBB98:
1557:iv.c          **** 
1558:iv.c          ****   // up to 8 characters
1559:iv.c          ****   for (i=1; i<9; i++) {
1560:iv.c          ****     // check for null-termination
1561:iv.c          ****     if (s[i-1] == 0)
 2162               	.LM306:
 2163 097a E991      		ld r30,Y+
 2164 097c EE23      		tst r30
 2165 097e 01F0      		breq .L93
 2166               	.LBB99:
1562:iv.c          ****       return;
1563:iv.c          **** 
1564:iv.c          ****     // Numbers and leters are looked up in the font table!
1565:iv.c          ****     if ((s[i-1] >= 'a') && (s[i-1] <= 'z')) {
 2168               	.LM307:
 2169 0980 8E2F      		mov r24,r30
 2170 0982 8156      		subi r24,lo8(-(-97))
 2171 0984 8A31      		cpi r24,lo8(26)
 2172 0986 00F4      		brsh .L95
 2173               	.LBB100:
1566:iv.c          ****       display[i] =  pgm_read_byte(alphatable + s[i-1] - 'a');
 2175               	.LM308:
 2176 0988 F0E0      		ldi r31,lo8(0)
 2177 098a E050      		subi r30,lo8(-(_ZL10alphatable-97))
 2178 098c F040      		sbci r31,hi8(-(_ZL10alphatable-97))
 2179 098e 00C0      		rjmp .L100
 2180               	.L95:
 2181               	.LBE100:
 2182               	.LBB101:
1567:iv.c          ****     } else if ((s[i-1] >= '0') && (s[i-1] <= '9')) {
 2184               	.LM309:
 2185 0990 8E2F      		mov r24,r30
 2186 0992 8053      		subi r24,lo8(-(-48))
 2187 0994 8A30      		cpi r24,lo8(10)
 2188 0996 00F4      		brsh .L97
 2189               	.LBB102:
1568:iv.c          ****       display[i] =  pgm_read_byte(numbertable + s[i-1] - '0');
 2191               	.LM310:
 2192 0998 F0E0      		ldi r31,lo8(0)
 2193 099a E050      		subi r30,lo8(-(_ZL11numbertable-48))
 2194 099c F040      		sbci r31,hi8(-(_ZL11numbertable-48))
 2195               	.L100:
 2196               	/* #APP */
 2197               	 ;  1568 "iv.c" 1
 2198 099e E491      		lpm r30, Z
 2199               		
 2200               	 ;  0 "" 2
 2201               	/* #NOAPP */
 2202 09a0 EC93      		st X,r30
 2203 09a2 00C0      		rjmp .L96
 2204               	.L97:
 2205               	.LBE102:
1569:iv.c          ****     } else {
1570:iv.c          ****       display[i] = 0;      // spaces and other stuff are ignored :(
 2207               	.LM311:
 2208 09a4 1C92      		st X,__zero_reg__
 2209               	.L96:
 2210 09a6 1196      		adiw r26,1
 2211               	.LBE101:
 2212               	.LBE99:
 2213               	.LBE98:
1559:iv.c          ****   for (i=1; i<9; i++) {
 2215               	.LM312:
 2216 09a8 90E0      		ldi r25,hi8(display+9)
 2217 09aa A030      		cpi r26,lo8(display+9)
 2218 09ac B907      		cpc r27,r25
 2219 09ae 01F4      		brne .L98
 2220               	.L93:
 2221               	/* epilogue start */
 2222               	.LBE97:
 2223               	.LBE96:
1571:iv.c          ****     }
1572:iv.c          ****   }
1573:iv.c          **** }
 2225               	.LM313:
 2226 09b0 DF91      		pop r29
 2227 09b2 CF91      		pop r28
 2228 09b4 FF90      		pop r15
 2229 09b6 EF90      		pop r14
 2230 09b8 0895      		ret
 2232               	.Lscope16:
 2234               		.stabd	78,0,0
 2235               		.data
 2236               	.LC0:
 2237 0000 7375 6E64 		.string	"sunday"
 2237      6179 00
 2238               	.LC1:
 2239 0007 6D6F 6E64 		.string	"monday"
 2239      6179 00
 2240               	.LC2:
 2241 000e 7475 6573 		.string	"tuesday"
 2241      6461 7900 
 2242               	.LC3:
 2243 0016 7765 646E 		.string	"wednsday"
 2243      7364 6179 
 2243      00
 2244               	.LC4:
 2245 001f 7468 7572 		.string	"thursday"
 2245      7364 6179 
 2245      00
 2246               	.LC5:
 2247 0028 6672 6964 		.string	"friday"
 2247      6179 00
 2248               	.LC6:
 2249 002f 7361 7475 		.string	"saturday"
 2249      7264 6179 
 2249      00
 2250               	.LC7:
 2251 0038 6A61 6E00 		.string	"jan"
 2252               	.LC8:
 2253 003c 6665 6200 		.string	"feb"
 2254               	.LC9:
 2255 0040 6D61 7263 		.string	"march"
 2255      6800 
 2256               	.LC10:
 2257 0046 6170 7269 		.string	"april"
 2257      6C00 
 2258               	.LC11:
 2259 004c 6D61 7900 		.string	"may"
 2260               	.LC12:
 2261 0050 6A75 6E65 		.string	"june"
 2261      00
 2262               	.LC13:
 2263 0055 6A75 6C79 		.string	"july"
 2263      00
 2264               	.LC14:
 2265 005a 6175 6773 		.string	"augst"
 2265      7400 
 2266               	.LC15:
 2267 0060 7365 7074 		.string	"sept"
 2267      00
 2268               	.LC16:
 2269 0065 6F63 746F 		.string	"octob"
 2269      6200 
 2270               	.LC17:
 2271 006b 6E6F 7665 		.string	"novem"
 2271      6D00 
 2272               	.LC18:
 2273 0071 6465 6365 		.string	"decem"
 2273      6D00 
 2274               		.text
 2277               	.global	_Z12display_dateh
 2279               	_Z12display_dateh:
 2280               		.stabd	46,0,0
1400:iv.c          **** void display_date(uint8_t style) {
 2282               	.LM314:
 2283               	.LFBB17:
 2284 09ba CF93      		push r28
 2285 09bc DF93      		push r29
 2286               	/* prologue: function */
 2287               	/* frame size = 0 */
 2288               	/* stack size = 2 */
 2289               	.L__stack_usage = 2
 2290               	.LBB103:
1403:iv.c          ****   if (style == DATE) {
 2292               	.LM315:
 2293 09be 8823      		tst r24
 2294 09c0 01F0      		breq .+2
 2295 09c2 00C0      		rjmp .L102
 2296               	.LBB104:
1404:iv.c          ****     display[0] = 0;
 2298               	.LM316:
 2299 09c4 1092 0000 		sts display,__zero_reg__
1405:iv.c          ****     display[6] = display[3] = 0x02;     // put dashes between num
 2301               	.LM317:
 2302 09c8 82E0      		ldi r24,lo8(2)
 2303 09ca 8093 0000 		sts display+3,r24
 2304 09ce 8093 0000 		sts display+6,r24
 2305               	.LBB105:
1407:iv.c          ****     if (region == REGION_US) {
 2307               	.LM318:
 2308 09d2 8091 0000 		lds r24,region
 2309 09d6 8823      		tst r24
 2310 09d8 01F4      		brne .L103
 2311               	.LBB106:
1409:iv.c          ****       display[1] = pgm_read_byte(numbertable + (date_m / 10));
 2313               	.LM319:
 2314 09da 8091 0000 		lds r24,date_m
 2315 09de 2AE0      		ldi r18,lo8(10)
 2316 09e0 622F      		mov r22,r18
 2317 09e2 0E94 0000 		call __udivmodqi4
 2318 09e6 E82F      		mov r30,r24
 2319 09e8 F0E0      		ldi r31,lo8(0)
 2320 09ea E050      		subi r30,lo8(-(_ZL11numbertable))
 2321 09ec F040      		sbci r31,hi8(-(_ZL11numbertable))
 2322               	/* #APP */
 2323               	 ;  1409 "iv.c" 1
 2324 09ee E491      		lpm r30, Z
 2325               		
 2326               	 ;  0 "" 2
 2327               	/* #NOAPP */
 2328 09f0 E093 0000 		sts display+1,r30
 2329               	.LBE106:
 2330               	.LBB107:
1410:iv.c          ****       display[2] = pgm_read_byte(numbertable + (date_m % 10));
 2332               	.LM320:
 2333 09f4 8091 0000 		lds r24,date_m
 2334 09f8 0E94 0000 		call __udivmodqi4
 2335 09fc E92F      		mov r30,r25
 2336 09fe F0E0      		ldi r31,lo8(0)
 2337 0a00 E050      		subi r30,lo8(-(_ZL11numbertable))
 2338 0a02 F040      		sbci r31,hi8(-(_ZL11numbertable))
 2339               	/* #APP */
 2340               	 ;  1410 "iv.c" 1
 2341 0a04 E491      		lpm r30, Z
 2342               		
 2343               	 ;  0 "" 2
 2344               	/* #NOAPP */
 2345 0a06 E093 0000 		sts display+2,r30
 2346               	.LBE107:
 2347               	.LBB108:
1411:iv.c          ****       display[4] = pgm_read_byte(numbertable + (date_d / 10));
 2349               	.LM321:
 2350 0a0a 8091 0000 		lds r24,date_d
 2351 0a0e 0E94 0000 		call __udivmodqi4
 2352 0a12 E82F      		mov r30,r24
 2353 0a14 F0E0      		ldi r31,lo8(0)
 2354 0a16 E050      		subi r30,lo8(-(_ZL11numbertable))
 2355 0a18 F040      		sbci r31,hi8(-(_ZL11numbertable))
 2356               	/* #APP */
 2357               	 ;  1411 "iv.c" 1
 2358 0a1a E491      		lpm r30, Z
 2359               		
 2360               	 ;  0 "" 2
 2361               	/* #NOAPP */
 2362 0a1c E093 0000 		sts display+4,r30
 2363               	.LBE108:
 2364               	.LBB109:
1412:iv.c          ****       display[5] = pgm_read_byte(numbertable + (date_d % 10));
 2366               	.LM322:
 2367 0a20 8091 0000 		lds r24,date_d
 2368 0a24 00C0      		rjmp .L132
 2369               	.L103:
 2370               	.LBE109:
 2371               	.LBB110:
1415:iv.c          ****       display[1] = pgm_read_byte(numbertable + (date_d / 10));
 2373               	.LM323:
 2374 0a26 8091 0000 		lds r24,date_d
 2375 0a2a 2AE0      		ldi r18,lo8(10)
 2376 0a2c 622F      		mov r22,r18
 2377 0a2e 0E94 0000 		call __udivmodqi4
 2378 0a32 E82F      		mov r30,r24
 2379 0a34 F0E0      		ldi r31,lo8(0)
 2380 0a36 E050      		subi r30,lo8(-(_ZL11numbertable))
 2381 0a38 F040      		sbci r31,hi8(-(_ZL11numbertable))
 2382               	/* #APP */
 2383               	 ;  1415 "iv.c" 1
 2384 0a3a E491      		lpm r30, Z
 2385               		
 2386               	 ;  0 "" 2
 2387               	/* #NOAPP */
 2388 0a3c E093 0000 		sts display+1,r30
 2389               	.LBE110:
 2390               	.LBB111:
1416:iv.c          ****       display[2] = pgm_read_byte(numbertable + (date_d % 10));
 2392               	.LM324:
 2393 0a40 8091 0000 		lds r24,date_d
 2394 0a44 0E94 0000 		call __udivmodqi4
 2395 0a48 E92F      		mov r30,r25
 2396 0a4a F0E0      		ldi r31,lo8(0)
 2397 0a4c E050      		subi r30,lo8(-(_ZL11numbertable))
 2398 0a4e F040      		sbci r31,hi8(-(_ZL11numbertable))
 2399               	/* #APP */
 2400               	 ;  1416 "iv.c" 1
 2401 0a50 E491      		lpm r30, Z
 2402               		
 2403               	 ;  0 "" 2
 2404               	/* #NOAPP */
 2405 0a52 E093 0000 		sts display+2,r30
 2406               	.LBE111:
 2407               	.LBB112:
1417:iv.c          ****       display[4] = pgm_read_byte(numbertable + (date_m / 10));
 2409               	.LM325:
 2410 0a56 8091 0000 		lds r24,date_m
 2411 0a5a 0E94 0000 		call __udivmodqi4
 2412 0a5e E82F      		mov r30,r24
 2413 0a60 F0E0      		ldi r31,lo8(0)
 2414 0a62 E050      		subi r30,lo8(-(_ZL11numbertable))
 2415 0a64 F040      		sbci r31,hi8(-(_ZL11numbertable))
 2416               	/* #APP */
 2417               	 ;  1417 "iv.c" 1
 2418 0a66 E491      		lpm r30, Z
 2419               		
 2420               	 ;  0 "" 2
 2421               	/* #NOAPP */
 2422 0a68 E093 0000 		sts display+4,r30
 2423               	.LBE112:
 2424               	.LBB113:
1418:iv.c          ****       display[5] = pgm_read_byte(numbertable + (date_m % 10));
 2426               	.LM326:
 2427 0a6c 8091 0000 		lds r24,date_m
 2428               	.L132:
 2429 0a70 0E94 0000 		call __udivmodqi4
 2430 0a74 E92F      		mov r30,r25
 2431 0a76 F0E0      		ldi r31,lo8(0)
 2432 0a78 E050      		subi r30,lo8(-(_ZL11numbertable))
 2433 0a7a F040      		sbci r31,hi8(-(_ZL11numbertable))
 2434               	/* #APP */
 2435               	 ;  1418 "iv.c" 1
 2436 0a7c E491      		lpm r30, Z
 2437               		
 2438               	 ;  0 "" 2
 2439               	/* #NOAPP */
 2440 0a7e E093 0000 		sts display+5,r30
 2441               	.LBE113:
 2442               	.LBE105:
 2443               	.LBB114:
1421:iv.c          ****     display[7] = pgm_read_byte(numbertable + (date_y / 10));
 2445               	.LM327:
 2446 0a82 8091 0000 		lds r24,date_y
 2447 0a86 2AE0      		ldi r18,lo8(10)
 2448 0a88 622F      		mov r22,r18
 2449 0a8a 0E94 0000 		call __udivmodqi4
 2450 0a8e E82F      		mov r30,r24
 2451 0a90 F0E0      		ldi r31,lo8(0)
 2452 0a92 E050      		subi r30,lo8(-(_ZL11numbertable))
 2453 0a94 F040      		sbci r31,hi8(-(_ZL11numbertable))
 2454               	/* #APP */
 2455               	 ;  1421 "iv.c" 1
 2456 0a96 E491      		lpm r30, Z
 2457               		
 2458               	 ;  0 "" 2
 2459               	/* #NOAPP */
 2460 0a98 E093 0000 		sts display+7,r30
 2461               	.LBE114:
 2462               	.LBB115:
1422:iv.c          ****     display[8] = pgm_read_byte(numbertable + (date_y % 10));
 2464               	.LM328:
 2465 0a9c 8091 0000 		lds r24,date_y
 2466 0aa0 00C0      		rjmp .L135
 2467               	.L102:
 2468               	.LBE115:
 2469               	.LBE104:
 2470               	.LBB116:
1424:iv.c          ****   } else if (style == DAY) {
 2472               	.LM329:
 2473 0aa2 8130      		cpi r24,lo8(1)
 2474 0aa4 01F0      		breq .+2
 2475 0aa6 00C0      		rjmp .L101
 2476               	.LBB117:
1432:iv.c          ****     month = date_m;
 2478               	.LM330:
 2479 0aa8 8091 0000 		lds r24,date_m
 2480 0aac C82F      		mov r28,r24
 2481 0aae D0E0      		ldi r29,lo8(0)
1433:iv.c          ****     year = 2000 + date_y;
 2483               	.LM331:
 2484 0ab0 E091 0000 		lds r30,date_y
 2485 0ab4 F0E0      		ldi r31,lo8(0)
 2486 0ab6 E053      		subi r30,lo8(-(2000))
 2487 0ab8 F84F      		sbci r31,hi8(-(2000))
1434:iv.c          ****     if (date_m < 3)  {
 2489               	.LM332:
 2490 0aba 8091 0000 		lds r24,date_m
 2491 0abe 8330      		cpi r24,lo8(3)
 2492 0ac0 00F4      		brsh .L106
1435:iv.c          ****       month += 12;
 2494               	.LM333:
 2495 0ac2 2C96      		adiw r28,12
1436:iv.c          ****       year -= 1;
 2497               	.LM334:
 2498 0ac4 3197      		sbiw r30,1
 2499               	.L106:
1438:iv.c          ****     dotw = (date_d + (2 * month) + (6 * (month+1)/10) + year + (year/4) - (year/100) + (year/400) +
 2501               	.LM335:
 2502 0ac6 2091 0000 		lds r18,date_d
1441:iv.c          ****     display[8] = display[7] = 0;
 2504               	.LM336:
 2505 0aca 1092 0000 		sts display+7,__zero_reg__
 2506 0ace 1092 0000 		sts display+8,__zero_reg__
1438:iv.c          ****     dotw = (date_d + (2 * month) + (6 * (month+1)/10) + year + (year/4) - (year/100) + (year/400) +
 2508               	.LM337:
 2509 0ad2 30E0      		ldi r19,lo8(0)
 2510 0ad4 2F5F      		subi r18,lo8(-(1))
 2511 0ad6 3F4F      		sbci r19,hi8(-(1))
 2512 0ad8 2E0F      		add r18,r30
 2513 0ada 3F1F      		adc r19,r31
 2514 0adc CE01      		movw r24,r28
 2515 0ade 880F      		lsl r24
 2516 0ae0 991F      		rol r25
 2517 0ae2 280F      		add r18,r24
 2518 0ae4 391F      		adc r19,r25
 2519 0ae6 CF01      		movw r24,r30
 2520 0ae8 9695      		lsr r25
 2521 0aea 8795      		ror r24
 2522 0aec 9695      		lsr r25
 2523 0aee 8795      		ror r24
 2524 0af0 280F      		add r18,r24
 2525 0af2 391F      		adc r19,r25
 2526 0af4 CF01      		movw r24,r30
 2527 0af6 60E9      		ldi r22,lo8(400)
 2528 0af8 71E0      		ldi r23,hi8(400)
 2529 0afa 0E94 0000 		call __udivmodhi4
 2530 0afe 260F      		add r18,r22
 2531 0b00 371F      		adc r19,r23
 2532 0b02 CF01      		movw r24,r30
 2533 0b04 64E6      		ldi r22,lo8(100)
 2534 0b06 70E0      		ldi r23,hi8(100)
 2535 0b08 0E94 0000 		call __udivmodhi4
 2536 0b0c 261B      		sub r18,r22
 2537 0b0e 370B      		sbc r19,r23
 2538 0b10 2196      		adiw r28,1
 2539 0b12 CE01      		movw r24,r28
 2540 0b14 880F      		lsl r24
 2541 0b16 991F      		rol r25
 2542 0b18 8C0F      		add r24,r28
 2543 0b1a 9D1F      		adc r25,r29
 2544 0b1c 880F      		lsl r24
 2545 0b1e 991F      		rol r25
 2546 0b20 6AE0      		ldi r22,lo8(10)
 2547 0b22 70E0      		ldi r23,hi8(10)
 2548 0b24 0E94 0000 		call __udivmodhi4
 2549 0b28 260F      		add r18,r22
 2550 0b2a 371F      		adc r19,r23
 2551 0b2c C901      		movw r24,r18
 2552 0b2e 67E0      		ldi r22,lo8(7)
 2553 0b30 70E0      		ldi r23,hi8(7)
 2554 0b32 0E94 0000 		call __udivmodhi4
1442:iv.c          ****     switch (dotw) {
 2556               	.LM338:
 2557 0b36 8330      		cpi r24,lo8(3)
 2558 0b38 01F0      		breq .L110
 2559 0b3a 8430      		cpi r24,lo8(4)
 2560 0b3c 00F4      		brsh .L114
 2561 0b3e 8130      		cpi r24,lo8(1)
 2562 0b40 01F0      		breq .L108
 2563 0b42 8230      		cpi r24,lo8(2)
 2564 0b44 01F4      		brne .L107
 2565 0b46 00C0      		rjmp .L136
 2566               	.L114:
 2567 0b48 8530      		cpi r24,lo8(5)
 2568 0b4a 01F0      		breq .L112
 2569 0b4c 8530      		cpi r24,lo8(5)
 2570 0b4e 00F0      		brlo .L111
 2571 0b50 8630      		cpi r24,lo8(6)
 2572 0b52 01F0      		breq .L113
 2573               	.L107:
1444:iv.c          ****       display_str("sunday"); break;
 2575               	.LM339:
 2576 0b54 80E0      		ldi r24,lo8(.LC0)
 2577 0b56 90E0      		ldi r25,hi8(.LC0)
 2578 0b58 00C0      		rjmp .L133
 2579               	.L108:
1446:iv.c          ****       display_str("monday"); break;
 2581               	.LM340:
 2582 0b5a 80E0      		ldi r24,lo8(.LC1)
 2583 0b5c 90E0      		ldi r25,hi8(.LC1)
 2584 0b5e 00C0      		rjmp .L133
 2585               	.L136:
1448:iv.c          ****       display_str("tuesday"); break;
 2587               	.LM341:
 2588 0b60 80E0      		ldi r24,lo8(.LC2)
 2589 0b62 90E0      		ldi r25,hi8(.LC2)
 2590 0b64 00C0      		rjmp .L133
 2591               	.L110:
1450:iv.c          ****       display_str("wednsday"); break;
 2593               	.LM342:
 2594 0b66 80E0      		ldi r24,lo8(.LC3)
 2595 0b68 90E0      		ldi r25,hi8(.LC3)
 2596 0b6a 00C0      		rjmp .L133
 2597               	.L111:
1452:iv.c          ****       display_str("thursday"); break;
 2599               	.LM343:
 2600 0b6c 80E0      		ldi r24,lo8(.LC4)
 2601 0b6e 90E0      		ldi r25,hi8(.LC4)
 2602 0b70 00C0      		rjmp .L133
 2603               	.L112:
1454:iv.c          ****       display_str("friday"); break;
 2605               	.LM344:
 2606 0b72 80E0      		ldi r24,lo8(.LC5)
 2607 0b74 90E0      		ldi r25,hi8(.LC5)
 2608 0b76 00C0      		rjmp .L133
 2609               	.L113:
1456:iv.c          ****       display_str("saturday"); break;
 2611               	.LM345:
 2612 0b78 80E0      		ldi r24,lo8(.LC6)
 2613 0b7a 90E0      		ldi r25,hi8(.LC6)
 2614               	.L133:
 2615 0b7c 0E94 0000 		call _Z11display_strPKc
1460:iv.c          ****     delayms(1000);
 2617               	.LM346:
 2618 0b80 88EE      		ldi r24,lo8(1000)
 2619 0b82 93E0      		ldi r25,hi8(1000)
 2620 0b84 0E94 0000 		call _Z7delaymsj
1463:iv.c          ****     display[6] = display[5] = display[4] = 0;
 2622               	.LM347:
 2623 0b88 1092 0000 		sts display+4,__zero_reg__
 2624 0b8c 1092 0000 		sts display+5,__zero_reg__
 2625 0b90 1092 0000 		sts display+6,__zero_reg__
1464:iv.c          ****     switch (date_m) {
 2627               	.LM348:
 2628 0b94 8091 0000 		lds r24,date_m
 2629 0b98 8630      		cpi r24,lo8(6)
 2630 0b9a 01F0      		breq .L122
 2631 0b9c 8730      		cpi r24,lo8(7)
 2632 0b9e 00F4      		brsh .L129
 2633 0ba0 8330      		cpi r24,lo8(3)
 2634 0ba2 01F0      		breq .L119
 2635 0ba4 8430      		cpi r24,lo8(4)
 2636 0ba6 00F4      		brsh .L130
 2637 0ba8 8130      		cpi r24,lo8(1)
 2638 0baa 01F0      		breq .L117
 2639 0bac 8230      		cpi r24,lo8(2)
 2640 0bae 01F4      		brne .L116
 2641 0bb0 00C0      		rjmp .L137
 2642               	.L130:
 2643 0bb2 8430      		cpi r24,lo8(4)
 2644 0bb4 01F0      		breq .L120
 2645 0bb6 8530      		cpi r24,lo8(5)
 2646 0bb8 01F4      		brne .L116
 2647 0bba 00C0      		rjmp .L138
 2648               	.L129:
 2649 0bbc 8930      		cpi r24,lo8(9)
 2650 0bbe 01F0      		breq .L125
 2651 0bc0 8A30      		cpi r24,lo8(10)
 2652 0bc2 00F4      		brsh .L131
 2653 0bc4 8730      		cpi r24,lo8(7)
 2654 0bc6 01F0      		breq .L123
 2655 0bc8 8830      		cpi r24,lo8(8)
 2656 0bca 01F4      		brne .L116
 2657 0bcc 00C0      		rjmp .L139
 2658               	.L131:
 2659 0bce 8B30      		cpi r24,lo8(11)
 2660 0bd0 01F0      		breq .L127
 2661 0bd2 8B30      		cpi r24,lo8(11)
 2662 0bd4 00F0      		brlo .L126
 2663 0bd6 8C30      		cpi r24,lo8(12)
 2664 0bd8 01F4      		brne .L116
 2665 0bda 00C0      		rjmp .L140
 2666               	.L117:
1466:iv.c          ****       display_str("jan"); break;
 2668               	.LM349:
 2669 0bdc 80E0      		ldi r24,lo8(.LC7)
 2670 0bde 90E0      		ldi r25,hi8(.LC7)
 2671 0be0 00C0      		rjmp .L134
 2672               	.L137:
1468:iv.c          ****       display_str("feb"); break;
 2674               	.LM350:
 2675 0be2 80E0      		ldi r24,lo8(.LC8)
 2676 0be4 90E0      		ldi r25,hi8(.LC8)
 2677 0be6 00C0      		rjmp .L134
 2678               	.L119:
1470:iv.c          ****       display_str("march"); break;
 2680               	.LM351:
 2681 0be8 80E0      		ldi r24,lo8(.LC9)
 2682 0bea 90E0      		ldi r25,hi8(.LC9)
 2683 0bec 00C0      		rjmp .L134
 2684               	.L120:
1472:iv.c          ****       display_str("april"); break;
 2686               	.LM352:
 2687 0bee 80E0      		ldi r24,lo8(.LC10)
 2688 0bf0 90E0      		ldi r25,hi8(.LC10)
 2689 0bf2 00C0      		rjmp .L134
 2690               	.L138:
1474:iv.c          ****       display_str("may"); break;
 2692               	.LM353:
 2693 0bf4 80E0      		ldi r24,lo8(.LC11)
 2694 0bf6 90E0      		ldi r25,hi8(.LC11)
 2695 0bf8 00C0      		rjmp .L134
 2696               	.L122:
1476:iv.c          ****       display_str("june"); break;
 2698               	.LM354:
 2699 0bfa 80E0      		ldi r24,lo8(.LC12)
 2700 0bfc 90E0      		ldi r25,hi8(.LC12)
 2701 0bfe 00C0      		rjmp .L134
 2702               	.L123:
1478:iv.c          ****       display_str("july"); break;
 2704               	.LM355:
 2705 0c00 80E0      		ldi r24,lo8(.LC13)
 2706 0c02 90E0      		ldi r25,hi8(.LC13)
 2707 0c04 00C0      		rjmp .L134
 2708               	.L139:
1480:iv.c          ****       display_str("augst"); break;
 2710               	.LM356:
 2711 0c06 80E0      		ldi r24,lo8(.LC14)
 2712 0c08 90E0      		ldi r25,hi8(.LC14)
 2713 0c0a 00C0      		rjmp .L134
 2714               	.L125:
1482:iv.c          ****       display_str("sept"); break;
 2716               	.LM357:
 2717 0c0c 80E0      		ldi r24,lo8(.LC15)
 2718 0c0e 90E0      		ldi r25,hi8(.LC15)
 2719 0c10 00C0      		rjmp .L134
 2720               	.L126:
1484:iv.c          ****       display_str("octob"); break;
 2722               	.LM358:
 2723 0c12 80E0      		ldi r24,lo8(.LC16)
 2724 0c14 90E0      		ldi r25,hi8(.LC16)
 2725 0c16 00C0      		rjmp .L134
 2726               	.L127:
1486:iv.c          ****       display_str("novem"); break;
 2728               	.LM359:
 2729 0c18 80E0      		ldi r24,lo8(.LC17)
 2730 0c1a 90E0      		ldi r25,hi8(.LC17)
 2731 0c1c 00C0      		rjmp .L134
 2732               	.L140:
1488:iv.c          ****       display_str("decem"); break;
 2734               	.LM360:
 2735 0c1e 80E0      		ldi r24,lo8(.LC18)
 2736 0c20 90E0      		ldi r25,hi8(.LC18)
 2737               	.L134:
 2738 0c22 0E94 0000 		call _Z11display_strPKc
 2739               	.L116:
 2740               	.LBB118:
1490:iv.c          ****     display[7] = pgm_read_byte(numbertable + (date_d / 10));
 2742               	.LM361:
 2743 0c26 8091 0000 		lds r24,date_d
 2744 0c2a 2AE0      		ldi r18,lo8(10)
 2745 0c2c 622F      		mov r22,r18
 2746 0c2e 0E94 0000 		call __udivmodqi4
 2747 0c32 E82F      		mov r30,r24
 2748 0c34 F0E0      		ldi r31,lo8(0)
 2749 0c36 E050      		subi r30,lo8(-(_ZL11numbertable))
 2750 0c38 F040      		sbci r31,hi8(-(_ZL11numbertable))
 2751               	/* #APP */
 2752               	 ;  1490 "iv.c" 1
 2753 0c3a E491      		lpm r30, Z
 2754               		
 2755               	 ;  0 "" 2
 2756               	/* #NOAPP */
 2757 0c3c E093 0000 		sts display+7,r30
 2758               	.LBE118:
 2759               	.LBB119:
1491:iv.c          ****     display[8] = pgm_read_byte(numbertable + (date_d % 10));
 2761               	.LM362:
 2762 0c40 8091 0000 		lds r24,date_d
 2763               	.L135:
 2764 0c44 0E94 0000 		call __udivmodqi4
 2765 0c48 E92F      		mov r30,r25
 2766 0c4a F0E0      		ldi r31,lo8(0)
 2767 0c4c E050      		subi r30,lo8(-(_ZL11numbertable))
 2768 0c4e F040      		sbci r31,hi8(-(_ZL11numbertable))
 2769               	/* #APP */
 2770               	 ;  1491 "iv.c" 1
 2771 0c50 E491      		lpm r30, Z
 2772               		
 2773               	 ;  0 "" 2
 2774               	/* #NOAPP */
 2775 0c52 E093 0000 		sts display+8,r30
 2776               	.L101:
 2777               	/* epilogue start */
 2778               	.LBE119:
 2779               	.LBE117:
 2780               	.LBE116:
 2781               	.LBE103:
1494:iv.c          **** }
 2783               	.LM363:
 2784 0c56 DF91      		pop r29
 2785 0c58 CF91      		pop r28
 2786 0c5a 0895      		ret
 2792               	.Lscope17:
 2794               		.stabd	78,0,0
 2796               	.global	_Z8set_datev
 2798               	_Z8set_datev:
 2799               		.stabd	46,0,0
 845:iv.c          **** void set_date(void) {
 2801               	.LM364:
 2802               	.LFBB18:
 2803 0c5c EF92      		push r14
 2804 0c5e FF92      		push r15
 2805 0c60 0F93      		push r16
 2806 0c62 1F93      		push r17
 2807               	/* prologue: function */
 2808               	/* frame size = 0 */
 2809               	/* stack size = 4 */
 2810               	.L__stack_usage = 4
 2811               	.LBB120:
 848:iv.c          ****   timeoutcounter = INACTIVITYTIMEOUT;;  
 2813               	.LM365:
 2814 0c64 8AE0      		ldi r24,lo8(10)
 2815 0c66 8093 0000 		sts timeoutcounter,r24
 846:iv.c          ****   uint8_t mode = SHOW_MENU;
 2817               	.LM366:
 2818 0c6a 10E0      		ldi r17,lo8(0)
 2819               	.LBB121:
 852:iv.c          ****       timeoutcounter = INACTIVITYTIMEOUT;;  
 2821               	.LM367:
 2822 0c6c 0AE0      		ldi r16,lo8(10)
 2823 0c6e E02E      		mov r14,r16
 2824               	.LBB122:
 2825               	.LBB123:
 2826               	.LBB124:
 882:iv.c          **** 	  mode = SET_MONTH;
 2828               	.LM368:
 2829 0c70 FF24      		clr r15
 2830 0c72 F394      		inc r15
 2831               	.LBE124:
 2832               	.LBE123:
 2833               	.LBE122:
 933:iv.c          **** 	date_y %= 100;
 2835               	.LM369:
 2836 0c74 04E6      		ldi r16,lo8(100)
 2837               	.L173:
 851:iv.c          ****     if (just_pressed || pressed) {
 2839               	.LM370:
 2840 0c76 8091 0000 		lds r24,just_pressed
 2841 0c7a 8823      		tst r24
 2842 0c7c 01F4      		brne .L143
 851:iv.c          ****     if (just_pressed || pressed) {
 2844               	.LM371:
 2845 0c7e 8091 0000 		lds r24,pressed
 2846 0c82 8823      		tst r24
 2847 0c84 01F4      		brne .+2
 2848 0c86 00C0      		rjmp .L144
 2849               	.L143:
 852:iv.c          ****       timeoutcounter = INACTIVITYTIMEOUT;;  
 2851               	.LM372:
 2852 0c88 E092 0000 		sts timeoutcounter,r14
 2853               	.L145:
 859:iv.c          ****     if (just_pressed & 0x1) { // mode change
 2855               	.LM373:
 2856 0c8c 8091 0000 		lds r24,just_pressed
 2857 0c90 80FD      		sbrc r24,0
 2858 0c92 00C0      		rjmp .L141
 2859               	.LBB130:
 862:iv.c          ****     if (just_pressed & 0x2) {
 2861               	.LM374:
 2862 0c94 8091 0000 		lds r24,just_pressed
 2863 0c98 81FF      		sbrs r24,1
 2864 0c9a 00C0      		rjmp .L147
 2865               	.LBB129:
 864:iv.c          ****       just_pressed = 0;
 2867               	.LM375:
 2868 0c9c 1092 0000 		sts just_pressed,__zero_reg__
 2869               	.LBB128:
 865:iv.c          ****       if (mode == SHOW_MENU) {
 2871               	.LM376:
 2872 0ca0 1123      		tst r17
 2873 0ca2 01F4      		brne .L148
 2874               	.LBB125:
 2875               	.LBB126:
 867:iv.c          **** 	if (region == REGION_US) {
 2877               	.LM377:
 2878 0ca4 8091 0000 		lds r24,region
 2879 0ca8 8823      		tst r24
 2880 0caa 01F0      		breq .L169
 2881               	.LBB127:
 871:iv.c          **** 	  DEBUGP("Set day");
 2883               	.LM378:
 2884 0cac 80E0      		ldi r24,lo8(_ZZ8set_datevE3__c)
 2885 0cae 90E0      		ldi r25,hi8(_ZZ8set_datevE3__c)
 2886 0cb0 61E0      		ldi r22,lo8(1)
 2887 0cb2 0E94 0000 		call _Z13ROM_putstringPKch
 872:iv.c          **** 	  mode = SET_DAY;
 2889               	.LM379:
 2890 0cb6 12E0      		ldi r17,lo8(2)
 2891 0cb8 00C0      		rjmp .L149
 2892               	.L169:
 2893               	.LBE127:
 868:iv.c          **** 	  mode = SET_MONTH;
 2895               	.LM380:
 2896 0cba 11E0      		ldi r17,lo8(1)
 2897               	.L149:
 2898               	.LBE126:
 874:iv.c          **** 	display_date(DATE);
 2900               	.LM381:
 2901 0cbc 80E0      		ldi r24,lo8(0)
 2902 0cbe 0E94 0000 		call _Z12display_dateh
 875:iv.c          **** 	display[1] |= 0x1;
 2904               	.LM382:
 2905 0cc2 8091 0000 		lds r24,display+1
 2906 0cc6 8160      		ori r24,lo8(1)
 2907 0cc8 8093 0000 		sts display+1,r24
 876:iv.c          **** 	display[2] |= 0x1;
 2909               	.LM383:
 2910 0ccc 8091 0000 		lds r24,display+2
 2911 0cd0 8160      		ori r24,lo8(1)
 2912 0cd2 8093 0000 		sts display+2,r24
 2913 0cd6 00C0      		rjmp .L147
 2914               	.L148:
 2915               	.LBE125:
 877:iv.c          ****       } else if (((mode == SET_MONTH) && (region == REGION_US)) ||
 2917               	.LM384:
 2918 0cd8 1130      		cpi r17,lo8(1)
 2919 0cda 01F4      		brne .L150
 877:iv.c          ****       } else if (((mode == SET_MONTH) && (region == REGION_US)) ||
 2921               	.LM385:
 2922 0cdc 8091 0000 		lds r24,region
 2923 0ce0 8823      		tst r24
 2924 0ce2 01F0      		breq .L151
 2925 0ce4 00C0      		rjmp .L177
 2926               	.L150:
 877:iv.c          ****       } else if (((mode == SET_MONTH) && (region == REGION_US)) ||
 2928               	.LM386:
 2929 0ce6 1230      		cpi r17,lo8(2)
 2930 0ce8 01F4      		brne .L153
 877:iv.c          ****       } else if (((mode == SET_MONTH) && (region == REGION_US)) ||
 2932               	.LM387:
 2933 0cea 8091 0000 		lds r24,region
 2934 0cee 8130      		cpi r24,lo8(1)
 2935 0cf0 01F4      		brne .L154
 2936               	.L151:
 879:iv.c          **** 	if (region == REGION_US)
 2938               	.LM388:
 2939 0cf2 8091 0000 		lds r24,region
 2940 0cf6 8823      		tst r24
 2941 0cf8 01F4      		brne .L170
 880:iv.c          **** 	  mode = SET_DAY;
 2943               	.LM389:
 2944 0cfa 12E0      		ldi r17,lo8(2)
 2945 0cfc 00C0      		rjmp .L155
 2946               	.L170:
 882:iv.c          **** 	  mode = SET_MONTH;
 2948               	.LM390:
 2949 0cfe 11E0      		ldi r17,lo8(1)
 2950               	.L155:
 883:iv.c          **** 	display_date(DATE);
 2952               	.LM391:
 2953 0d00 80E0      		ldi r24,lo8(0)
 2954 0d02 0E94 0000 		call _Z12display_dateh
 884:iv.c          **** 	display[4] |= 0x1;
 2956               	.LM392:
 2957 0d06 8091 0000 		lds r24,display+4
 2958 0d0a 8160      		ori r24,lo8(1)
 2959 0d0c 8093 0000 		sts display+4,r24
 885:iv.c          **** 	display[5] |= 0x1;
 2961               	.LM393:
 2962 0d10 8091 0000 		lds r24,display+5
 2963 0d14 8160      		ori r24,lo8(1)
 2964 0d16 8093 0000 		sts display+5,r24
 2965 0d1a 00C0      		rjmp .L147
 2966               	.L154:
 886:iv.c          ****       } else if (((mode == SET_DAY) && (region == REGION_US)) ||
 2968               	.LM394:
 2969 0d1c 8823      		tst r24
 2970 0d1e 01F0      		breq .L156
 2971 0d20 00C0      		rjmp .L153
 2972               	.L177:
 886:iv.c          ****       } else if (((mode == SET_DAY) && (region == REGION_US)) ||
 2974               	.LM395:
 2975 0d22 8130      		cpi r24,lo8(1)
 2976 0d24 01F4      		brne .L153
 2977               	.L156:
 889:iv.c          **** 	display_date(DATE);
 2979               	.LM396:
 2980 0d26 80E0      		ldi r24,lo8(0)
 2981 0d28 0E94 0000 		call _Z12display_dateh
 890:iv.c          **** 	display[7] |= 0x1;
 2983               	.LM397:
 2984 0d2c 8091 0000 		lds r24,display+7
 2985 0d30 8160      		ori r24,lo8(1)
 2986 0d32 8093 0000 		sts display+7,r24
 891:iv.c          **** 	display[8] |= 0x1;
 2988               	.LM398:
 2989 0d36 8091 0000 		lds r24,display+8
 2990 0d3a 8160      		ori r24,lo8(1)
 2991 0d3c 8093 0000 		sts display+8,r24
 888:iv.c          **** 	mode = SET_YEAR;
 2993               	.LM399:
 2994 0d40 13E0      		ldi r17,lo8(3)
 891:iv.c          **** 	display[8] |= 0x1;
 2996               	.LM400:
 2997 0d42 00C0      		rjmp .L147
 2998               	.L153:
 893:iv.c          **** 	displaymode = NONE;
 3000               	.LM401:
 3001 0d44 83E6      		ldi r24,lo8(99)
 3002 0d46 8093 0000 		sts displaymode,r24
 894:iv.c          **** 	display_date(DATE);
 3004               	.LM402:
 3005 0d4a 80E0      		ldi r24,lo8(0)
 3006 0d4c 0E94 0000 		call _Z12display_dateh
 895:iv.c          **** 	delayms(1500);
 3008               	.LM403:
 3009 0d50 8CED      		ldi r24,lo8(1500)
 3010 0d52 95E0      		ldi r25,hi8(1500)
 3011 0d54 0E94 0000 		call _Z7delaymsj
 3012               	.L176:
 896:iv.c          **** 	displaymode = SHOW_TIME;
 3014               	.LM404:
 3015 0d58 1092 0000 		sts displaymode,__zero_reg__
 3016 0d5c 00C0      		rjmp .L141
 3017               	.L147:
 3018               	.LBE128:
 3019               	.LBE129:
 3020               	.LBE130:
 900:iv.c          ****     if ((just_pressed & 0x4) || (pressed & 0x4)) {
 3022               	.LM405:
 3023 0d5e 8091 0000 		lds r24,just_pressed
 3024 0d62 82FD      		sbrc r24,2
 3025 0d64 00C0      		rjmp .L157
 900:iv.c          ****     if ((just_pressed & 0x4) || (pressed & 0x4)) {
 3027               	.LM406:
 3028 0d66 8091 0000 		lds r24,pressed
 3029 0d6a 82FF      		sbrs r24,2
 3030 0d6c 00C0      		rjmp .L173
 3031               	.L157:
 901:iv.c          ****       just_pressed = 0;
 3033               	.LM407:
 3034 0d6e 1092 0000 		sts just_pressed,__zero_reg__
 902:iv.c          ****       if (mode == SET_MONTH) {
 3036               	.LM408:
 3037 0d72 1130      		cpi r17,lo8(1)
 3038 0d74 01F4      		brne .L159
 903:iv.c          **** 	date_m++;
 3040               	.LM409:
 3041 0d76 8091 0000 		lds r24,date_m
 3042 0d7a 8F5F      		subi r24,lo8(-(1))
 3043 0d7c 8093 0000 		sts date_m,r24
 904:iv.c          **** 	if (date_m >= 13)
 3045               	.LM410:
 3046 0d80 8091 0000 		lds r24,date_m
 3047 0d84 8D30      		cpi r24,lo8(13)
 3048 0d86 00F0      		brlo .L160
 905:iv.c          **** 	  date_m = 1;
 3050               	.LM411:
 3051 0d88 1093 0000 		sts date_m,r17
 3052               	.L160:
 906:iv.c          **** 	display_date(DATE);
 3054               	.LM412:
 3055 0d8c 80E0      		ldi r24,lo8(0)
 3056 0d8e 0E94 0000 		call _Z12display_dateh
 907:iv.c          **** 	if (region == REGION_US) {
 3058               	.LM413:
 3059 0d92 8091 0000 		lds r24,region
 3060 0d96 8823      		tst r24
 3061 0d98 01F4      		brne .L161
 908:iv.c          **** 	  display[1] |= 0x1;
 3063               	.LM414:
 3064 0d9a 8091 0000 		lds r24,display+1
 3065 0d9e 8160      		ori r24,lo8(1)
 3066 0da0 8093 0000 		sts display+1,r24
 909:iv.c          **** 	  display[2] |= 0x1;
 3068               	.LM415:
 3069 0da4 8091 0000 		lds r24,display+2
 3070 0da8 8160      		ori r24,lo8(1)
 3071 0daa 8093 0000 		sts display+2,r24
 3072 0dae 00C0      		rjmp .L162
 3073               	.L161:
 911:iv.c          **** 	  display[4] |= 0x1;
 3075               	.LM416:
 3076 0db0 8091 0000 		lds r24,display+4
 3077 0db4 8160      		ori r24,lo8(1)
 3078 0db6 8093 0000 		sts display+4,r24
 912:iv.c          **** 	  display[5] |= 0x1;
 3080               	.LM417:
 3081 0dba 8091 0000 		lds r24,display+5
 3082 0dbe 8160      		ori r24,lo8(1)
 3083 0dc0 8093 0000 		sts display+5,r24
 3084               	.L162:
 914:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_MONTH, date_m);    
 3086               	.LM418:
 3087 0dc4 6091 0000 		lds r22,date_m
 3088 0dc8 82E0      		ldi r24,lo8(2)
 3089 0dca 90E0      		ldi r25,hi8(2)
 3090 0dcc 00C0      		rjmp .L175
 3091               	.L159:
 916:iv.c          ****       if (mode == SET_DAY) {
 3093               	.LM419:
 3094 0dce 1230      		cpi r17,lo8(2)
 3095 0dd0 01F4      		brne .L164
 917:iv.c          **** 	date_d++;
 3097               	.LM420:
 3098 0dd2 8091 0000 		lds r24,date_d
 3099 0dd6 8F5F      		subi r24,lo8(-(1))
 3100 0dd8 8093 0000 		sts date_d,r24
 918:iv.c          **** 	if (date_d > 31)
 3102               	.LM421:
 3103 0ddc 8091 0000 		lds r24,date_d
 3104 0de0 8032      		cpi r24,lo8(32)
 3105 0de2 00F0      		brlo .L165
 919:iv.c          **** 	  date_d = 1;
 3107               	.LM422:
 3108 0de4 F092 0000 		sts date_d,r15
 3109               	.L165:
 920:iv.c          **** 	display_date(DATE);
 3111               	.LM423:
 3112 0de8 80E0      		ldi r24,lo8(0)
 3113 0dea 0E94 0000 		call _Z12display_dateh
 922:iv.c          **** 	if (region == REGION_EU) {
 3115               	.LM424:
 3116 0dee 8091 0000 		lds r24,region
 3117 0df2 8130      		cpi r24,lo8(1)
 3118 0df4 01F4      		brne .L166
 923:iv.c          **** 	  display[1] |= 0x1;
 3120               	.LM425:
 3121 0df6 8091 0000 		lds r24,display+1
 3122 0dfa 8160      		ori r24,lo8(1)
 3123 0dfc 8093 0000 		sts display+1,r24
 924:iv.c          **** 	  display[2] |= 0x1;
 3125               	.LM426:
 3126 0e00 8091 0000 		lds r24,display+2
 3127 0e04 8160      		ori r24,lo8(1)
 3128 0e06 8093 0000 		sts display+2,r24
 3129 0e0a 00C0      		rjmp .L167
 3130               	.L166:
 926:iv.c          **** 	  display[4] |= 0x1;
 3132               	.LM427:
 3133 0e0c 8091 0000 		lds r24,display+4
 3134 0e10 8160      		ori r24,lo8(1)
 3135 0e12 8093 0000 		sts display+4,r24
 927:iv.c          **** 	  display[5] |= 0x1;
 3137               	.LM428:
 3138 0e16 8091 0000 		lds r24,display+5
 3139 0e1a 8160      		ori r24,lo8(1)
 3140 0e1c 8093 0000 		sts display+5,r24
 3141               	.L167:
 929:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_DAY, date_d);    
 3143               	.LM429:
 3144 0e20 6091 0000 		lds r22,date_d
 3145 0e24 83E0      		ldi r24,lo8(3)
 3146 0e26 90E0      		ldi r25,hi8(3)
 3147 0e28 00C0      		rjmp .L175
 3148               	.L164:
 931:iv.c          ****       if (mode == SET_YEAR) {
 3150               	.LM430:
 3151 0e2a 1330      		cpi r17,lo8(3)
 3152 0e2c 01F4      		brne .L163
 932:iv.c          **** 	date_y++;
 3154               	.LM431:
 3155 0e2e 8091 0000 		lds r24,date_y
 3156 0e32 8F5F      		subi r24,lo8(-(1))
 3157 0e34 8093 0000 		sts date_y,r24
 933:iv.c          **** 	date_y %= 100;
 3159               	.LM432:
 3160 0e38 8091 0000 		lds r24,date_y
 3161 0e3c 602F      		mov r22,r16
 3162 0e3e 0E94 0000 		call __udivmodqi4
 3163 0e42 9093 0000 		sts date_y,r25
 934:iv.c          **** 	display_date(DATE);
 3165               	.LM433:
 3166 0e46 80E0      		ldi r24,lo8(0)
 3167 0e48 0E94 0000 		call _Z12display_dateh
 935:iv.c          **** 	display[7] |= 0x1;
 3169               	.LM434:
 3170 0e4c 8091 0000 		lds r24,display+7
 3171 0e50 8160      		ori r24,lo8(1)
 3172 0e52 8093 0000 		sts display+7,r24
 936:iv.c          **** 	display[8] |= 0x1;
 3174               	.LM435:
 3175 0e56 8091 0000 		lds r24,display+8
 3176 0e5a 8160      		ori r24,lo8(1)
 3177 0e5c 8093 0000 		sts display+8,r24
 937:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_YEAR, date_y);    
 3179               	.LM436:
 3180 0e60 6091 0000 		lds r22,date_y
 3181 0e64 81E0      		ldi r24,lo8(1)
 3182 0e66 90E0      		ldi r25,hi8(1)
 3183               	.L175:
 3184 0e68 0E94 0000 		call __eewr_byte_m328p
 3185               	.L163:
 940:iv.c          ****       if (pressed & 0x4)
 3187               	.LM437:
 3188 0e6c 8091 0000 		lds r24,pressed
 3189 0e70 82FF      		sbrs r24,2
 3190 0e72 00C0      		rjmp .L173
 941:iv.c          **** 	delayms(60);
 3192               	.LM438:
 3193 0e74 8CE3      		ldi r24,lo8(60)
 3194 0e76 90E0      		ldi r25,hi8(60)
 3195 0e78 0E94 0000 		call _Z7delaymsj
 3196 0e7c 00C0      		rjmp .L173
 3197               	.L144:
 854:iv.c          ****     } else if (!timeoutcounter) {
 3199               	.LM439:
 3200 0e7e 8091 0000 		lds r24,timeoutcounter
 3201 0e82 8823      		tst r24
 3202 0e84 01F0      		breq .+2
 3203 0e86 00C0      		rjmp .L145
 3204 0e88 00C0      		rjmp .L176
 3205               	.L141:
 3206               	/* epilogue start */
 3207               	.LBE121:
 3208               	.LBE120:
 944:iv.c          **** }
 3210               	.LM440:
 3211 0e8a 1F91      		pop r17
 3212 0e8c 0F91      		pop r16
 3213 0e8e FF90      		pop r15
 3214 0e90 EF90      		pop r14
 3215 0e92 0895      		ret
 3220               	.Lscope18:
 3222               		.stabd	78,0,0
 3223               		.data
 3224               	.LC19:
 3225 0077 616C 6172 		.string	"alarm on"
 3225      6D20 6F6E 
 3225      00
 3226               		.text
 3228               	.global	_Z13setalarmstatev
 3230               	_Z13setalarmstatev:
 3231               		.stabd	46,0,0
1235:iv.c          **** void setalarmstate(void) {
 3233               	.LM441:
 3234               	.LFBB19:
 3235               	/* prologue: function */
 3236               	/* frame size = 0 */
 3237               	/* stack size = 0 */
 3238               	.L__stack_usage = 0
 3239               	.LBB131:
1236:iv.c          ****   if (ALARM_PIN & _BV(ALARM)) { 
 3241               	.LM442:
 3242 0e94 4A9B      		sbis 41-32,2
 3243 0e96 00C0      		rjmp .L179
1238:iv.c          ****     if  (!alarm_on) {
 3245               	.LM443:
 3246 0e98 8091 0000 		lds r24,alarm_on
 3247 0e9c 8823      		tst r24
 3248 0e9e 01F4      		brne .L178
1240:iv.c          ****       alarm_on = 1;
 3250               	.LM444:
 3251 0ea0 81E0      		ldi r24,lo8(1)
 3252 0ea2 8093 0000 		sts alarm_on,r24
1242:iv.c          ****       snoozetimer = 0;
 3254               	.LM445:
 3255 0ea6 1092 0000 		sts snoozetimer+1,__zero_reg__
 3256 0eaa 1092 0000 		sts snoozetimer,__zero_reg__
1244:iv.c          ****       display_str("alarm on");
 3258               	.LM446:
 3259 0eae 80E0      		ldi r24,lo8(.LC19)
 3260 0eb0 90E0      		ldi r25,hi8(.LC19)
 3261 0eb2 0E94 0000 		call _Z11display_strPKc
1246:iv.c          ****       displaymode = SHOW_SNOOZE;
 3263               	.LM447:
 3264 0eb6 89E0      		ldi r24,lo8(9)
 3265 0eb8 8093 0000 		sts displaymode,r24
1247:iv.c          ****       delayms(1000);
 3267               	.LM448:
 3268 0ebc 88EE      		ldi r24,lo8(1000)
 3269 0ebe 93E0      		ldi r25,hi8(1000)
 3270 0ec0 0E94 0000 		call _Z7delaymsj
1249:iv.c          ****       display_alarm(alarm_h, alarm_m);
 3272               	.LM449:
 3273 0ec4 8091 0000 		lds r24,alarm_h
 3274 0ec8 6091 0000 		lds r22,alarm_m
 3275 0ecc 0E94 0000 		call _Z13display_alarmhh
1250:iv.c          ****       delayms(1000);
 3277               	.LM450:
 3278 0ed0 88EE      		ldi r24,lo8(1000)
 3279 0ed2 93E0      		ldi r25,hi8(1000)
 3280 0ed4 0E94 0000 		call _Z7delaymsj
1252:iv.c          ****       displaymode = SHOW_TIME;
 3282               	.LM451:
 3283 0ed8 1092 0000 		sts displaymode,__zero_reg__
 3284 0edc 0895      		ret
 3285               	.L179:
 3286               	.LBB132:
1255:iv.c          ****     if (alarm_on) {
 3288               	.LM452:
 3289 0ede 8091 0000 		lds r24,alarm_on
 3290 0ee2 8823      		tst r24
 3291 0ee4 01F0      		breq .L178
 3292               	.LBB133:
1257:iv.c          ****       alarm_on = 0;
 3294               	.LM453:
 3295 0ee6 1092 0000 		sts alarm_on,__zero_reg__
1258:iv.c          ****       snoozetimer = 0;
 3297               	.LM454:
 3298 0eea 1092 0000 		sts snoozetimer+1,__zero_reg__
 3299 0eee 1092 0000 		sts snoozetimer,__zero_reg__
 3300               	.LBB134:
1259:iv.c          ****       if (alarming) {
 3302               	.LM455:
 3303 0ef2 8091 0000 		lds r24,alarming
 3304 0ef6 8823      		tst r24
 3305 0ef8 01F0      		breq .L178
 3306               	.LBB135:
 3307               	.LBB136:
1262:iv.c          **** 	DEBUGP("alarm off");
 3309               	.LM456:
 3310 0efa 80E0      		ldi r24,lo8(_ZZ13setalarmstatevE3__c)
 3311 0efc 90E0      		ldi r25,hi8(_ZZ13setalarmstatevE3__c)
 3312 0efe 61E0      		ldi r22,lo8(1)
 3313 0f00 0E94 0000 		call _Z13ROM_putstringPKch
 3314               	.LBE136:
1263:iv.c          **** 	alarming = 0;
 3316               	.LM457:
 3317 0f04 1092 0000 		sts alarming,__zero_reg__
1264:iv.c          **** 	TCCR1B &= ~_BV(CS11); // turn it off!
 3319               	.LM458:
 3320 0f08 8091 8100 		lds r24,129
 3321 0f0c 8D7F      		andi r24,lo8(-3)
 3322 0f0e 8093 8100 		sts 129,r24
1265:iv.c          **** 	PORTB |= _BV(SPK1) | _BV(SPK2);
 3324               	.LM459:
 3325 0f12 85B1      		in r24,37-32
 3326 0f14 8660      		ori r24,lo8(6)
 3327 0f16 85B9      		out 37-32,r24
 3328               	.L178:
 3329 0f18 0895      		ret
 3330               	.LBE135:
 3331               	.LBE134:
 3332               	.LBE133:
 3333               	.LBE132:
 3334               	.LBE131:
 3336               	.Lscope19:
 3338               		.stabd	78,0,0
 3340               	.global	__vector_1
 3342               	__vector_1:
 3343               		.stabd	46,0,0
 378:iv.c          **** ISR(INT0_vect) {
 3345               	.LM460:
 3346               	.LFBB20:
 3347 0f1a 1F92      		push __zero_reg__
 3348 0f1c 0F92      		push r0
 3349 0f1e 0FB6      		in r0,__SREG__
 3350 0f20 0F92      		push r0
 3351 0f22 1124      		clr __zero_reg__
 3352 0f24 1F93      		push r17
 3353 0f26 2F93      		push r18
 3354 0f28 3F93      		push r19
 3355 0f2a 4F93      		push r20
 3356 0f2c 5F93      		push r21
 3357 0f2e 6F93      		push r22
 3358 0f30 7F93      		push r23
 3359 0f32 8F93      		push r24
 3360 0f34 9F93      		push r25
 3361 0f36 AF93      		push r26
 3362 0f38 BF93      		push r27
 3363 0f3a EF93      		push r30
 3364 0f3c FF93      		push r31
 3365               	/* prologue: Signal */
 3366               	/* frame size = 0 */
 3367               	/* stack size = 16 */
 3368               	.L__stack_usage = 16
 3369               	.LBB137:
 379:iv.c          ****   uart_putchar('i');
 3371               	.LM461:
 3372 0f3e 89E6      		ldi r24,lo8(105)
 3373 0f40 0E94 0000 		call _Z12uart_putcharc
 380:iv.c          ****   uint8_t x = ALARM_PIN & _BV(ALARM);
 3375               	.LM462:
 3376 0f44 19B1      		in r17,41-32
 381:iv.c          ****   sei();
 3378               	.LM463:
 3379               	/* #APP */
 3380               	 ;  381 "iv.c" 1
 3381 0f46 7894      		sei
 3382               	 ;  0 "" 2
 382:iv.c          ****   delayms(10); // wait for debouncing
 3384               	.LM464:
 3385               	/* #NOAPP */
 3386 0f48 8AE0      		ldi r24,lo8(10)
 3387 0f4a 90E0      		ldi r25,hi8(10)
 3388 0f4c 0E94 0000 		call _Z7delaymsj
 383:iv.c          ****   if (x != (ALARM_PIN & _BV(ALARM)))
 3390               	.LM465:
 3391 0f50 89B1      		in r24,41-32
 380:iv.c          ****   uint8_t x = ALARM_PIN & _BV(ALARM);
 3393               	.LM466:
 3394 0f52 1470      		andi r17,lo8(4)
 383:iv.c          ****   if (x != (ALARM_PIN & _BV(ALARM)))
 3396               	.LM467:
 3397 0f54 212F      		mov r18,r17
 3398 0f56 30E0      		ldi r19,lo8(0)
 3399 0f58 90E0      		ldi r25,lo8(0)
 3400 0f5a 8470      		andi r24,lo8(4)
 3401 0f5c 9070      		andi r25,hi8(4)
 3402 0f5e 2817      		cp r18,r24
 3403 0f60 3907      		cpc r19,r25
 3404 0f62 01F4      		brne .L181
 385:iv.c          ****   setalarmstate();
 3406               	.LM468:
 3407 0f64 0E94 0000 		call _Z13setalarmstatev
 3408               	.L181:
 3409               	/* epilogue start */
 3410               	.LBE137:
 386:iv.c          **** }
 3412               	.LM469:
 3413 0f68 FF91      		pop r31
 3414 0f6a EF91      		pop r30
 3415 0f6c BF91      		pop r27
 3416 0f6e AF91      		pop r26
 3417 0f70 9F91      		pop r25
 3418 0f72 8F91      		pop r24
 3419 0f74 7F91      		pop r23
 3420 0f76 6F91      		pop r22
 3421 0f78 5F91      		pop r21
 3422 0f7a 4F91      		pop r20
 3423 0f7c 3F91      		pop r19
 3424 0f7e 2F91      		pop r18
 3425 0f80 1F91      		pop r17
 3426 0f82 0F90      		pop r0
 3427 0f84 0FBE      		out __SREG__,r0
 3428 0f86 0F90      		pop r0
 3429 0f88 1F90      		pop __zero_reg__
 3430 0f8a 1895      		reti
 3432               	.Lscope20:
 3434               		.stabd	78,0,0
 3436               	.global	_Z6wakeupv
 3438               	_Z6wakeupv:
 3439               		.stabd	46,0,0
 470:iv.c          ****  void wakeup(void) {
 3441               	.LM470:
 3442               	.LFBB21:
 3443               	/* prologue: function */
 3444               	/* frame size = 0 */
 3445               	/* stack size = 0 */
 3446               	.L__stack_usage = 0
 3447               	.LBB138:
 471:iv.c          ****    if (!sleepmode)
 3449               	.LM471:
 3450 0f8c 8091 0000 		lds r24,sleepmode
 3451 0f90 8823      		tst r24
 3452 0f92 01F0      		breq .L183
 473:iv.c          ****    CLKPR = _BV(CLKPCE);
 3454               	.LM472:
 3455 0f94 80E8      		ldi r24,lo8(-128)
 3456 0f96 8093 6100 		sts 97,r24
 474:iv.c          ****    CLKPR = 0;
 3458               	.LM473:
 3459 0f9a 1092 6100 		sts 97,__zero_reg__
 3460               	.LBB139:
 475:iv.c          ****    DEBUGP("waketime");
 3462               	.LM474:
 3463 0f9e 80E0      		ldi r24,lo8(_ZZ6wakeupvE3__c)
 3464 0fa0 90E0      		ldi r25,hi8(_ZZ6wakeupvE3__c)
 3465 0fa2 61E0      		ldi r22,lo8(1)
 3466 0fa4 0E94 0000 		call _Z13ROM_putstringPKch
 3467               	.LBE139:
 476:iv.c          ****    sleepmode = 0;
 3469               	.LM475:
 3470 0fa8 1092 0000 		sts sleepmode,__zero_reg__
 3471               	.LBB140:
 3472               	.LBB141:
 3474               	.Ltext5:
 3476               	.LM476:
 3477 0fac 8FE3      		 ldi r24,lo8(-25537)
 3478 0fae 9CE9      	    ldi r25,hi8(-25537)
 3479 0fb0 0197      	    1:sbiw r24,1
 3480 0fb2 01F4      	    brne 1b
 3481 0fb4 00C0      		rjmp .
 3482 0fb6 0000      		nop
 3483               	.LBE141:
 3484               	.LBE140:
 3486               	.Ltext6:
 480:iv.c          ****    if (ACSR & _BV(ACO)) 
 3488               	.LM477:
 3489 0fb8 00B6      		in __tmp_reg__,80-32
 3490 0fba 05FC      		sbrc __tmp_reg__,5
 3491 0fbc 00C0      		rjmp .L183
 484:iv.c          ****    initbuttons();
 3493               	.LM478:
 3494 0fbe 0E94 0000 		call _Z11initbuttonsv
 487:iv.c          ****    boost_init(eeprom_read_byte((uint8_t *)EE_BRIGHT));
 3496               	.LM479:
 3497 0fc2 89E0      		ldi r24,lo8(9)
 3498 0fc4 90E0      		ldi r25,hi8(9)
 3499 0fc6 0E94 0000 		call __eerd_byte_m328p
 3500 0fca 0E94 0000 		call _Z10boost_inith
 3501               	.LBB142:
 3502               	.LBB143:
1574:iv.c          **** 
1575:iv.c          **** /************************* LOW LEVEL DISPLAY ************************/
1576:iv.c          **** 
1577:iv.c          **** // Setup SPI
1578:iv.c          **** void vfd_init(void) {
1579:iv.c          ****   SPCR  = _BV(SPE) | _BV(MSTR) | _BV(SPR0);
 3504               	.LM480:
 3505 0fce 81E5      		ldi r24,lo8(81)
 3506 0fd0 8CBD      		out 76-32,r24
 3507               	.LBE143:
 3508               	.LBE142:
 493:iv.c          ****    VFDSWITCH_PORT &= ~_BV(VFDSWITCH); 
 3510               	.LM481:
 3511 0fd2 5B98      		cbi 43-32,3
 494:iv.c          ****    VFDBLANK_PORT &= ~_BV(VFDBLANK);
 3513               	.LM482:
 3514 0fd4 4398      		cbi 40-32,3
 495:iv.c          ****    volume = eeprom_read_byte((uint8_t *)EE_VOLUME); // reset
 3516               	.LM483:
 3517 0fd6 8AE0      		ldi r24,lo8(10)
 3518 0fd8 90E0      		ldi r25,hi8(10)
 3519 0fda 0E94 0000 		call __eerd_byte_m328p
 3520 0fde 8093 0000 		sts volume,r24
 497:iv.c          ****    speaker_init();
 3522               	.LM484:
 3523 0fe2 0E94 0000 		call _Z12speaker_initv
 3524               	.LBB144:
 3525               	.LBB145:
 118:iv.c          ****   wdt_reset();
 3527               	.LM485:
 3528               	/* #APP */
 3529               	 ;  118 "iv.c" 1
 3530 0fe6 A895      		wdr
 3531               	 ;  0 "" 2
 3532               	/* #NOAPP */
 3533               	.LBE145:
 3534               	.LBE144:
 501:iv.c          ****    setalarmstate();
 3536               	.LM486:
 3537 0fe8 0E94 0000 		call _Z13setalarmstatev
 504:iv.c          ****    beep(880, 1);
 3539               	.LM487:
 3540 0fec 80E7      		ldi r24,lo8(880)
 3541 0fee 93E0      		ldi r25,hi8(880)
 3542 0ff0 61E0      		ldi r22,lo8(1)
 3543 0ff2 0E94 0000 		call _Z4beepjh
 505:iv.c          ****    beep(1760, 1);
 3545               	.LM488:
 3546 0ff6 80EE      		ldi r24,lo8(1760)
 3547 0ff8 96E0      		ldi r25,hi8(1760)
 3548 0ffa 61E0      		ldi r22,lo8(1)
 3549 0ffc 0E94 0000 		call _Z4beepjh
 506:iv.c          ****    beep(3520, 1);
 3551               	.LM489:
 3552 1000 80EC      		ldi r24,lo8(3520)
 3553 1002 9DE0      		ldi r25,hi8(3520)
 3554 1004 61E0      		ldi r22,lo8(1)
 3555 1006 0E94 0000 		call _Z4beepjh
 3556               	.LBB146:
 3557               	.LBB147:
 118:iv.c          ****   wdt_reset();
 3559               	.LM490:
 3560               	/* #APP */
 3561               	 ;  118 "iv.c" 1
 3562 100a A895      		wdr
 3563               	 ;  0 "" 2
 3564               	/* #NOAPP */
 3565               	.L183:
 3566 100c 0895      		ret
 3567               	.LBE147:
 3568               	.LBE146:
 3569               	.LBE138:
 3571               	.Lscope21:
 3573               		.stabd	78,0,0
 3574               		.data
 3575               	.LC20:
 3576 0080 7573 612D 		.string	"usa-12hr"
 3576      3132 6872 
 3576      00
 3577               	.LC21:
 3578 0089 6575 722D 		.string	"eur-24hr"
 3578      3234 6872 
 3578      00
 3579               		.text
 3581               	.global	_Z10set_regionv
 3583               	_Z10set_regionv:
 3584               		.stabd	46,0,0
1089:iv.c          **** void set_region(void) {
 3586               	.LM491:
 3587               	.LFBB22:
 3588 100e 0F93      		push r16
 3589 1010 1F93      		push r17
 3590               	/* prologue: function */
 3591               	/* frame size = 0 */
 3592               	/* stack size = 2 */
 3593               	.L__stack_usage = 2
 3594               	.LBB148:
1092:iv.c          ****   timeoutcounter = INACTIVITYTIMEOUT;;  
 3596               	.LM492:
 3597 1012 8AE0      		ldi r24,lo8(10)
 3598 1014 8093 0000 		sts timeoutcounter,r24
1093:iv.c          ****   region = eeprom_read_byte((uint8_t *)EE_REGION);
 3600               	.LM493:
 3601 1018 8BE0      		ldi r24,lo8(11)
 3602 101a 90E0      		ldi r25,hi8(11)
 3603 101c 0E94 0000 		call __eerd_byte_m328p
 3604 1020 8093 0000 		sts region,r24
1090:iv.c          ****   uint8_t mode = SHOW_MENU;
 3606               	.LM494:
 3607 1024 10E0      		ldi r17,lo8(0)
1097:iv.c          ****       timeoutcounter = INACTIVITYTIMEOUT;;  
 3609               	.LM495:
 3610 1026 0AE0      		ldi r16,lo8(10)
 3611 1028 00C0      		rjmp .L202
 3612               	.L199:
1125:iv.c          ****       if (mode == SET_REG) {
 3614               	.LM496:
 3615 102a 10E0      		ldi r17,lo8(0)
 3616               	.L202:
1096:iv.c          ****     if (just_pressed || pressed) {
 3618               	.LM497:
 3619 102c 8091 0000 		lds r24,just_pressed
 3620 1030 8823      		tst r24
 3621 1032 01F4      		brne .L187
1096:iv.c          ****     if (just_pressed || pressed) {
 3623               	.LM498:
 3624 1034 8091 0000 		lds r24,pressed
 3625 1038 8823      		tst r24
 3626 103a 01F0      		breq .L188
 3627               	.L187:
1097:iv.c          ****       timeoutcounter = INACTIVITYTIMEOUT;;  
 3629               	.LM499:
 3630 103c 0093 0000 		sts timeoutcounter,r16
 3631               	.L189:
1104:iv.c          ****     if (just_pressed & 0x1) { // mode change
 3633               	.LM500:
 3634 1040 8091 0000 		lds r24,just_pressed
 3635 1044 80FD      		sbrc r24,0
 3636 1046 00C0      		rjmp .L185
1107:iv.c          ****     if (just_pressed & 0x2) {
 3638               	.LM501:
 3639 1048 8091 0000 		lds r24,just_pressed
 3640 104c 81FF      		sbrs r24,1
 3641 104e 00C0      		rjmp .L191
1108:iv.c          ****       just_pressed = 0;
 3643               	.LM502:
 3644 1050 1092 0000 		sts just_pressed,__zero_reg__
1109:iv.c          ****       if (mode == SHOW_MENU) {
 3646               	.LM503:
 3647 1054 1123      		tst r17
 3648 1056 01F4      		brne .L192
1113:iv.c          **** 	if (region == REGION_US) {
 3650               	.LM504:
 3651 1058 8091 0000 		lds r24,region
 3652 105c 8823      		tst r24
 3653 105e 01F4      		brne .L193
1114:iv.c          **** 	  display_str("usa-12hr");
 3655               	.LM505:
 3656 1060 80E0      		ldi r24,lo8(.LC20)
 3657 1062 90E0      		ldi r25,hi8(.LC20)
 3658 1064 00C0      		rjmp .L203
 3659               	.L193:
1116:iv.c          **** 	  display_str("eur-24hr");
 3661               	.LM506:
 3662 1066 80E0      		ldi r24,lo8(.LC21)
 3663 1068 90E0      		ldi r25,hi8(.LC21)
 3664               	.L203:
 3665 106a 0E94 0000 		call _Z11display_strPKc
1111:iv.c          **** 	mode = SET_REG;
 3667               	.LM507:
 3668 106e 11E0      		ldi r17,lo8(1)
 3669 1070 00C0      		rjmp .L191
 3670               	.L192:
1119:iv.c          **** 	displaymode = SHOW_TIME;
 3672               	.LM508:
 3673 1072 1092 0000 		sts displaymode,__zero_reg__
 3674 1076 00C0      		rjmp .L185
 3675               	.L191:
1123:iv.c          ****     if (just_pressed & 0x4) {
 3677               	.LM509:
 3678 1078 8091 0000 		lds r24,just_pressed
 3679 107c 82FF      		sbrs r24,2
 3680 107e 00C0      		rjmp .L202
1124:iv.c          ****       just_pressed = 0;
 3682               	.LM510:
 3683 1080 1092 0000 		sts just_pressed,__zero_reg__
1125:iv.c          ****       if (mode == SET_REG) {
 3685               	.LM511:
 3686 1084 1130      		cpi r17,lo8(1)
 3687 1086 01F4      		brne .L199
1126:iv.c          **** 	region = !region;
 3689               	.LM512:
 3690 1088 81E0      		ldi r24,lo8(1)
 3691 108a 9091 0000 		lds r25,region
 3692 108e 9111      		cpse r25,__zero_reg__
 3693 1090 80E0      		ldi r24,lo8(0)
 3694               	.L195:
 3695 1092 8093 0000 		sts region,r24
1127:iv.c          **** 	if (region == REGION_US) {
 3697               	.LM513:
 3698 1096 8823      		tst r24
 3699 1098 01F4      		brne .L196
1128:iv.c          **** 	  display_str("usa-12hr");
 3701               	.LM514:
 3702 109a 80E0      		ldi r24,lo8(.LC20)
 3703 109c 90E0      		ldi r25,hi8(.LC20)
 3704 109e 00C0      		rjmp .L204
 3705               	.L196:
1130:iv.c          **** 	  display_str("eur-24hr");
 3707               	.LM515:
 3708 10a0 80E0      		ldi r24,lo8(.LC21)
 3709 10a2 90E0      		ldi r25,hi8(.LC21)
 3710               	.L204:
 3711 10a4 0E94 0000 		call _Z11display_strPKc
1132:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_REGION, region);
 3713               	.LM516:
 3714 10a8 8BE0      		ldi r24,lo8(11)
 3715 10aa 90E0      		ldi r25,hi8(11)
 3716 10ac 6091 0000 		lds r22,region
 3717 10b0 0E94 0000 		call __eewr_byte_m328p
 3718 10b4 00C0      		rjmp .L202
 3719               	.L188:
1099:iv.c          ****     } else if (!timeoutcounter) {
 3721               	.LM517:
 3722 10b6 8091 0000 		lds r24,timeoutcounter
 3723 10ba 8823      		tst r24
 3724 10bc 01F0      		breq .+2
 3725 10be 00C0      		rjmp .L189
 3726 10c0 00C0      		rjmp .L192
 3727               	.L185:
 3728               	/* epilogue start */
 3729               	.LBE148:
1136:iv.c          **** }
 3731               	.LM518:
 3732 10c2 1F91      		pop r17
 3733 10c4 0F91      		pop r16
 3734 10c6 0895      		ret
 3739               	.Lscope22:
 3741               		.stabd	78,0,0
 3742               		.data
 3743               	.LC22:
 3744 0092 766F 6C20 		.string	"vol high"
 3744      6869 6768 
 3744      00
 3745               	.LC23:
 3746 009b 766F 6C20 		.string	"vol  low"
 3746      206C 6F77 
 3746      00
 3747               		.text
 3749               	.global	_Z10set_volumev
 3751               	_Z10set_volumev:
 3752               		.stabd	46,0,0
1026:iv.c          **** void set_volume(void) {
 3754               	.LM519:
 3755               	.LFBB23:
 3756 10c8 FF92      		push r15
 3757 10ca 0F93      		push r16
 3758 10cc 1F93      		push r17
 3759 10ce DF93      		push r29
 3760 10d0 CF93      		push r28
 3761 10d2 0F92      		push __tmp_reg__
 3762 10d4 CDB7      		in r28,__SP_L__
 3763 10d6 DEB7      		in r29,__SP_H__
 3764               	/* prologue: function */
 3765               	/* frame size = 1 */
 3766               	/* stack size = 6 */
 3767               	.L__stack_usage = 6
 3768               	.LBB149:
1030:iv.c          ****   timeoutcounter = INACTIVITYTIMEOUT;;  
 3770               	.LM520:
 3771 10d8 8AE0      		ldi r24,lo8(10)
 3772 10da 8093 0000 		sts timeoutcounter,r24
1031:iv.c          ****   volume = eeprom_read_byte((uint8_t *)EE_VOLUME);
 3774               	.LM521:
 3775 10de 8AE0      		ldi r24,lo8(10)
 3776 10e0 90E0      		ldi r25,hi8(10)
 3777 10e2 0E94 0000 		call __eerd_byte_m328p
 3778 10e6 082F      		mov r16,r24
1027:iv.c          ****   uint8_t mode = SHOW_MENU;
 3780               	.LM522:
 3781 10e8 10E0      		ldi r17,lo8(0)
1035:iv.c          ****       timeoutcounter = INACTIVITYTIMEOUT;;  
 3783               	.LM523:
 3784 10ea 8AE0      		ldi r24,lo8(10)
 3785 10ec F82E      		mov r15,r24
 3786 10ee 00C0      		rjmp .L223
 3787               	.L220:
1067:iv.c          ****       if (mode == SET_VOL) {
 3789               	.LM524:
 3790 10f0 10E0      		ldi r17,lo8(0)
 3791               	.L223:
1034:iv.c          ****     if (just_pressed || pressed) {
 3793               	.LM525:
 3794 10f2 8091 0000 		lds r24,just_pressed
 3795 10f6 8823      		tst r24
 3796 10f8 01F4      		brne .L207
1034:iv.c          ****     if (just_pressed || pressed) {
 3798               	.LM526:
 3799 10fa 8091 0000 		lds r24,pressed
 3800 10fe 8823      		tst r24
 3801 1100 01F4      		brne .+2
 3802 1102 00C0      		rjmp .L208
 3803               	.L207:
1035:iv.c          ****       timeoutcounter = INACTIVITYTIMEOUT;;  
 3805               	.LM527:
 3806 1104 F092 0000 		sts timeoutcounter,r15
 3807               	.L209:
1042:iv.c          ****     if (just_pressed & 0x1) { // mode change
 3809               	.LM528:
 3810 1108 8091 0000 		lds r24,just_pressed
 3811 110c 80FD      		sbrc r24,0
 3812 110e 00C0      		rjmp .L205
1045:iv.c          ****     if (just_pressed & 0x2) {
 3814               	.LM529:
 3815 1110 8091 0000 		lds r24,just_pressed
 3816 1114 81FF      		sbrs r24,1
 3817 1116 00C0      		rjmp .L211
1046:iv.c          ****       just_pressed = 0;
 3819               	.LM530:
 3820 1118 1092 0000 		sts just_pressed,__zero_reg__
1047:iv.c          ****       if (mode == SHOW_MENU) {
 3822               	.LM531:
 3823 111c 1123      		tst r17
 3824 111e 01F4      		brne .L212
1051:iv.c          **** 	if (volume) {
 3826               	.LM532:
 3827 1120 0023      		tst r16
 3828 1122 01F0      		breq .L213
1052:iv.c          **** 	  display_str("vol high");
 3830               	.LM533:
 3831 1124 80E0      		ldi r24,lo8(.LC22)
 3832 1126 90E0      		ldi r25,hi8(.LC22)
 3833 1128 0E94 0000 		call _Z11display_strPKc
1053:iv.c          **** 	  display[5] |= 0x1;
 3835               	.LM534:
 3836 112c 8091 0000 		lds r24,display+5
 3837 1130 8160      		ori r24,lo8(1)
 3838 1132 8093 0000 		sts display+5,r24
 3839 1136 00C0      		rjmp .L214
 3840               	.L213:
1055:iv.c          **** 	  display_str("vol  low");
 3842               	.LM535:
 3843 1138 80E0      		ldi r24,lo8(.LC23)
 3844 113a 90E0      		ldi r25,hi8(.LC23)
 3845 113c 0E94 0000 		call _Z11display_strPKc
 3846               	.L214:
1057:iv.c          **** 	display[6] |= 0x1;
 3848               	.LM536:
 3849 1140 8091 0000 		lds r24,display+6
 3850 1144 8160      		ori r24,lo8(1)
 3851 1146 8093 0000 		sts display+6,r24
1058:iv.c          **** 	display[7] |= 0x1;
 3853               	.LM537:
 3854 114a 8091 0000 		lds r24,display+7
 3855 114e 8160      		ori r24,lo8(1)
 3856 1150 8093 0000 		sts display+7,r24
1059:iv.c          **** 	display[8] |= 0x1;
 3858               	.LM538:
 3859 1154 8091 0000 		lds r24,display+8
 3860 1158 8160      		ori r24,lo8(1)
 3861 115a 8093 0000 		sts display+8,r24
1049:iv.c          **** 	mode = SET_VOL;
 3863               	.LM539:
 3864 115e 11E0      		ldi r17,lo8(1)
 3865 1160 00C0      		rjmp .L211
 3866               	.L212:
1061:iv.c          **** 	displaymode = SHOW_TIME;
 3868               	.LM540:
 3869 1162 1092 0000 		sts displaymode,__zero_reg__
 3870 1166 00C0      		rjmp .L205
 3871               	.L211:
1065:iv.c          ****     if (just_pressed & 0x4) {
 3873               	.LM541:
 3874 1168 8091 0000 		lds r24,just_pressed
 3875 116c 82FF      		sbrs r24,2
 3876 116e 00C0      		rjmp .L223
1066:iv.c          ****       just_pressed = 0;
 3878               	.LM542:
 3879 1170 1092 0000 		sts just_pressed,__zero_reg__
1067:iv.c          ****       if (mode == SET_VOL) {
 3881               	.LM543:
 3882 1174 1130      		cpi r17,lo8(1)
 3883 1176 01F0      		breq .+2
 3884 1178 00C0      		rjmp .L220
1068:iv.c          **** 	volume = !volume;
 3886               	.LM544:
 3887 117a 61E0      		ldi r22,lo8(1)
 3888 117c 0111      		cpse r16,__zero_reg__
 3889 117e 60E0      		ldi r22,lo8(0)
 3890               	.L216:
 3891 1180 062F      		mov r16,r22
1069:iv.c          **** 	if (volume) {
 3893               	.LM545:
 3894 1182 6623      		tst r22
 3895 1184 01F0      		breq .L217
1070:iv.c          **** 	  display_str("vol high");
 3897               	.LM546:
 3898 1186 80E0      		ldi r24,lo8(.LC22)
 3899 1188 90E0      		ldi r25,hi8(.LC22)
 3900 118a 6983      		std Y+1,r22
 3901 118c 0E94 0000 		call _Z11display_strPKc
1071:iv.c          **** 	  display[5] |= 0x1;
 3903               	.LM547:
 3904 1190 8091 0000 		lds r24,display+5
 3905 1194 8160      		ori r24,lo8(1)
 3906 1196 8093 0000 		sts display+5,r24
 3907 119a 00C0      		rjmp .L224
 3908               	.L217:
1073:iv.c          **** 	  display_str("vol  low");
 3910               	.LM548:
 3911 119c 80E0      		ldi r24,lo8(.LC23)
 3912 119e 90E0      		ldi r25,hi8(.LC23)
 3913 11a0 6983      		std Y+1,r22
 3914 11a2 0E94 0000 		call _Z11display_strPKc
 3915               	.L224:
 3916 11a6 6981      		ldd r22,Y+1
1075:iv.c          **** 	display[6] |= 0x1;
 3918               	.LM549:
 3919 11a8 8091 0000 		lds r24,display+6
 3920 11ac 8160      		ori r24,lo8(1)
 3921 11ae 8093 0000 		sts display+6,r24
1076:iv.c          **** 	display[7] |= 0x1;
 3923               	.LM550:
 3924 11b2 8091 0000 		lds r24,display+7
 3925 11b6 8160      		ori r24,lo8(1)
 3926 11b8 8093 0000 		sts display+7,r24
1077:iv.c          **** 	display[8] |= 0x1;
 3928               	.LM551:
 3929 11bc 8091 0000 		lds r24,display+8
 3930 11c0 8160      		ori r24,lo8(1)
 3931 11c2 8093 0000 		sts display+8,r24
1078:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_VOLUME, volume);
 3933               	.LM552:
 3934 11c6 8AE0      		ldi r24,lo8(10)
 3935 11c8 90E0      		ldi r25,hi8(10)
 3936 11ca 0E94 0000 		call __eewr_byte_m328p
1079:iv.c          **** 	speaker_init();
 3938               	.LM553:
 3939 11ce 0E94 0000 		call _Z12speaker_initv
1080:iv.c          **** 	beep(4000, 1);
 3941               	.LM554:
 3942 11d2 80EA      		ldi r24,lo8(4000)
 3943 11d4 9FE0      		ldi r25,hi8(4000)
 3944 11d6 61E0      		ldi r22,lo8(1)
 3945 11d8 0E94 0000 		call _Z4beepjh
 3946 11dc 00C0      		rjmp .L223
 3947               	.L208:
1037:iv.c          ****     } else if (!timeoutcounter) {
 3949               	.LM555:
 3950 11de 8091 0000 		lds r24,timeoutcounter
 3951 11e2 8823      		tst r24
 3952 11e4 01F0      		breq .+2
 3953 11e6 00C0      		rjmp .L209
 3954 11e8 00C0      		rjmp .L212
 3955               	.L205:
 3956               	/* epilogue start */
 3957               	.LBE149:
1084:iv.c          **** }
 3959               	.LM556:
 3960 11ea 0F90      		pop __tmp_reg__
 3961 11ec CF91      		pop r28
 3962 11ee DF91      		pop r29
 3963 11f0 1F91      		pop r17
 3964 11f2 0F91      		pop r16
 3965 11f4 FF90      		pop r15
 3966 11f6 0895      		ret
 3972               	.Lscope23:
 3974               		.stabd	78,0,0
 3975               		.data
 3976               	.LC24:
 3977 00a4 6272 6974 		.string	"brite "
 3977      6520 00
 3978               		.text
 3980               	.global	_Z14set_brightnessv
 3982               	_Z14set_brightnessv:
 3983               		.stabd	46,0,0
 947:iv.c          **** void set_brightness(void) {
 3985               	.LM557:
 3986               	.LFBB24:
 3987 11f8 3F92      		push r3
 3988 11fa 4F92      		push r4
 3989 11fc 5F92      		push r5
 3990 11fe 6F92      		push r6
 3991 1200 7F92      		push r7
 3992 1202 8F92      		push r8
 3993 1204 9F92      		push r9
 3994 1206 AF92      		push r10
 3995 1208 BF92      		push r11
 3996 120a CF92      		push r12
 3997 120c DF92      		push r13
 3998 120e EF92      		push r14
 3999 1210 FF92      		push r15
 4000 1212 0F93      		push r16
 4001 1214 1F93      		push r17
 4002               	/* prologue: function */
 4003               	/* frame size = 0 */
 4004               	/* stack size = 15 */
 4005               	.L__stack_usage = 15
 4006               	.LBB150:
 951:iv.c          ****   timeoutcounter = INACTIVITYTIMEOUT;;  
 4008               	.LM558:
 4009 1216 8AE0      		ldi r24,lo8(10)
 4010 1218 8093 0000 		sts timeoutcounter,r24
 952:iv.c          ****   brightness = eeprom_read_byte((uint8_t *)EE_BRIGHT);
 4012               	.LM559:
 4013 121c 89E0      		ldi r24,lo8(9)
 4014 121e 90E0      		ldi r25,hi8(9)
 4015 1220 0E94 0000 		call __eerd_byte_m328p
 4016 1224 182F      		mov r17,r24
 948:iv.c          ****   uint8_t mode = SHOW_MENU;
 4018               	.LM560:
 4019 1226 20E0      		ldi r18,lo8(0)
 4020               	.LBB151:
 956:iv.c          ****       timeoutcounter = INACTIVITYTIMEOUT;;  
 4022               	.LM561:
 4023 1228 0AE0      		ldi r16,lo8(10)
 4024               	.LBB152:
 4025               	.LBB153:
 4026               	.LBB154:
 4027               	.LBB155:
1018:iv.c          **** 	  OCR0A = 30;
 4029               	.LM562:
 4030 122a 3EE1      		ldi r19,lo8(30)
 4031 122c F32E      		mov r15,r19
1016:iv.c          **** 	  OCR0A = 90;
 4033               	.LM563:
 4034 122e 9AE5      		ldi r25,lo8(90)
 4035 1230 692E      		mov r6,r25
1014:iv.c          **** 	  OCR0A = 85;
 4037               	.LM564:
 4038 1232 85E5      		ldi r24,lo8(85)
 4039 1234 782E      		mov r7,r24
1012:iv.c          **** 	  OCR0A = 80;
 4041               	.LM565:
 4042 1236 B0E5      		ldi r27,lo8(80)
 4043 1238 8B2E      		mov r8,r27
1010:iv.c          **** 	  OCR0A = 75;
 4045               	.LM566:
 4046 123a ABE4      		ldi r26,lo8(75)
 4047 123c 9A2E      		mov r9,r26
1008:iv.c          **** 	  OCR0A = 70;
 4049               	.LM567:
 4050 123e F6E4      		ldi r31,lo8(70)
 4051 1240 AF2E      		mov r10,r31
1006:iv.c          **** 	  OCR0A = 65;
 4053               	.LM568:
 4054 1242 E1E4      		ldi r30,lo8(65)
 4055 1244 BE2E      		mov r11,r30
1004:iv.c          **** 	  OCR0A = 60;
 4057               	.LM569:
 4058 1246 7CE3      		ldi r23,lo8(60)
 4059 1248 C72E      		mov r12,r23
1002:iv.c          **** 	  OCR0A = 55;
 4061               	.LM570:
 4062 124a 67E3      		ldi r22,lo8(55)
 4063 124c D62E      		mov r13,r22
1000:iv.c          **** 	  OCR0A = 50;
 4065               	.LM571:
 4066 124e 52E3      		ldi r21,lo8(50)
 4067 1250 E52E      		mov r14,r21
 998:iv.c          **** 	  OCR0A = 45;
 4069               	.LM572:
 4070 1252 4DE2      		ldi r20,lo8(45)
 4071 1254 542E      		mov r5,r20
 996:iv.c          **** 	  OCR0A = 40;
 4073               	.LM573:
 4074 1256 38E2      		ldi r19,lo8(40)
 4075 1258 432E      		mov r4,r19
 994:iv.c          **** 	  OCR0A = 35;
 4077               	.LM574:
 4078 125a 93E2      		ldi r25,lo8(35)
 4079 125c 392E      		mov r3,r25
 4080 125e 00C0      		rjmp .L254
 4081               	.L250:
 4082               	.LBE155:
 985:iv.c          ****       if (mode == SET_BRITE) {
 4084               	.LM575:
 4085 1260 20E0      		ldi r18,lo8(0)
 4086               	.L254:
 4087               	.LBE154:
 4088               	.LBE153:
 4089               	.LBE152:
 955:iv.c          ****     if (just_pressed || pressed) {
 4091               	.LM576:
 4092 1262 8091 0000 		lds r24,just_pressed
 4093 1266 8823      		tst r24
 4094 1268 01F4      		brne .L227
 955:iv.c          ****     if (just_pressed || pressed) {
 4096               	.LM577:
 4097 126a 8091 0000 		lds r24,pressed
 4098 126e 8823      		tst r24
 4099 1270 01F4      		brne .+2
 4100 1272 00C0      		rjmp .L228
 4101               	.L227:
 956:iv.c          ****       timeoutcounter = INACTIVITYTIMEOUT;;  
 4103               	.LM578:
 4104 1274 0093 0000 		sts timeoutcounter,r16
 4105               	.L229:
 964:iv.c          ****     if (just_pressed & 0x1) { // mode change
 4107               	.LM579:
 4108 1278 8091 0000 		lds r24,just_pressed
 4109 127c 80FD      		sbrc r24,0
 4110 127e 00C0      		rjmp .L225
 4111               	.LBB161:
 967:iv.c          ****     if (just_pressed & 0x2) {
 4113               	.LM580:
 4114 1280 8091 0000 		lds r24,just_pressed
 4115 1284 81FF      		sbrs r24,1
 4116 1286 00C0      		rjmp .L231
 4117               	.LBB162:
 969:iv.c          ****       just_pressed = 0;
 4119               	.LM581:
 4120 1288 1092 0000 		sts just_pressed,__zero_reg__
 4121               	.LBB163:
 970:iv.c          ****       if (mode == SHOW_MENU) {
 4123               	.LM582:
 4124 128c 2223      		tst r18
 4125 128e 01F4      		brne .L232
 4126               	.LBB164:
 974:iv.c          **** 	display_str("brite ");
 4128               	.LM583:
 4129 1290 80E0      		ldi r24,lo8(.LC24)
 4130 1292 90E0      		ldi r25,hi8(.LC24)
 4131 1294 0E94 0000 		call _Z11display_strPKc
 4132               	.LBB165:
 975:iv.c          **** 	display[7] = pgm_read_byte(numbertable + (brightness / 10)) | 0x1;
 4134               	.LM584:
 4135 1298 812F      		mov r24,r17
 4136 129a 602F      		mov r22,r16
 4137 129c 0E94 0000 		call __udivmodqi4
 4138 12a0 E82F      		mov r30,r24
 4139 12a2 F0E0      		ldi r31,lo8(0)
 4140 12a4 E050      		subi r30,lo8(-(_ZL11numbertable))
 4141 12a6 F040      		sbci r31,hi8(-(_ZL11numbertable))
 4142               	/* #APP */
 4143               	 ;  975 "iv.c" 1
 4144 12a8 E491      		lpm r30, Z
 4145               		
 4146               	 ;  0 "" 2
 4147               	/* #NOAPP */
 4148               	.LBE165:
 4149 12aa E160      		ori r30,lo8(1)
 4150 12ac E093 0000 		sts display+7,r30
 4151               	.LBB166:
 976:iv.c          **** 	display[8] = pgm_read_byte(numbertable + (brightness % 10)) | 0x1;
 4153               	.LM585:
 4154 12b0 E92F      		mov r30,r25
 4155 12b2 F0E0      		ldi r31,lo8(0)
 4156 12b4 E050      		subi r30,lo8(-(_ZL11numbertable))
 4157 12b6 F040      		sbci r31,hi8(-(_ZL11numbertable))
 4158               	/* #APP */
 4159               	 ;  976 "iv.c" 1
 4160 12b8 E491      		lpm r30, Z
 4161               		
 4162               	 ;  0 "" 2
 4163               	/* #NOAPP */
 4164               	.LBE166:
 4165 12ba E160      		ori r30,lo8(1)
 4166 12bc E093 0000 		sts display+8,r30
 972:iv.c          **** 	mode = SET_BRITE;
 4168               	.LM586:
 4169 12c0 21E0      		ldi r18,lo8(1)
 4170 12c2 00C0      		rjmp .L231
 4171               	.L232:
 4172               	.LBE164:
 978:iv.c          **** 	displaymode = SHOW_TIME;
 4174               	.LM587:
 4175 12c4 1092 0000 		sts displaymode,__zero_reg__
 979:iv.c          **** 	eeprom_write_byte((uint8_t *)EE_BRIGHT, brightness);
 4177               	.LM588:
 4178 12c8 89E0      		ldi r24,lo8(9)
 4179 12ca 90E0      		ldi r25,hi8(9)
 4180 12cc 612F      		mov r22,r17
 4181 12ce 0E94 0000 		call __eewr_byte_m328p
 4182 12d2 00C0      		rjmp .L225
 4183               	.L231:
 4184               	.LBE163:
 4185               	.LBE162:
 4186               	.LBE161:
 4187               	.LBB167:
 983:iv.c          ****     if ((just_pressed & 0x4) || (pressed & 0x4)) {
 4189               	.LM589:
 4190 12d4 8091 0000 		lds r24,just_pressed
 4191 12d8 82FD      		sbrc r24,2
 4192 12da 00C0      		rjmp .L233
 983:iv.c          ****     if ((just_pressed & 0x4) || (pressed & 0x4)) {
 4194               	.LM590:
 4195 12dc 8091 0000 		lds r24,pressed
 4196 12e0 82FF      		sbrs r24,2
 4197 12e2 00C0      		rjmp .L254
 4198               	.L233:
 4199               	.LBB160:
 984:iv.c          ****       just_pressed = 0;
 4201               	.LM591:
 4202 12e4 1092 0000 		sts just_pressed,__zero_reg__
 4203               	.LBB159:
 985:iv.c          ****       if (mode == SET_BRITE) {
 4205               	.LM592:
 4206 12e8 2130      		cpi r18,lo8(1)
 4207 12ea 01F0      		breq .+2
 4208 12ec 00C0      		rjmp .L250
 4209               	.LBB158:
 986:iv.c          **** 	brightness += 5;
 4211               	.LM593:
 4212 12ee 1B5F      		subi r17,lo8(-(5))
 987:iv.c          **** 	if (brightness > 91)
 4214               	.LM594:
 4215 12f0 1C35      		cpi r17,lo8(92)
 4216 12f2 00F0      		brlo .L235
 988:iv.c          **** 	  brightness = 30;
 4218               	.LM595:
 4219 12f4 1EE1      		ldi r17,lo8(30)
 4220               	.L235:
 4221               	.LBB156:
 989:iv.c          **** 	display[7] = pgm_read_byte(numbertable + (brightness / 10)) | 0x1;
 4223               	.LM596:
 4224 12f6 812F      		mov r24,r17
 4225 12f8 602F      		mov r22,r16
 4226 12fa 0E94 0000 		call __udivmodqi4
 4227 12fe E82F      		mov r30,r24
 4228 1300 F0E0      		ldi r31,lo8(0)
 4229 1302 E050      		subi r30,lo8(-(_ZL11numbertable))
 4230 1304 F040      		sbci r31,hi8(-(_ZL11numbertable))
 4231               	/* #APP */
 4232               	 ;  989 "iv.c" 1
 4233 1306 E491      		lpm r30, Z
 4234               		
 4235               	 ;  0 "" 2
 4236               	/* #NOAPP */
 4237               	.LBE156:
 4238 1308 E160      		ori r30,lo8(1)
 4239 130a E093 0000 		sts display+7,r30
 4240               	.LBB157:
 990:iv.c          **** 	display[8] = pgm_read_byte(numbertable + (brightness % 10)) | 0x1;
 4242               	.LM597:
 4243 130e E92F      		mov r30,r25
 4244 1310 F0E0      		ldi r31,lo8(0)
 4245 1312 E050      		subi r30,lo8(-(_ZL11numbertable))
 4246 1314 F040      		sbci r31,hi8(-(_ZL11numbertable))
 4247               	/* #APP */
 4248               	 ;  990 "iv.c" 1
 4249 1316 E491      		lpm r30, Z
 4250               		
 4251               	 ;  0 "" 2
 4252               	/* #NOAPP */
 4253               	.LBE157:
 4254 1318 E160      		ori r30,lo8(1)
 4255 131a E093 0000 		sts display+8,r30
 991:iv.c          **** 	if (brightness <= 30) {
 4257               	.LM598:
 4258 131e 1F31      		cpi r17,lo8(31)
 4259 1320 00F0      		brlo .L248
 4260               	.L236:
 993:iv.c          **** 	} else if (brightness <= 35) {
 4262               	.LM599:
 4263 1322 1432      		cpi r17,lo8(36)
 4264 1324 00F4      		brsh .L237
 994:iv.c          **** 	  OCR0A = 35;
 4266               	.LM600:
 4267 1326 37BC      		out 71-32,r3
 4268 1328 00C0      		rjmp .L254
 4269               	.L237:
 995:iv.c          **** 	} else if (brightness <= 40) {
 4271               	.LM601:
 4272 132a 1932      		cpi r17,lo8(41)
 4273 132c 00F4      		brsh .L238
 996:iv.c          **** 	  OCR0A = 40;
 4275               	.LM602:
 4276 132e 47BC      		out 71-32,r4
 4277 1330 00C0      		rjmp .L254
 4278               	.L238:
 997:iv.c          **** 	} else if (brightness <= 45) {
 4280               	.LM603:
 4281 1332 1E32      		cpi r17,lo8(46)
 4282 1334 00F4      		brsh .L239
 998:iv.c          **** 	  OCR0A = 45;
 4284               	.LM604:
 4285 1336 57BC      		out 71-32,r5
 4286 1338 00C0      		rjmp .L254
 4287               	.L239:
 999:iv.c          **** 	} else if (brightness <= 50) {
 4289               	.LM605:
 4290 133a 1333      		cpi r17,lo8(51)
 4291 133c 00F4      		brsh .L240
1000:iv.c          **** 	  OCR0A = 50;
 4293               	.LM606:
 4294 133e E7BC      		out 71-32,r14
 4295 1340 00C0      		rjmp .L254
 4296               	.L240:
1001:iv.c          **** 	} else if (brightness <= 55) {
 4298               	.LM607:
 4299 1342 1833      		cpi r17,lo8(56)
 4300 1344 00F4      		brsh .L241
1002:iv.c          **** 	  OCR0A = 55;
 4302               	.LM608:
 4303 1346 D7BC      		out 71-32,r13
 4304 1348 00C0      		rjmp .L254
 4305               	.L241:
1003:iv.c          **** 	} else if (brightness <= 60) {
 4307               	.LM609:
 4308 134a 1D33      		cpi r17,lo8(61)
 4309 134c 00F4      		brsh .L242
1004:iv.c          **** 	  OCR0A = 60;
 4311               	.LM610:
 4312 134e C7BC      		out 71-32,r12
 4313 1350 00C0      		rjmp .L254
 4314               	.L242:
1005:iv.c          **** 	} else if (brightness <= 65) {
 4316               	.LM611:
 4317 1352 1234      		cpi r17,lo8(66)
 4318 1354 00F4      		brsh .L243
1006:iv.c          **** 	  OCR0A = 65;
 4320               	.LM612:
 4321 1356 B7BC      		out 71-32,r11
 4322 1358 00C0      		rjmp .L254
 4323               	.L243:
1007:iv.c          **** 	} else if (brightness <= 70) {
 4325               	.LM613:
 4326 135a 1734      		cpi r17,lo8(71)
 4327 135c 00F4      		brsh .L244
1008:iv.c          **** 	  OCR0A = 70;
 4329               	.LM614:
 4330 135e A7BC      		out 71-32,r10
 4331 1360 00C0      		rjmp .L254
 4332               	.L244:
1009:iv.c          **** 	} else if (brightness <= 75) {
 4334               	.LM615:
 4335 1362 1C34      		cpi r17,lo8(76)
 4336 1364 00F4      		brsh .L245
1010:iv.c          **** 	  OCR0A = 75;
 4338               	.LM616:
 4339 1366 97BC      		out 71-32,r9
 4340 1368 00C0      		rjmp .L254
 4341               	.L245:
1011:iv.c          **** 	} else if (brightness <= 80) {
 4343               	.LM617:
 4344 136a 1135      		cpi r17,lo8(81)
 4345 136c 00F4      		brsh .L246
1012:iv.c          **** 	  OCR0A = 80;
 4347               	.LM618:
 4348 136e 87BC      		out 71-32,r8
 4349 1370 00C0      		rjmp .L254
 4350               	.L246:
1013:iv.c          **** 	} else if (brightness <= 85) {
 4352               	.LM619:
 4353 1372 1635      		cpi r17,lo8(86)
 4354 1374 00F4      		brsh .L247
1014:iv.c          **** 	  OCR0A = 85;
 4356               	.LM620:
 4357 1376 77BC      		out 71-32,r7
 4358 1378 00C0      		rjmp .L254
 4359               	.L247:
1015:iv.c          **** 	} else if (brightness <= 90) {
 4361               	.LM621:
 4362 137a 1B35      		cpi r17,lo8(91)
 4363 137c 01F0      		breq .L248
1016:iv.c          **** 	  OCR0A = 90;
 4365               	.LM622:
 4366 137e 67BC      		out 71-32,r6
 4367 1380 00C0      		rjmp .L254
 4368               	.L248:
1018:iv.c          **** 	  OCR0A = 30;
 4370               	.LM623:
 4371 1382 F7BC      		out 71-32,r15
 4372 1384 00C0      		rjmp .L254
 4373               	.L228:
 4374               	.LBE158:
 4375               	.LBE159:
 4376               	.LBE160:
 4377               	.LBE167:
 958:iv.c          ****     } else if (!timeoutcounter) {
 4379               	.LM624:
 4380 1386 8091 0000 		lds r24,timeoutcounter
 4381 138a 8823      		tst r24
 4382 138c 01F0      		breq .+2
 4383 138e 00C0      		rjmp .L229
 4384 1390 00C0      		rjmp .L232
 4385               	.L225:
 4386               	/* epilogue start */
 4387               	.LBE151:
 4388               	.LBE150:
1023:iv.c          **** }
 4390               	.LM625:
 4391 1392 1F91      		pop r17
 4392 1394 0F91      		pop r16
 4393 1396 FF90      		pop r15
 4394 1398 EF90      		pop r14
 4395 139a DF90      		pop r13
 4396 139c CF90      		pop r12
 4397 139e BF90      		pop r11
 4398 13a0 AF90      		pop r10
 4399 13a2 9F90      		pop r9
 4400 13a4 8F90      		pop r8
 4401 13a6 7F90      		pop r7
 4402 13a8 6F90      		pop r6
 4403 13aa 5F90      		pop r5
 4404 13ac 4F90      		pop r4
 4405 13ae 3F90      		pop r3
 4406 13b0 0895      		ret
 4412               	.Lscope24:
 4414               		.stabd	78,0,0
 4415               		.data
 4416               	.LC25:
 4417 00ab 2020 2020 		.string	"        "
 4417      2020 2020 
 4417      00
 4418               		.text
 4420               	.global	__vector_9
 4422               	__vector_9:
 4423               		.stabd	46,0,0
 284:iv.c          **** ISR(TIMER2_OVF_vect) {
 4425               	.LM626:
 4426               	.LFBB25:
 4427 13b2 1F92      		push __zero_reg__
 4428 13b4 0F92      		push r0
 4429 13b6 0FB6      		in r0,__SREG__
 4430 13b8 0F92      		push r0
 4431 13ba 1124      		clr __zero_reg__
 4432 13bc 2F93      		push r18
 4433 13be 3F93      		push r19
 4434 13c0 4F93      		push r20
 4435 13c2 5F93      		push r21
 4436 13c4 6F93      		push r22
 4437 13c6 7F93      		push r23
 4438 13c8 8F93      		push r24
 4439 13ca 9F93      		push r25
 4440 13cc AF93      		push r26
 4441 13ce BF93      		push r27
 4442 13d0 EF93      		push r30
 4443 13d2 FF93      		push r31
 4444               	/* prologue: Signal */
 4445               	/* frame size = 0 */
 4446               	/* stack size = 15 */
 4447               	.L__stack_usage = 15
 4448               	.LBB168:
 285:iv.c          ****   CLKPR = _BV(CLKPCE);  //MEME
 4450               	.LM627:
 4451 13d4 80E8      		ldi r24,lo8(-128)
 4452 13d6 8093 6100 		sts 97,r24
 286:iv.c          ****   CLKPR = 0;
 4454               	.LM628:
 4455 13da 1092 6100 		sts 97,__zero_reg__
 288:iv.c          ****   time_s++;             // one second has gone by
 4457               	.LM629:
 4458 13de 8091 0000 		lds r24,time_s
 4459 13e2 8F5F      		subi r24,lo8(-(1))
 4460 13e4 8093 0000 		sts time_s,r24
 291:iv.c          ****   if (time_s >= 60) {
 4462               	.LM630:
 4463 13e8 8091 0000 		lds r24,time_s
 4464 13ec 8C33      		cpi r24,lo8(60)
 4465 13ee 00F0      		brlo .L256
 292:iv.c          ****     time_s = 0;
 4467               	.LM631:
 4468 13f0 1092 0000 		sts time_s,__zero_reg__
 293:iv.c          ****     time_m++;
 4470               	.LM632:
 4471 13f4 8091 0000 		lds r24,time_m
 4472 13f8 8F5F      		subi r24,lo8(-(1))
 4473 13fa 8093 0000 		sts time_m,r24
 4474               	.L256:
 297:iv.c          ****   if (time_m >= 60) {
 4476               	.LM633:
 4477 13fe 8091 0000 		lds r24,time_m
 4478 1402 8C33      		cpi r24,lo8(60)
 4479 1404 00F0      		brlo .L257
 298:iv.c          ****     time_m = 0;
 4481               	.LM634:
 4482 1406 1092 0000 		sts time_m,__zero_reg__
 299:iv.c          ****     time_h++; 
 4484               	.LM635:
 4485 140a 8091 0000 		lds r24,time_h
 4486 140e 8F5F      		subi r24,lo8(-(1))
 4487 1410 8093 0000 		sts time_h,r24
 301:iv.c          ****     eeprom_write_byte((uint8_t *)EE_HOUR, time_h);
 4489               	.LM636:
 4490 1414 6091 0000 		lds r22,time_h
 4491 1418 84E0      		ldi r24,lo8(4)
 4492 141a 90E0      		ldi r25,hi8(4)
 4493 141c 0E94 0000 		call __eewr_byte_m328p
 302:iv.c          ****     eeprom_write_byte((uint8_t *)EE_MIN, time_m);
 4495               	.LM637:
 4496 1420 6091 0000 		lds r22,time_m
 4497 1424 85E0      		ldi r24,lo8(5)
 4498 1426 90E0      		ldi r25,hi8(5)
 4499 1428 0E94 0000 		call __eewr_byte_m328p
 4500               	.L257:
 306:iv.c          ****   if (time_h >= 24) {
 4502               	.LM638:
 4503 142c 8091 0000 		lds r24,time_h
 4504 1430 8831      		cpi r24,lo8(24)
 4505 1432 00F0      		brlo .L258
 307:iv.c          ****     time_h = 0;
 4507               	.LM639:
 4508 1434 1092 0000 		sts time_h,__zero_reg__
 308:iv.c          ****     date_d++;
 4510               	.LM640:
 4511 1438 8091 0000 		lds r24,date_d
 4512 143c 8F5F      		subi r24,lo8(-(1))
 4513 143e 8093 0000 		sts date_d,r24
 309:iv.c          ****     eeprom_write_byte((uint8_t *)EE_DAY, date_d);
 4515               	.LM641:
 4516 1442 6091 0000 		lds r22,date_d
 4517 1446 83E0      		ldi r24,lo8(3)
 4518 1448 90E0      		ldi r25,hi8(3)
 4519 144a 0E94 0000 		call __eewr_byte_m328p
 4520               	.L258:
 325:iv.c          ****   if ((date_d > 31) ||
 4522               	.LM642:
 4523 144e 8091 0000 		lds r24,date_d
 4524 1452 8032      		cpi r24,lo8(32)
 4525 1454 00F4      		brsh .L259
 325:iv.c          ****   if ((date_d > 31) ||
 4527               	.LM643:
 4528 1456 8091 0000 		lds r24,date_d
 4529 145a 8F31      		cpi r24,lo8(31)
 4530 145c 01F4      		brne .L260
 325:iv.c          ****   if ((date_d > 31) ||
 4532               	.LM644:
 4533 145e 8091 0000 		lds r24,date_m
 4534 1462 8430      		cpi r24,lo8(4)
 4535 1464 01F0      		breq .L259
 325:iv.c          ****   if ((date_d > 31) ||
 4537               	.LM645:
 4538 1466 8091 0000 		lds r24,date_m
 4539 146a 8630      		cpi r24,lo8(6)
 4540 146c 01F0      		breq .L259
 325:iv.c          ****   if ((date_d > 31) ||
 4542               	.LM646:
 4543 146e 8091 0000 		lds r24,date_m
 4544 1472 8930      		cpi r24,lo8(9)
 4545 1474 01F0      		breq .L259
 325:iv.c          ****   if ((date_d > 31) ||
 4547               	.LM647:
 4548 1476 8091 0000 		lds r24,date_m
 4549 147a 8B30      		cpi r24,lo8(11)
 4550 147c 01F0      		breq .L259
 4551               	.L260:
 325:iv.c          ****   if ((date_d > 31) ||
 4553               	.LM648:
 4554 147e 8091 0000 		lds r24,date_d
 4555 1482 8E31      		cpi r24,lo8(30)
 4556 1484 01F4      		brne .L261
 325:iv.c          ****   if ((date_d > 31) ||
 4558               	.LM649:
 4559 1486 8091 0000 		lds r24,date_m
 4560 148a 8230      		cpi r24,lo8(2)
 4561 148c 01F0      		breq .L259
 4562               	.L261:
 325:iv.c          ****   if ((date_d > 31) ||
 4564               	.LM650:
 4565 148e 8091 0000 		lds r24,date_d
 4566 1492 8D31      		cpi r24,lo8(29)
 4567 1494 01F4      		brne .L262
 325:iv.c          ****   if ((date_d > 31) ||
 4569               	.LM651:
 4570 1496 8091 0000 		lds r24,date_m
 4571 149a 8230      		cpi r24,lo8(2)
 4572 149c 01F4      		brne .L262
 328:iv.c          ****       ((date_d == 29) && (date_m == 2) && !leapyear(2000+date_y))) {
 4574               	.LM652:
 4575 149e 8091 0000 		lds r24,date_y
 4576 14a2 90E0      		ldi r25,lo8(0)
 4577 14a4 8053      		subi r24,lo8(-(2000))
 4578 14a6 984F      		sbci r25,hi8(-(2000))
 4579 14a8 0E94 0000 		call _Z8leapyearj
 325:iv.c          ****   if ((date_d > 31) ||
 4581               	.LM653:
 4582 14ac 8823      		tst r24
 4583 14ae 01F4      		brne .L262
 4584               	.L259:
 329:iv.c          ****     date_d = 1;
 4586               	.LM654:
 4587 14b0 81E0      		ldi r24,lo8(1)
 4588 14b2 8093 0000 		sts date_d,r24
 330:iv.c          ****     date_m++;
 4590               	.LM655:
 4591 14b6 8091 0000 		lds r24,date_m
 4592 14ba 8F5F      		subi r24,lo8(-(1))
 4593 14bc 8093 0000 		sts date_m,r24
 331:iv.c          ****     eeprom_write_byte((uint8_t *)EE_MONTH, date_m);
 4595               	.LM656:
 4596 14c0 6091 0000 		lds r22,date_m
 4597 14c4 82E0      		ldi r24,lo8(2)
 4598 14c6 90E0      		ldi r25,hi8(2)
 4599 14c8 0E94 0000 		call __eewr_byte_m328p
 4600               	.L262:
 335:iv.c          ****   if (date_m >= 13) {
 4602               	.LM657:
 4603 14cc 8091 0000 		lds r24,date_m
 4604 14d0 8D30      		cpi r24,lo8(13)
 4605 14d2 00F0      		brlo .L263
 336:iv.c          ****     date_y++;
 4607               	.LM658:
 4608 14d4 8091 0000 		lds r24,date_y
 4609 14d8 8F5F      		subi r24,lo8(-(1))
 4610 14da 8093 0000 		sts date_y,r24
 337:iv.c          ****     date_m = 1;
 4612               	.LM659:
 4613 14de 81E0      		ldi r24,lo8(1)
 4614 14e0 8093 0000 		sts date_m,r24
 338:iv.c          ****     eeprom_write_byte((uint8_t *)EE_YEAR, date_y);
 4616               	.LM660:
 4617 14e4 6091 0000 		lds r22,date_y
 4618 14e8 81E0      		ldi r24,lo8(1)
 4619 14ea 90E0      		ldi r25,hi8(1)
 4620 14ec 0E94 0000 		call __eewr_byte_m328p
 4621               	.L263:
 342:iv.c          ****   if (sleepmode)
 4623               	.LM661:
 4624 14f0 8091 0000 		lds r24,sleepmode
 4625 14f4 8823      		tst r24
 4626 14f6 01F0      		breq .+2
 4627 14f8 00C0      		rjmp .L255
 346:iv.c          ****   if (displaymode == SHOW_TIME) {
 4629               	.LM662:
 4630 14fa 8091 0000 		lds r24,displaymode
 4631 14fe 8823      		tst r24
 4632 1500 01F4      		brne .L265
 347:iv.c          ****     if (timeunknown && (time_s % 2)) {
 4634               	.LM663:
 4635 1502 8091 0000 		lds r24,timeunknown
 4636 1506 8823      		tst r24
 4637 1508 01F4      		brne .+2
 4638 150a 00C0      		rjmp .L266
 347:iv.c          ****     if (timeunknown && (time_s % 2)) {
 4640               	.LM664:
 4641 150c 8091 0000 		lds r24,time_s
 4642 1510 80FF      		sbrs r24,0
 4643 1512 00C0      		rjmp .L266
 348:iv.c          ****       display_str("        ");
 4645               	.LM665:
 4646 1514 80E0      		ldi r24,lo8(.LC25)
 4647 1516 90E0      		ldi r25,hi8(.LC25)
 4648 1518 0E94 0000 		call _Z11display_strPKc
 4649               	.L272:
 352:iv.c          ****     if (alarm_on)
 4651               	.LM666:
 4652 151c 8091 0000 		lds r24,alarm_on
 4653 1520 2091 0000 		lds r18,display
 4654 1524 8823      		tst r24
 4655 1526 01F0      		breq .L267
 353:iv.c          ****       display[0] |= 0x2;
 4657               	.LM667:
 4658 1528 2260      		ori r18,lo8(2)
 4659 152a 00C0      		rjmp .L273
 4660               	.L267:
 355:iv.c          ****       display[0] &= ~0x2;
 4662               	.LM668:
 4663 152c 2D7F      		andi r18,lo8(-3)
 4664               	.L273:
 4665 152e 2093 0000 		sts display,r18
 4666               	.L265:
 4667               	.LBB169:
 358:iv.c          ****   if (alarm_on && (alarm_h == time_h) && (alarm_m == time_m) && (time_s == 0)) {
 4669               	.LM669:
 4670 1532 8091 0000 		lds r24,alarm_on
 4671 1536 8823      		tst r24
 4672 1538 01F0      		breq .L268
 358:iv.c          ****   if (alarm_on && (alarm_h == time_h) && (alarm_m == time_m) && (time_s == 0)) {
 4674               	.LM670:
 4675 153a 9091 0000 		lds r25,alarm_h
 4676 153e 8091 0000 		lds r24,time_h
 4677 1542 9817      		cp r25,r24
 4678 1544 01F4      		brne .L268
 358:iv.c          ****   if (alarm_on && (alarm_h == time_h) && (alarm_m == time_m) && (time_s == 0)) {
 4680               	.LM671:
 4681 1546 9091 0000 		lds r25,alarm_m
 4682 154a 8091 0000 		lds r24,time_m
 4683 154e 9817      		cp r25,r24
 4684 1550 01F4      		brne .L268
 358:iv.c          ****   if (alarm_on && (alarm_h == time_h) && (alarm_m == time_m) && (time_s == 0)) {
 4686               	.LM672:
 4687 1552 8091 0000 		lds r24,time_s
 4688 1556 8823      		tst r24
 4689 1558 01F4      		brne .L268
 4690               	.LBB170:
 4691               	.LBB171:
 359:iv.c          ****     DEBUGP("alarm on!");
 4693               	.LM673:
 4694 155a 80E0      		ldi r24,lo8(_ZZ10__vector_9E3__c)
 4695 155c 90E0      		ldi r25,hi8(_ZZ10__vector_9E3__c)
 4696 155e 61E0      		ldi r22,lo8(1)
 4697 1560 0E94 0000 		call _Z13ROM_putstringPKch
 4698               	.LBE171:
 360:iv.c          ****     alarming = 1;
 4700               	.LM674:
 4701 1564 81E0      		ldi r24,lo8(1)
 4702 1566 8093 0000 		sts alarming,r24
 361:iv.c          ****     snoozetimer = 0;
 4704               	.LM675:
 4705 156a 1092 0000 		sts snoozetimer+1,__zero_reg__
 4706 156e 1092 0000 		sts snoozetimer,__zero_reg__
 4707               	.L268:
 4708               	.LBE170:
 4709               	.LBE169:
 364:iv.c          ****   if (timeoutcounter)
 4711               	.LM676:
 4712 1572 8091 0000 		lds r24,timeoutcounter
 4713 1576 8823      		tst r24
 4714 1578 01F0      		breq .L269
 365:iv.c          ****     timeoutcounter--;
 4716               	.LM677:
 4717 157a 8091 0000 		lds r24,timeoutcounter
 4718 157e 8150      		subi r24,lo8(-(-1))
 4719 1580 8093 0000 		sts timeoutcounter,r24
 4720               	.L269:
 366:iv.c          ****   if (buttonholdcounter)
 4722               	.LM678:
 4723 1584 8091 0000 		lds r24,buttonholdcounter
 4724 1588 8823      		tst r24
 4725 158a 01F0      		breq .L270
 367:iv.c          ****     buttonholdcounter--;
 4727               	.LM679:
 4728 158c 8091 0000 		lds r24,buttonholdcounter
 4729 1590 8150      		subi r24,lo8(-(-1))
 4730 1592 8093 0000 		sts buttonholdcounter,r24
 4731               	.L270:
 368:iv.c          ****   if (snoozetimer) {
 4733               	.LM680:
 4734 1596 8091 0000 		lds r24,snoozetimer
 4735 159a 9091 0000 		lds r25,snoozetimer+1
 4736 159e 0097      		sbiw r24,0
 4737 15a0 01F0      		breq .L255
 369:iv.c          ****     snoozetimer--;
 4739               	.LM681:
 4740 15a2 0197      		sbiw r24,1
 4741 15a4 9093 0000 		sts snoozetimer+1,r25
 4742 15a8 8093 0000 		sts snoozetimer,r24
 4743 15ac 2091 0000 		lds r18,display
 370:iv.c          ****     if (snoozetimer % 2) 
 4745               	.LM682:
 4746 15b0 80FF      		sbrs r24,0
 4747 15b2 00C0      		rjmp .L271
 371:iv.c          ****       display[0] |= 0x2;
 4749               	.LM683:
 4750 15b4 2260      		ori r18,lo8(2)
 4751 15b6 00C0      		rjmp .L274
 4752               	.L271:
 373:iv.c          ****       display[0] &= ~0x2;
 4754               	.LM684:
 4755 15b8 2D7F      		andi r18,lo8(-3)
 4756               	.L274:
 4757 15ba 2093 0000 		sts display,r18
 4758 15be 00C0      		rjmp .L255
 4759               	.L266:
 350:iv.c          ****       display_time(time_h, time_m, time_s);
 4761               	.LM685:
 4762 15c0 8091 0000 		lds r24,time_h
 4763 15c4 6091 0000 		lds r22,time_m
 4764 15c8 4091 0000 		lds r20,time_s
 4765 15cc 0E94 0000 		call _Z12display_timehhh
 4766 15d0 00C0      		rjmp .L272
 4767               	.L255:
 4768               	/* epilogue start */
 4769               	.LBE168:
 375:iv.c          **** }
 4771               	.LM686:
 4772 15d2 FF91      		pop r31
 4773 15d4 EF91      		pop r30
 4774 15d6 BF91      		pop r27
 4775 15d8 AF91      		pop r26
 4776 15da 9F91      		pop r25
 4777 15dc 8F91      		pop r24
 4778 15de 7F91      		pop r23
 4779 15e0 6F91      		pop r22
 4780 15e2 5F91      		pop r21
 4781 15e4 4F91      		pop r20
 4782 15e6 3F91      		pop r19
 4783 15e8 2F91      		pop r18
 4784 15ea 0F90      		pop r0
 4785 15ec 0FBE      		out __SREG__,r0
 4786 15ee 0F90      		pop r0
 4787 15f0 1F90      		pop __zero_reg__
 4788 15f2 1895      		reti
 4790               	.Lscope25:
 4792               		.stabd	78,0,0
 4793               		.data
 4794               	.LC26:
 4795 00b4 736E 6F6F 		.string	"snoozing"
 4795      7A69 6E67 
 4795      00
 4796               		.text
 4798               	.global	_Z9setsnoozev
 4800               	_Z9setsnoozev:
 4801               		.stabd	46,0,0
 105:iv.c          **** void setsnooze(void) {
 4803               	.LM687:
 4804               	.LFBB26:
 4805               	/* prologue: function */
 4806               	/* frame size = 0 */
 4807               	/* stack size = 0 */
 4808               	.L__stack_usage = 0
 4809               	.LBB172:
 108:iv.c          ****   snoozetimer = MAXSNOOZE;
 4811               	.LM688:
 4812 15f4 88E5      		ldi r24,lo8(600)
 4813 15f6 92E0      		ldi r25,hi8(600)
 4814 15f8 9093 0000 		sts snoozetimer+1,r25
 4815 15fc 8093 0000 		sts snoozetimer,r24
 4816               	.LBB173:
 109:iv.c          ****   DEBUGP("snooze");
 4818               	.LM689:
 4819 1600 80E0      		ldi r24,lo8(_ZZ9setsnoozevE3__c)
 4820 1602 90E0      		ldi r25,hi8(_ZZ9setsnoozevE3__c)
 4821 1604 61E0      		ldi r22,lo8(1)
 4822 1606 0E94 0000 		call _Z13ROM_putstringPKch
 4823               	.LBE173:
 110:iv.c          ****   display_str("snoozing");
 4825               	.LM690:
 4826 160a 80E0      		ldi r24,lo8(.LC26)
 4827 160c 90E0      		ldi r25,hi8(.LC26)
 4828 160e 0E94 0000 		call _Z11display_strPKc
 111:iv.c          ****   displaymode = SHOW_SNOOZE;
 4830               	.LM691:
 4831 1612 89E0      		ldi r24,lo8(9)
 4832 1614 8093 0000 		sts displaymode,r24
 112:iv.c          ****   delayms(1000);
 4834               	.LM692:
 4835 1618 88EE      		ldi r24,lo8(1000)
 4836 161a 93E0      		ldi r25,hi8(1000)
 4837 161c 0E94 0000 		call _Z7delaymsj
 113:iv.c          ****   displaymode = SHOW_TIME;
 4839               	.LM693:
 4840 1620 1092 0000 		sts displaymode,__zero_reg__
 4841               	/* epilogue start */
 4842               	.LBE172:
 114:iv.c          **** }
 4844               	.LM694:
 4845 1624 0895      		ret
 4847               	.Lscope26:
 4849               		.stabd	78,0,0
 4851               	.global	__vector_3
 4853               	__vector_3:
 4854               		.stabd	46,0,0
 250:iv.c          **** ISR(PCINT0_vect) {
 4856               	.LM695:
 4857               	.LFBB27:
 4858 1626 1F92      		push __zero_reg__
 4859 1628 0F92      		push r0
 4860 162a 0FB6      		in r0,__SREG__
 4861 162c 0F92      		push r0
 4862 162e 1124      		clr __zero_reg__
 4863 1630 2F93      		push r18
 4864 1632 3F93      		push r19
 4865 1634 4F93      		push r20
 4866 1636 5F93      		push r21
 4867 1638 6F93      		push r22
 4868 163a 7F93      		push r23
 4869 163c 8F93      		push r24
 4870 163e 9F93      		push r25
 4871 1640 AF93      		push r26
 4872 1642 BF93      		push r27
 4873 1644 EF93      		push r30
 4874 1646 FF93      		push r31
 4875               	/* prologue: Signal */
 4876               	/* frame size = 0 */
 4877               	/* stack size = 15 */
 4878               	.L__stack_usage = 15
 4879               	.LBB174:
 251:iv.c          ****   PCICR = 0;
 4881               	.LM696:
 4882 1648 1092 6800 		sts 104,__zero_reg__
 252:iv.c          ****   sei();
 4884               	.LM697:
 4885               	/* #APP */
 4886               	 ;  252 "iv.c" 1
 4887 164c 7894      		sei
 4888               	 ;  0 "" 2
 4889               	/* #NOAPP */
 4890               	.LBB175:
 253:iv.c          ****   if (! (PINB & _BV(BUTTON2))) {
 4892               	.LM698:
 4893 164e 83B1      		in r24,35-32
 4894 1650 80FD      		sbrc r24,0
 4895 1652 00C0      		rjmp .L277
 4896               	.LBB176:
 255:iv.c          ****     if (! (last_buttonstate & 0x2)) { // was not pressed before
 4898               	.LM699:
 4899 1654 8091 0000 		lds r24,last_buttonstate
 4900 1658 81FD      		sbrc r24,1
 4901 165a 00C0      		rjmp .L278
 4902               	.LBB177:
 256:iv.c          ****       delayms(10);                    // debounce
 4904               	.LM700:
 4905 165c 8AE0      		ldi r24,lo8(10)
 4906 165e 90E0      		ldi r25,hi8(10)
 4907 1660 0E94 0000 		call _Z7delaymsj
 257:iv.c          ****       if (PINB & _BV(BUTTON2)) {      // filter out bounces
 4909               	.LM701:
 4910 1664 1899      		sbic 35-32,0
 4911 1666 00C0      		rjmp .L278
 4912               	.L279:
 261:iv.c          ****       tick();                         // make a noise
 4914               	.LM702:
 4915 1668 0E94 0000 		call _Z4tickv
 263:iv.c          ****       if (alarming) {
 4917               	.LM703:
 4918 166c 8091 0000 		lds r24,alarming
 4919 1670 8823      		tst r24
 4920 1672 01F0      		breq .L281
 264:iv.c          **** 	setsnooze(); 	// turn on snooze
 4922               	.LM704:
 4923 1674 0E94 0000 		call _Z9setsnoozev
 4924 1678 00C0      		rjmp .L278
 4925               	.L281:
 268:iv.c          ****       last_buttonstate |= 0x2;
 4927               	.LM705:
 4928 167a 8091 0000 		lds r24,last_buttonstate
 4929 167e 8260      		ori r24,lo8(2)
 4930 1680 8093 0000 		sts last_buttonstate,r24
 269:iv.c          ****       just_pressed |= 0x2;
 4932               	.LM706:
 4933 1684 8091 0000 		lds r24,just_pressed
 4934 1688 8260      		ori r24,lo8(2)
 4935 168a 8093 0000 		sts just_pressed,r24
 4936               	.LBB178:
 270:iv.c          ****       DEBUGP("b2");
 4938               	.LM707:
 4939 168e 80E0      		ldi r24,lo8(_ZZ10__vector_3E3__c)
 4940 1690 90E0      		ldi r25,hi8(_ZZ10__vector_3E3__c)
 4941 1692 61E0      		ldi r22,lo8(1)
 4942 1694 0E94 0000 		call _Z13ROM_putstringPKch
 4943 1698 00C0      		rjmp .L278
 4944               	.L277:
 4945               	.LBE178:
 4946               	.LBE177:
 4947               	.LBE176:
 273:iv.c          ****     last_buttonstate &= ~0x2;
 4949               	.LM708:
 4950 169a 8091 0000 		lds r24,last_buttonstate
 4951 169e 8D7F      		andi r24,lo8(-3)
 4952 16a0 8093 0000 		sts last_buttonstate,r24
 4953               	.L278:
 4954               	.LBE175:
 275:iv.c          ****   PCICR = _BV(PCIE0) | _BV(PCIE2);
 4956               	.LM709:
 4957 16a4 85E0      		ldi r24,lo8(5)
 4958 16a6 8093 6800 		sts 104,r24
 4959               	/* epilogue start */
 4960               	.LBE174:
 276:iv.c          **** }
 4962               	.LM710:
 4963 16aa FF91      		pop r31
 4964 16ac EF91      		pop r30
 4965 16ae BF91      		pop r27
 4966 16b0 AF91      		pop r26
 4967 16b2 9F91      		pop r25
 4968 16b4 8F91      		pop r24
 4969 16b6 7F91      		pop r23
 4970 16b8 6F91      		pop r22
 4971 16ba 5F91      		pop r21
 4972 16bc 4F91      		pop r20
 4973 16be 3F91      		pop r19
 4974 16c0 2F91      		pop r18
 4975 16c2 0F90      		pop r0
 4976 16c4 0FBE      		out __SREG__,r0
 4977 16c6 0F90      		pop r0
 4978 16c8 1F90      		pop __zero_reg__
 4979 16ca 1895      		reti
 4981               	.Lscope27:
 4983               		.stabd	78,0,0
 4985               	.global	__vector_5
 4987               	__vector_5:
 4988               		.stabd	46,0,0
 184:iv.c          **** ISR(PCINT2_vect) {
 4990               	.LM711:
 4991               	.LFBB28:
 4992 16cc 1F92      		push __zero_reg__
 4993 16ce 0F92      		push r0
 4994 16d0 0FB6      		in r0,__SREG__
 4995 16d2 0F92      		push r0
 4996 16d4 1124      		clr __zero_reg__
 4997 16d6 2F93      		push r18
 4998 16d8 3F93      		push r19
 4999 16da 4F93      		push r20
 5000 16dc 5F93      		push r21
 5001 16de 6F93      		push r22
 5002 16e0 7F93      		push r23
 5003 16e2 8F93      		push r24
 5004 16e4 9F93      		push r25
 5005 16e6 AF93      		push r26
 5006 16e8 BF93      		push r27
 5007 16ea EF93      		push r30
 5008 16ec FF93      		push r31
 5009               	/* prologue: Signal */
 5010               	/* frame size = 0 */
 5011               	/* stack size = 15 */
 5012               	.L__stack_usage = 15
 5013               	.LBB179:
 185:iv.c          ****   PCICR = 0;
 5015               	.LM712:
 5016 16ee 1092 6800 		sts 104,__zero_reg__
 187:iv.c          ****   sei();
 5018               	.LM713:
 5019               	/* #APP */
 5020               	 ;  187 "iv.c" 1
 5021 16f2 7894      		sei
 5022               	 ;  0 "" 2
 5023               	/* #NOAPP */
 5024               	.LBB180:
 189:iv.c          ****   if (! (PIND & _BV(BUTTON1))) {
 5026               	.LM714:
 5027 16f4 4D99      		sbic 41-32,5
 5028 16f6 00C0      		rjmp .L283
 5029               	.LBB181:
 191:iv.c          ****     if (! (last_buttonstate & 0x1)) { // was not pressed before
 5031               	.LM715:
 5032 16f8 8091 0000 		lds r24,last_buttonstate
 5033 16fc 80FD      		sbrc r24,0
 5034 16fe 00C0      		rjmp .L284
 5035               	.LBB182:
 192:iv.c          ****       delayms(10);                    // debounce
 5037               	.LM716:
 5038 1700 8AE0      		ldi r24,lo8(10)
 5039 1702 90E0      		ldi r25,hi8(10)
 5040 1704 0E94 0000 		call _Z7delaymsj
 193:iv.c          ****       if (PIND & _BV(BUTTON1)) {      // filter out bounce
 5042               	.LM717:
 5043 1708 4D99      		sbic 41-32,5
 5044 170a 00C0      		rjmp .L289
 5045               	.L285:
 197:iv.c          ****       tick();                         // make a noise
 5047               	.LM718:
 5048 170c 0E94 0000 		call _Z4tickv
 199:iv.c          ****       if (alarming) {
 5050               	.LM719:
 5051 1710 8091 0000 		lds r24,alarming
 5052 1714 8823      		tst r24
 5053 1716 01F4      		brne .L295
 5054               	.L287:
 205:iv.c          ****       last_buttonstate |= 0x1;
 5056               	.LM720:
 5057 1718 8091 0000 		lds r24,last_buttonstate
 5058 171c 8160      		ori r24,lo8(1)
 5059 171e 8093 0000 		sts last_buttonstate,r24
 206:iv.c          ****       just_pressed |= 0x1;
 5061               	.LM721:
 5062 1722 8091 0000 		lds r24,just_pressed
 5063 1726 8160      		ori r24,lo8(1)
 5064 1728 8093 0000 		sts just_pressed,r24
 5065               	.LBB183:
 207:iv.c          ****       DEBUGP("b1");
 5067               	.LM722:
 5068 172c 80E0      		ldi r24,lo8(_ZZ10__vector_5E3__c)
 5069 172e 90E0      		ldi r25,hi8(_ZZ10__vector_5E3__c)
 5070 1730 61E0      		ldi r22,lo8(1)
 5071 1732 0E94 0000 		call _Z13ROM_putstringPKch
 5072 1736 00C0      		rjmp .L284
 5073               	.L283:
 5074               	.LBE183:
 5075               	.LBE182:
 5076               	.LBE181:
 210:iv.c          ****     last_buttonstate &= ~0x1;
 5078               	.LM723:
 5079 1738 8091 0000 		lds r24,last_buttonstate
 5080 173c 8E7F      		andi r24,lo8(-2)
 5081 173e 8093 0000 		sts last_buttonstate,r24
 5082               	.L284:
 5083               	.LBE180:
 5084               	.LBB184:
 213:iv.c          ****   if (! (PIND & _BV(BUTTON3))) {
 5086               	.LM724:
 5087 1742 4C99      		sbic 41-32,4
 5088 1744 00C0      		rjmp .L288
 5089               	.LBB185:
 215:iv.c          ****     if (! (last_buttonstate & 0x4)) { // was not pressed before
 5091               	.LM725:
 5092 1746 8091 0000 		lds r24,last_buttonstate
 5093 174a 82FD      		sbrc r24,2
 5094 174c 00C0      		rjmp .L289
 5095               	.LBB186:
 216:iv.c          ****       delayms(10);                    // debounce
 5097               	.LM726:
 5098 174e 8AE0      		ldi r24,lo8(10)
 5099 1750 90E0      		ldi r25,hi8(10)
 5100 1752 0E94 0000 		call _Z7delaymsj
 217:iv.c          ****       if (PIND & _BV(BUTTON3)) {      // filter out bounces
 5102               	.LM727:
 5103 1756 4C99      		sbic 41-32,4
 5104 1758 00C0      		rjmp .L289
 5105               	.L290:
 221:iv.c          ****       buttonholdcounter = 2;          // see if we're press-and-holding
 5107               	.LM728:
 5108 175a 82E0      		ldi r24,lo8(2)
 5109 175c 8093 0000 		sts buttonholdcounter,r24
 222:iv.c          ****       while (buttonholdcounter) {
 5111               	.LM729:
 5112 1760 00C0      		rjmp .L291
 5113               	.L293:
 5114               	.LBB187:
 223:iv.c          **** 	if (PIND & _BV(BUTTON3)) {        // released
 5116               	.LM730:
 5117 1762 4C9B      		sbis 41-32,4
 5118 1764 00C0      		rjmp .L291
 5119               	.LBB188:
 224:iv.c          **** 	  tick();                         // make a noise
 5121               	.LM731:
 5122 1766 0E94 0000 		call _Z4tickv
 225:iv.c          **** 	  last_buttonstate &= ~0x4;
 5124               	.LM732:
 5125 176a 8091 0000 		lds r24,last_buttonstate
 5126 176e 8B7F      		andi r24,lo8(-5)
 5127 1770 8093 0000 		sts last_buttonstate,r24
 227:iv.c          **** 	  if (alarming) {
 5129               	.LM733:
 5130 1774 8091 0000 		lds r24,alarming
 5131 1778 8823      		tst r24
 5132 177a 01F0      		breq .L292
 5133               	.L295:
 229:iv.c          **** 	    setsnooze();
 5135               	.LM734:
 5136 177c 0E94 0000 		call _Z9setsnoozev
 5137 1780 00C0      		rjmp .L289
 5138               	.L292:
 5139               	.LBB189:
 233:iv.c          **** 	  DEBUGP("b3");
 5141               	.LM735:
 5142 1782 80E0      		ldi r24,lo8(_ZZ10__vector_5E3__c_0)
 5143 1784 90E0      		ldi r25,hi8(_ZZ10__vector_5E3__c_0)
 5144 1786 61E0      		ldi r22,lo8(1)
 5145 1788 0E94 0000 		call _Z13ROM_putstringPKch
 5146               	.LBE189:
 234:iv.c          **** 	  just_pressed |= 0x4;
 5148               	.LM736:
 5149 178c 8091 0000 		lds r24,just_pressed
 5150 1790 8460      		ori r24,lo8(4)
 5151 1792 8093 0000 		sts just_pressed,r24
 5152 1796 00C0      		rjmp .L289
 5153               	.L291:
 5154               	.LBE188:
 5155               	.LBE187:
 222:iv.c          ****       while (buttonholdcounter) {
 5157               	.LM737:
 5158 1798 8091 0000 		lds r24,buttonholdcounter
 5159 179c 8823      		tst r24
 5160 179e 01F4      		brne .L293
 239:iv.c          ****       last_buttonstate |= 0x4;
 5162               	.LM738:
 5163 17a0 8091 0000 		lds r24,last_buttonstate
 5164 17a4 8460      		ori r24,lo8(4)
 5165 17a6 8093 0000 		sts last_buttonstate,r24
 240:iv.c          ****       pressed |= 0x4;                 // held down
 5167               	.LM739:
 5168 17aa 8091 0000 		lds r24,pressed
 5169 17ae 8460      		ori r24,lo8(4)
 5170 17b0 8093 0000 		sts pressed,r24
 5171 17b4 00C0      		rjmp .L289
 5172               	.L288:
 5173               	.LBE186:
 5174               	.LBE185:
 243:iv.c          ****     pressed = 0;                      // button released
 5176               	.LM740:
 5177 17b6 1092 0000 		sts pressed,__zero_reg__
 244:iv.c          ****     last_buttonstate &= ~0x4;
 5179               	.LM741:
 5180 17ba 8091 0000 		lds r24,last_buttonstate
 5181 17be 8B7F      		andi r24,lo8(-5)
 5182 17c0 8093 0000 		sts last_buttonstate,r24
 5183               	.L289:
 5184               	.LBE184:
 246:iv.c          ****   PCICR = _BV(PCIE0) | _BV(PCIE2);
 5186               	.LM742:
 5187 17c4 85E0      		ldi r24,lo8(5)
 5188 17c6 8093 6800 		sts 104,r24
 5189               	/* epilogue start */
 5190               	.LBE179:
 247:iv.c          **** }
 5192               	.LM743:
 5193 17ca FF91      		pop r31
 5194 17cc EF91      		pop r30
 5195 17ce BF91      		pop r27
 5196 17d0 AF91      		pop r26
 5197 17d2 9F91      		pop r25
 5198 17d4 8F91      		pop r24
 5199 17d6 7F91      		pop r23
 5200 17d8 6F91      		pop r22
 5201 17da 5F91      		pop r21
 5202 17dc 4F91      		pop r20
 5203 17de 3F91      		pop r19
 5204 17e0 2F91      		pop r18
 5205 17e2 0F90      		pop r0
 5206 17e4 0FBE      		out __SREG__,r0
 5207 17e6 0F90      		pop r0
 5208 17e8 1F90      		pop __zero_reg__
 5209 17ea 1895      		reti
 5211               	.Lscope28:
 5213               		.stabd	78,0,0
 5214               		.data
 5215               	.LC27:
 5216 00bd 7365 7420 		.string	"set alarm"
 5216      616C 6172 
 5216      6D00 
 5217               	.LC28:
 5218 00c7 7365 7420 		.string	"set time"
 5218      7469 6D65 
 5218      00
 5219               	.LC29:
 5220 00d0 7365 7420 		.string	"set date"
 5220      6461 7465 
 5220      00
 5221               	.LC30:
 5222 00d9 7365 7420 		.string	"set brit"
 5222      6272 6974 
 5222      00
 5223               	.LC31:
 5224 00e2 7365 7420 		.string	"set vol "
 5224      766F 6C20 
 5224      00
 5225               	.LC32:
 5226 00eb 7365 7420 		.string	"set regn"
 5226      7265 676E 
 5226      00
 5227               		.text
 5229               	.global	main
 5231               	main:
 5232               		.stabd	46,0,0
 526:iv.c          **** int main(void) {
 5234               	.LM744:
 5235               	.LFBB29:
 5236 17ec BF92      		push r11
 5237 17ee CF92      		push r12
 5238 17f0 DF92      		push r13
 5239 17f2 EF92      		push r14
 5240 17f4 FF92      		push r15
 5241 17f6 0F93      		push r16
 5242 17f8 1F93      		push r17
 5243               	/* prologue: function */
 5244               	/* frame size = 0 */
 5245               	/* stack size = 7 */
 5246               	.L__stack_usage = 7
 5247               	.LBB190:
 531:iv.c          ****   TCCR0B = 0;
 5249               	.LM745:
 5250 17fa 15BC      		out 69-32,__zero_reg__
 532:iv.c          ****   BOOST_DDR |= _BV(BOOST);
 5252               	.LM746:
 5253 17fc 569A      		sbi 42-32,6
 533:iv.c          ****   BOOST_PORT &= ~_BV(BOOST); // pull boost fet low
 5255               	.LM747:
 5256 17fe 5E98      		cbi 43-32,6
 536:iv.c          ****   mcustate = MCUSR;
 5258               	.LM748:
 5259 1800 84B7      		in r24,84-32
 537:iv.c          ****   MCUSR = 0;
 5261               	.LM749:
 5262 1802 14BE      		out 84-32,__zero_reg__
 539:iv.c          ****   uart_putw_hex(mcustate);
 5264               	.LM750:
 5265 1804 90E0      		ldi r25,lo8(0)
 5266 1806 0E94 0000 		call _Z13uart_putw_hexj
 541:iv.c          ****   wdt_disable();
 5268               	.LM751:
 5269 180a 88E1      		ldi r24,lo8(24)
 5270               	/* #APP */
 5271               	 ;  541 "iv.c" 1
 5272 180c 0FB6      		in __tmp_reg__, __SREG__
 5273 180e F894      		cli
 5274 1810 8093 6000 		sts 96, r24
 5275 1814 1092 6000 		sts 96, __zero_reg__
 5276 1818 0FBE      		out __SREG__,__tmp_reg__
 5277               		
 5278               	 ;  0 "" 2
 545:iv.c          ****   wdt_enable(WDTO_2S);
 5280               	.LM752:
 5281               	/* #NOAPP */
 5282 181a 2FE0      		ldi r18,lo8(15)
 5283 181c 88E1      		ldi r24,lo8(24)
 5284 181e 90E0      		ldi r25,hi8(24)
 5285               	/* #APP */
 5286               	 ;  545 "iv.c" 1
 5287 1820 0FB6      		in __tmp_reg__,__SREG__
 5288 1822 F894      		cli
 5289 1824 A895      		wdr
 5290 1826 8093 6000 		sts 96,r24
 5291 182a 0FBE      		out __SREG__,__tmp_reg__
 5292 182c 2093 6000 		sts 96,r18
 5293               		
 5294               	 ;  0 "" 2
 5295               	/* #NOAPP */
 5296               	.LBB191:
 5297               	.LBB192:
 118:iv.c          ****   wdt_reset();
 5299               	.LM753:
 5300               	/* #APP */
 5301               	 ;  118 "iv.c" 1
 5302 1830 A895      		wdr
 5303               	 ;  0 "" 2
 5304               	/* #NOAPP */
 5305               	.LBE192:
 5306               	.LBE191:
 550:iv.c          ****   timeunknown = 1;
 5308               	.LM754:
 5309 1832 11E0      		ldi r17,lo8(1)
 5310 1834 1093 0000 		sts timeunknown,r17
 553:iv.c          ****   restored = 0;
 5312               	.LM755:
 5313 1838 1092 0000 		sts restored,__zero_reg__
 556:iv.c          ****   uart_init(BRRL_192);
 5315               	.LM756:
 5316 183c 8AE1      		ldi r24,lo8(26)
 5317 183e 90E0      		ldi r25,hi8(26)
 5318 1840 0E94 0000 		call _Z9uart_initj
 5319               	.LBB193:
 558:iv.c          ****   DEBUGP("!");
 5321               	.LM757:
 5322 1844 80E0      		ldi r24,lo8(_ZZ4mainE3__c)
 5323 1846 90E0      		ldi r25,hi8(_ZZ4mainE3__c)
 5324 1848 61E0      		ldi r22,lo8(1)
 5325 184a 0E94 0000 		call _Z13ROM_putstringPKch
 5326               	.LBE193:
 562:iv.c          ****   ACSR = _BV(ACBG) | _BV(ACIE); // use bandgap, intr. on toggle!
 5328               	.LM758:
 5329 184e 88E4      		ldi r24,lo8(72)
 5330 1850 80BF      		out 80-32,r24
 5331               	.LBB194:
 5332               	.LBB195:
 5334               	.Ltext7:
 5336               	.LM759:
 5337 1852 8FEC      		 ldi r24,lo8(1999)
 5338 1854 97E0      	    ldi r25,hi8(1999)
 5339 1856 0197      	    1:sbiw r24,1
 5340 1858 01F4      	    brne 1b
 5341 185a 00C0      		rjmp .
 5342 185c 0000      		nop
 5343               	.LBE195:
 5344               	.LBE194:
 5345               	.LBB196:
 5347               	.Ltext8:
 565:iv.c          ****   if (ACSR & _BV(ACO)) {
 5349               	.LM760:
 5350 185e 00B6      		in __tmp_reg__,80-32
 5351 1860 05FE      		sbrs __tmp_reg__,5
 5352 1862 00C0      		rjmp .L297
 5353               	.LBB197:
 567:iv.c          ****     ACSR |= _BV(ACI);
 5355               	.LM761:
 5356 1864 80B7      		in r24,80-32
 5357 1866 8061      		ori r24,lo8(16)
 5358 1868 80BF      		out 80-32,r24
 5359               	.LBB198:
 570:iv.c          ****     DEBUGP("clock init");
 5361               	.LM762:
 5362 186a 80E0      		ldi r24,lo8(_ZZ4mainE3__c_0)
 5363 186c 90E0      		ldi r25,hi8(_ZZ4mainE3__c_0)
 5364 186e 61E0      		ldi r22,lo8(1)
 5365 1870 0E94 0000 		call _Z13ROM_putstringPKch
 5366               	.LBE198:
 571:iv.c          ****     clock_init();  
 5368               	.LM763:
 5369 1874 0E94 0000 		call _Z10clock_initv
 5370 1878 00C0      		rjmp .L298
 5371               	.L297:
 5372               	.LBE197:
 5373               	.LBB199:
 577:iv.c          ****     initbuttons();
 5375               	.LM764:
 5376 187a 0E94 0000 		call _Z11initbuttonsv
 579:iv.c          ****     VFDSWITCH_PORT &= ~_BV(VFDSWITCH);
 5378               	.LM765:
 5379 187e 5B98      		cbi 43-32,3
 5380               	.LBB200:
 581:iv.c          ****     DEBUGP("turning on buttons");
 5382               	.LM766:
 5383 1880 80E0      		ldi r24,lo8(_ZZ4mainE3__c_1)
 5384 1882 90E0      		ldi r25,hi8(_ZZ4mainE3__c_1)
 5385 1884 61E0      		ldi r22,lo8(1)
 5386 1886 0E94 0000 		call _Z13ROM_putstringPKch
 5387               	.LBE200:
 5388               	.LBB201:
 583:iv.c          ****     DEBUGP("turning on alarmsw");
 5390               	.LM767:
 5391 188a 80E0      		ldi r24,lo8(_ZZ4mainE3__c_2)
 5392 188c 90E0      		ldi r25,hi8(_ZZ4mainE3__c_2)
 5393 188e 61E0      		ldi r22,lo8(1)
 5394 1890 0E94 0000 		call _Z13ROM_putstringPKch
 5395               	.LBE201:
 585:iv.c          ****     EICRA = _BV(ISC00);
 5397               	.LM768:
 5398 1894 1093 6900 		sts 105,r17
 586:iv.c          ****     EIMSK = _BV(INT0);
 5400               	.LM769:
 5401 1898 1DBB      		out 61-32,r17
 588:iv.c          ****     displaymode = SHOW_TIME;
 5403               	.LM770:
 5404 189a 1092 0000 		sts displaymode,__zero_reg__
 5405               	.LBB202:
 589:iv.c          ****     DEBUGP("vfd init");
 5407               	.LM771:
 5408 189e 80E0      		ldi r24,lo8(_ZZ4mainE3__c_3)
 5409 18a0 90E0      		ldi r25,hi8(_ZZ4mainE3__c_3)
 5410 18a2 61E0      		ldi r22,lo8(1)
 5411 18a4 0E94 0000 		call _Z13ROM_putstringPKch
 5412               	.LBE202:
 5413               	.LBB203:
 5414               	.LBB204:
 5416               	.LM772:
 5417 18a8 81E5      		ldi r24,lo8(81)
 5418 18aa 8CBD      		out 76-32,r24
 5419               	.LBE204:
 5420               	.LBE203:
 5421               	.LBB205:
 592:iv.c          ****     DEBUGP("boost init");
 5423               	.LM773:
 5424 18ac 80E0      		ldi r24,lo8(_ZZ4mainE3__c_4)
 5425 18ae 90E0      		ldi r25,hi8(_ZZ4mainE3__c_4)
 5426 18b0 61E0      		ldi r22,lo8(1)
 5427 18b2 0E94 0000 		call _Z13ROM_putstringPKch
 5428               	.LBE205:
 593:iv.c          ****     boost_init(eeprom_read_byte((uint8_t *)EE_BRIGHT));
 5430               	.LM774:
 5431 18b6 89E0      		ldi r24,lo8(9)
 5432 18b8 90E0      		ldi r25,hi8(9)
 5433 18ba 0E94 0000 		call __eerd_byte_m328p
 5434 18be 0E94 0000 		call _Z10boost_inith
 594:iv.c          ****     sei();
 5436               	.LM775:
 5437               	/* #APP */
 5438               	 ;  594 "iv.c" 1
 5439 18c2 7894      		sei
 5440               	 ;  0 "" 2
 596:iv.c          ****     region = eeprom_read_byte((uint8_t *)EE_REGION);
 5442               	.LM776:
 5443               	/* #NOAPP */
 5444 18c4 8BE0      		ldi r24,lo8(11)
 5445 18c6 90E0      		ldi r25,hi8(11)
 5446 18c8 0E94 0000 		call __eerd_byte_m328p
 5447 18cc 8093 0000 		sts region,r24
 5448               	.LBB206:
 598:iv.c          ****     DEBUGP("speaker init");
 5450               	.LM777:
 5451 18d0 80E0      		ldi r24,lo8(_ZZ4mainE3__c_5)
 5452 18d2 90E0      		ldi r25,hi8(_ZZ4mainE3__c_5)
 5453 18d4 61E0      		ldi r22,lo8(1)
 5454 18d6 0E94 0000 		call _Z13ROM_putstringPKch
 5455               	.LBE206:
 599:iv.c          ****     speaker_init();
 5457               	.LM778:
 5458 18da 0E94 0000 		call _Z12speaker_initv
 601:iv.c          ****     beep(4000, 1);
 5460               	.LM779:
 5461 18de 80EA      		ldi r24,lo8(4000)
 5462 18e0 9FE0      		ldi r25,hi8(4000)
 5463 18e2 61E0      		ldi r22,lo8(1)
 5464 18e4 0E94 0000 		call _Z4beepjh
 5465               	.LBB207:
 603:iv.c          ****     DEBUGP("clock init");
 5467               	.LM780:
 5468 18e8 80E0      		ldi r24,lo8(_ZZ4mainE3__c_6)
 5469 18ea 90E0      		ldi r25,hi8(_ZZ4mainE3__c_6)
 5470 18ec 61E0      		ldi r22,lo8(1)
 5471 18ee 0E94 0000 		call _Z13ROM_putstringPKch
 5472               	.LBE207:
 604:iv.c          ****     clock_init();  
 5474               	.LM781:
 5475 18f2 0E94 0000 		call _Z10clock_initv
 5476               	.LBB208:
 606:iv.c          ****     DEBUGP("alarm init");
 5478               	.LM782:
 5479 18f6 80E0      		ldi r24,lo8(_ZZ4mainE3__c_7)
 5480 18f8 90E0      		ldi r25,hi8(_ZZ4mainE3__c_7)
 5481 18fa 61E0      		ldi r22,lo8(1)
 5482 18fc 0E94 0000 		call _Z13ROM_putstringPKch
 5483               	.LBE208:
 607:iv.c          ****     setalarmstate();
 5485               	.LM783:
 5486 1900 0E94 0000 		call _Z13setalarmstatev
 5487               	.L298:
 5488               	.LBE199:
 5489               	.LBE196:
 5490               	.LBB209:
 609:iv.c          ****   DEBUGP("done");
 5492               	.LM784:
 5493 1904 80E0      		ldi r24,lo8(_ZZ4mainE3__c_8)
 5494 1906 90E0      		ldi r25,hi8(_ZZ4mainE3__c_8)
 5495 1908 61E0      		ldi r22,lo8(1)
 5496 190a 0E94 0000 		call _Z13ROM_putstringPKch
 5497               	.LBE209:
 666:iv.c          ****       displaymode = NONE;
 5499               	.LM785:
 5500 190e E3E6      		ldi r30,lo8(99)
 5501 1910 BE2E      		mov r11,r30
 629:iv.c          **** 	displaymode = SET_TIME;
 5503               	.LM786:
 5504 1912 73E0      		ldi r23,lo8(3)
 5505 1914 C72E      		mov r12,r23
 645:iv.c          **** 	displaymode = SET_VOLUME;
 5507               	.LM787:
 5508 1916 67E0      		ldi r22,lo8(7)
 5509 1918 D62E      		mov r13,r22
 640:iv.c          **** 	displaymode = SET_BRIGHTNESS;
 5511               	.LM788:
 5512 191a 56E0      		ldi r21,lo8(6)
 5513 191c E52E      		mov r14,r21
 650:iv.c          **** 	displaymode = SET_REGION;
 5515               	.LM789:
 5516 191e 48E0      		ldi r20,lo8(8)
 5517 1920 F42E      		mov r15,r20
 624:iv.c          **** 	displaymode = SET_ALARM;
 5519               	.LM790:
 5520 1922 04E0      		ldi r16,lo8(4)
 635:iv.c          **** 	displaymode = SET_DATE;
 5522               	.LM791:
 5523 1924 15E0      		ldi r17,lo8(5)
 5524               	.L314:
 5525               	.LBB210:
 5526               	.LBB211:
 118:iv.c          ****   wdt_reset();
 5528               	.LM792:
 5529               	/* #APP */
 5530               	 ;  118 "iv.c" 1
 5531 1926 A895      		wdr
 5532               	 ;  0 "" 2
 5533               	/* #NOAPP */
 5534               	.LBE211:
 5535               	.LBE210:
 614:iv.c          ****     if (ACSR & _BV(ACO)) {
 5537               	.LM793:
 5538 1928 00B6      		in __tmp_reg__,80-32
 5539 192a 05FE      		sbrs __tmp_reg__,5
 5540 192c 00C0      		rjmp .L300
 616:iv.c          ****       gotosleep();
 5542               	.LM794:
 5543 192e 0E94 0000 		call _Z9gotosleepv
 617:iv.c          ****       continue;
 5545               	.LM795:
 5546 1932 00C0      		rjmp .L314
 5547               	.L300:
 620:iv.c          ****     if (just_pressed & 0x1) {
 5549               	.LM796:
 5550 1934 8091 0000 		lds r24,just_pressed
 5551 1938 80FF      		sbrs r24,0
 5552 193a 00C0      		rjmp .L302
 621:iv.c          ****       just_pressed = 0;
 5554               	.LM797:
 5555 193c 1092 0000 		sts just_pressed,__zero_reg__
 622:iv.c          ****       switch(displaymode) {
 5557               	.LM798:
 5558 1940 8091 0000 		lds r24,displaymode
 5559 1944 8430      		cpi r24,lo8(4)
 5560 1946 01F0      		breq .L306
 5561 1948 8530      		cpi r24,lo8(5)
 5562 194a 00F4      		brsh .L310
 5563 194c 8823      		tst r24
 5564 194e 01F0      		breq .L304
 5565 1950 8330      		cpi r24,lo8(3)
 5566 1952 01F0      		breq .+2
 5567 1954 00C0      		rjmp .L315
 5568 1956 00C0      		rjmp .L316
 5569               	.L310:
 5570 1958 8630      		cpi r24,lo8(6)
 5571 195a 01F0      		breq .L308
 5572 195c 8630      		cpi r24,lo8(6)
 5573 195e 00F0      		brlo .L307
 5574 1960 8730      		cpi r24,lo8(7)
 5575 1962 01F0      		breq .+2
 5576 1964 00C0      		rjmp .L315
 5577 1966 00C0      		rjmp .L317
 5578               	.L304:
 624:iv.c          **** 	displaymode = SET_ALARM;
 5580               	.LM799:
 5581 1968 0093 0000 		sts displaymode,r16
 625:iv.c          **** 	display_str("set alarm");
 5583               	.LM800:
 5584 196c 80E0      		ldi r24,lo8(.LC27)
 5585 196e 90E0      		ldi r25,hi8(.LC27)
 5586 1970 0E94 0000 		call _Z11display_strPKc
 626:iv.c          **** 	set_alarm();
 5588               	.LM801:
 5589 1974 0E94 0000 		call _Z9set_alarmv
 627:iv.c          **** 	break;
 5591               	.LM802:
 5592 1978 00C0      		rjmp .L314
 5593               	.L306:
 629:iv.c          **** 	displaymode = SET_TIME;
 5595               	.LM803:
 5596 197a C092 0000 		sts displaymode,r12
 630:iv.c          **** 	display_str("set time");
 5598               	.LM804:
 5599 197e 80E0      		ldi r24,lo8(.LC28)
 5600 1980 90E0      		ldi r25,hi8(.LC28)
 5601 1982 0E94 0000 		call _Z11display_strPKc
 631:iv.c          **** 	set_time();
 5603               	.LM805:
 5604 1986 0E94 0000 		call _Z8set_timev
 632:iv.c          **** 	timeunknown = 0;
 5606               	.LM806:
 5607 198a 1092 0000 		sts timeunknown,__zero_reg__
 633:iv.c          **** 	break;
 5609               	.LM807:
 5610 198e 00C0      		rjmp .L314
 5611               	.L316:
 635:iv.c          **** 	displaymode = SET_DATE;
 5613               	.LM808:
 5614 1990 1093 0000 		sts displaymode,r17
 636:iv.c          **** 	display_str("set date");
 5616               	.LM809:
 5617 1994 80E0      		ldi r24,lo8(.LC29)
 5618 1996 90E0      		ldi r25,hi8(.LC29)
 5619 1998 0E94 0000 		call _Z11display_strPKc
 637:iv.c          **** 	set_date();
 5621               	.LM810:
 5622 199c 0E94 0000 		call _Z8set_datev
 638:iv.c          **** 	break;
 5624               	.LM811:
 5625 19a0 00C0      		rjmp .L314
 5626               	.L307:
 640:iv.c          **** 	displaymode = SET_BRIGHTNESS;
 5628               	.LM812:
 5629 19a2 E092 0000 		sts displaymode,r14
 641:iv.c          **** 	display_str("set brit");
 5631               	.LM813:
 5632 19a6 80E0      		ldi r24,lo8(.LC30)
 5633 19a8 90E0      		ldi r25,hi8(.LC30)
 5634 19aa 0E94 0000 		call _Z11display_strPKc
 642:iv.c          **** 	set_brightness();
 5636               	.LM814:
 5637 19ae 0E94 0000 		call _Z14set_brightnessv
 643:iv.c          **** 	break;
 5639               	.LM815:
 5640 19b2 00C0      		rjmp .L314
 5641               	.L308:
 645:iv.c          **** 	displaymode = SET_VOLUME;
 5643               	.LM816:
 5644 19b4 D092 0000 		sts displaymode,r13
 646:iv.c          **** 	display_str("set vol ");
 5646               	.LM817:
 5647 19b8 80E0      		ldi r24,lo8(.LC31)
 5648 19ba 90E0      		ldi r25,hi8(.LC31)
 5649 19bc 0E94 0000 		call _Z11display_strPKc
 647:iv.c          **** 	set_volume();
 5651               	.LM818:
 5652 19c0 0E94 0000 		call _Z10set_volumev
 648:iv.c          **** 	break;
 5654               	.LM819:
 5655 19c4 00C0      		rjmp .L314
 5656               	.L317:
 650:iv.c          **** 	displaymode = SET_REGION;
 5658               	.LM820:
 5659 19c6 F092 0000 		sts displaymode,r15
 651:iv.c          **** 	display_str("set regn");
 5661               	.LM821:
 5662 19ca 80E0      		ldi r24,lo8(.LC32)
 5663 19cc 90E0      		ldi r25,hi8(.LC32)
 5664 19ce 0E94 0000 		call _Z11display_strPKc
 652:iv.c          **** 	set_region();
 5666               	.LM822:
 5667 19d2 0E94 0000 		call _Z10set_regionv
 653:iv.c          **** 	break;
 5669               	.LM823:
 5670 19d6 00C0      		rjmp .L314
 5671               	.L302:
 664:iv.c          ****     } else if ((just_pressed & 0x2) || (just_pressed & 0x4)) {
 5673               	.LM824:
 5674 19d8 8091 0000 		lds r24,just_pressed
 5675 19dc 81FD      		sbrc r24,1
 5676 19de 00C0      		rjmp .L311
 664:iv.c          ****     } else if ((just_pressed & 0x2) || (just_pressed & 0x4)) {
 5678               	.LM825:
 5679 19e0 8091 0000 		lds r24,just_pressed
 5680 19e4 82FF      		sbrs r24,2
 5681 19e6 00C0      		rjmp .L314
 5682               	.L311:
 665:iv.c          ****       just_pressed = 0;
 5684               	.LM826:
 5685 19e8 1092 0000 		sts just_pressed,__zero_reg__
 666:iv.c          ****       displaymode = NONE;
 5687               	.LM827:
 5688 19ec B092 0000 		sts displaymode,r11
 667:iv.c          ****       display_date(DAY);
 5690               	.LM828:
 5691 19f0 81E0      		ldi r24,lo8(1)
 5692 19f2 0E94 0000 		call _Z12display_dateh
 5693               	.LBB212:
 5694               	.LBB213:
 118:iv.c          ****   wdt_reset();
 5696               	.LM829:
 5697               	/* #APP */
 5698               	 ;  118 "iv.c" 1
 5699 19f6 A895      		wdr
 5700               	 ;  0 "" 2
 5701               	/* #NOAPP */
 5702               	.LBE213:
 5703               	.LBE212:
 670:iv.c          ****       delayms(1500);
 5705               	.LM830:
 5706 19f8 8CED      		ldi r24,lo8(1500)
 5707 19fa 95E0      		ldi r25,hi8(1500)
 5708 19fc 0E94 0000 		call _Z7delaymsj
 5709               	.LBB214:
 5710               	.LBB215:
 118:iv.c          ****   wdt_reset();
 5712               	.LM831:
 5713               	/* #APP */
 5714               	 ;  118 "iv.c" 1
 5715 1a00 A895      		wdr
 5716               	 ;  0 "" 2
 5717               	/* #NOAPP */
 5718               	.L315:
 5719               	.LBE215:
 5720               	.LBE214:
 673:iv.c          ****       displaymode = SHOW_TIME;     
 5722               	.LM832:
 5723 1a02 1092 0000 		sts displaymode,__zero_reg__
 5724 1a06 00C0      		rjmp .L314
 5725               	.LBE190:
 5730               	.Lscope29:
 5732               		.stabd	78,0,0
 5734               	.global	_Z8vfd_initv
 5736               	_Z8vfd_initv:
 5737               		.stabd	46,0,0
1578:iv.c          **** void vfd_init(void) {
 5739               	.LM833:
 5740               	.LFBB30:
 5741               	/* prologue: function */
 5742               	/* frame size = 0 */
 5743               	/* stack size = 0 */
 5744               	.L__stack_usage = 0
 5746               	.LM834:
 5747 1a08 81E5      		ldi r24,lo8(81)
 5748 1a0a 8CBD      		out 76-32,r24
 5749               	/* epilogue start */
1580:iv.c          **** }
 5751               	.LM835:
 5752 1a0c 0895      		ret
 5754               	.Lscope30:
 5756               		.stabd	78,0,0
 5759               	.global	_Z8spi_xferh
 5761               	_Z8spi_xferh:
 5762               		.stabd	46,0,0
1581:iv.c          **** 
1582:iv.c          **** // This changes and updates the display
1583:iv.c          **** // We use the digit/segment table to determine which
1584:iv.c          **** // pins on the MAX6921 to turn on
1585:iv.c          **** void setdisplay(uint8_t digit, uint8_t segments) {
1586:iv.c          ****   uint32_t d = 0;  // we only need 20 bits but 32 will do
1587:iv.c          ****   uint8_t i;
1588:iv.c          **** 
1589:iv.c          ****   // Set the digit selection pin
1590:iv.c          ****   d |= _BV(pgm_read_byte(digittable + digit));
1591:iv.c          **** 
1592:iv.c          ****   
1593:iv.c          ****   // Set the individual segments for this digit
1594:iv.c          ****   for (i=0; i<8; i++) {
1595:iv.c          ****     if (segments & _BV(i)) {
1596:iv.c          ****       t = 1;
1597:iv.c          ****       t <<= pgm_read_byte(segmenttable + i);
1598:iv.c          ****       d |= t;
1599:iv.c          ****     }
1600:iv.c          ****   }
1601:iv.c          **** 
1602:iv.c          ****   // Shift the data out to the display
1603:iv.c          ****   vfd_send(d);
1604:iv.c          **** }
1605:iv.c          **** 
1606:iv.c          **** // send raw data to display, its pretty straightforward. Just send 32 bits via SPI
1607:iv.c          **** // the bottom 20 define the segments
1608:iv.c          **** void vfd_send(uint32_t d) {
1609:iv.c          ****   // send lowest 20 bits
1610:iv.c          ****   cli();       // to prevent flicker we turn off interrupts
1611:iv.c          ****   spi_xfer(d >> 16);
1612:iv.c          ****   spi_xfer(d >> 8);
1613:iv.c          ****   spi_xfer(d);
1614:iv.c          **** 
1615:iv.c          ****   // latch data
1616:iv.c          ****   VFDLOAD_PORT |= _BV(VFDLOAD);
1617:iv.c          ****   VFDLOAD_PORT &= ~_BV(VFDLOAD);
1618:iv.c          ****   sei();
1619:iv.c          **** }
1620:iv.c          **** 
1621:iv.c          **** // Send 1 byte via SPI
1622:iv.c          **** void spi_xfer(uint8_t c) {
 5764               	.LM836:
 5765               	.LFBB31:
 5766               	/* prologue: function */
 5767               	/* frame size = 0 */
 5768               	/* stack size = 0 */
 5769               	.L__stack_usage = 0
1623:iv.c          **** 
1624:iv.c          ****   SPDR = c;
 5771               	.LM837:
 5772 1a0e 8EBD      		out 78-32,r24
 5773               	.L320:
1625:iv.c          ****   while (! (SPSR & _BV(SPIF)));
 5775               	.LM838:
 5776 1a10 0DB4      		in __tmp_reg__,77-32
 5777 1a12 07FE      		sbrs __tmp_reg__,7
 5778 1a14 00C0      		rjmp .L320
 5779               	/* epilogue start */
1626:iv.c          **** }
 5781               	.LM839:
 5782 1a16 0895      		ret
 5784               	.Lscope31:
 5786               		.stabd	78,0,0
 5788               	.global	_Z8vfd_sendm
 5790               	_Z8vfd_sendm:
 5791               		.stabd	46,0,0
1608:iv.c          **** void vfd_send(uint32_t d) {
 5793               	.LM840:
 5794               	.LFBB32:
 5795 1a18 DF93      		push r29
 5796 1a1a CF93      		push r28
 5797 1a1c 00D0      		rcall .
 5798 1a1e CDB7      		in r28,__SP_L__
 5799 1a20 DEB7      		in r29,__SP_H__
 5800               	/* prologue: function */
 5801               	/* frame size = 2 */
 5802               	/* stack size = 4 */
 5803               	.L__stack_usage = 4
1610:iv.c          ****   cli();       // to prevent flicker we turn off interrupts
 5805               	.LM841:
 5806               	/* #APP */
 5807               	 ;  1610 "iv.c" 1
 5808 1a22 F894      		cli
 5809               	 ;  0 "" 2
1611:iv.c          ****   spi_xfer(d >> 16);
 5811               	.LM842:
 5812               	/* #NOAPP */
 5813 1a24 6A83      		std Y+2,r22
 5814 1a26 7983      		std Y+1,r23
 5815 1a28 0E94 0000 		call _Z8spi_xferh
1612:iv.c          ****   spi_xfer(d >> 8);
 5817               	.LM843:
 5818 1a2c 7981      		ldd r23,Y+1
 5819 1a2e 872F      		mov r24,r23
 5820 1a30 0E94 0000 		call _Z8spi_xferh
1613:iv.c          ****   spi_xfer(d);
 5822               	.LM844:
 5823 1a34 6A81      		ldd r22,Y+2
 5824 1a36 862F      		mov r24,r22
 5825 1a38 0E94 0000 		call _Z8spi_xferh
1616:iv.c          ****   VFDLOAD_PORT |= _BV(VFDLOAD);
 5827               	.LM845:
 5828 1a3c 409A      		sbi 40-32,0
1617:iv.c          ****   VFDLOAD_PORT &= ~_BV(VFDLOAD);
 5830               	.LM846:
 5831 1a3e 4098      		cbi 40-32,0
1618:iv.c          ****   sei();
 5833               	.LM847:
 5834               	/* #APP */
 5835               	 ;  1618 "iv.c" 1
 5836 1a40 7894      		sei
 5837               	 ;  0 "" 2
 5838               	/* epilogue start */
1619:iv.c          **** }
 5840               	.LM848:
 5841               	/* #NOAPP */
 5842 1a42 0F90      		pop __tmp_reg__
 5843 1a44 0F90      		pop __tmp_reg__
 5844 1a46 CF91      		pop r28
 5845 1a48 DF91      		pop r29
 5846 1a4a 0895      		ret
 5848               	.Lscope32:
 5850               		.stabd	78,0,0
 5854               	.global	_Z10setdisplayhh
 5856               	_Z10setdisplayhh:
 5857               		.stabd	46,0,0
1585:iv.c          **** void setdisplay(uint8_t digit, uint8_t segments) {
 5859               	.LM849:
 5860               	.LFBB33:
 5861 1a4c AF92      		push r10
 5862 1a4e BF92      		push r11
 5863 1a50 CF92      		push r12
 5864 1a52 DF92      		push r13
 5865 1a54 EF92      		push r14
 5866 1a56 FF92      		push r15
 5867 1a58 0F93      		push r16
 5868 1a5a 1F93      		push r17
 5869 1a5c CF93      		push r28
 5870 1a5e DF93      		push r29
 5871               	/* prologue: function */
 5872               	/* frame size = 0 */
 5873               	/* stack size = 10 */
 5874               	.L__stack_usage = 10
 5875 1a60 E62E      		mov r14,r22
 5876               	.LBB216:
 5877               	.LBB217:
1590:iv.c          ****   d |= _BV(pgm_read_byte(digittable + digit));
 5879               	.LM850:
 5880 1a62 E82F      		mov r30,r24
 5881 1a64 F0E0      		ldi r31,lo8(0)
 5882 1a66 E050      		subi r30,lo8(-(_ZL10digittable))
 5883 1a68 F040      		sbci r31,hi8(-(_ZL10digittable))
 5884               	/* #APP */
 5885               	 ;  1590 "iv.c" 1
 5886 1a6a E491      		lpm r30, Z
 5887               		
 5888               	 ;  0 "" 2
 5889               	/* #NOAPP */
 5890               	.LBE217:
 5891 1a6c 21E0      		ldi r18,lo8(1)
 5892 1a6e 30E0      		ldi r19,hi8(1)
 5893 1a70 00C0      		rjmp 2f
 5894 1a72 220F      	1:	lsl r18
 5895 1a74 331F      		rol r19
 5896 1a76 EA95      	2:	dec r30
 5897 1a78 02F4      		brpl 1b
 5898 1a7a B901      		movw r22,r18
 5899 1a7c 8827      		clr r24
 5900 1a7e 77FD      		sbrc r23,7
 5901 1a80 8095      		com r24
 5902 1a82 982F      		mov r25,r24
 5903 1a84 2091 0000 		lds r18,t
 5904 1a88 3091 0000 		lds r19,t+1
 5905 1a8c 4091 0000 		lds r20,t+2
 5906 1a90 5091 0000 		lds r21,t+3
 5907 1a94 A0E0      		ldi r26,lo8(0)
 5908 1a96 B0E0      		ldi r27,hi8(0)
 5909               	.LBB218:
 5910               	.LBB219:
1595:iv.c          ****     if (segments & _BV(i)) {
 5912               	.LM851:
 5913 1a98 CE2D      		mov r28,r14
 5914 1a9a D0E0      		ldi r29,lo8(0)
 5915               	.LBB220:
1597:iv.c          ****       t <<= pgm_read_byte(segmenttable + i);
 5917               	.LM852:
 5918 1a9c F1E0      		ldi r31,lo8(1)
 5919 1a9e EF2E      		mov r14,r31
 5920 1aa0 F12C      		mov r15,__zero_reg__
 5921 1aa2 012D      		mov r16,__zero_reg__
 5922 1aa4 112D      		mov r17,__zero_reg__
 5923               	.L325:
 5924               	.LBE220:
1595:iv.c          ****     if (segments & _BV(i)) {
 5926               	.LM853:
 5927 1aa6 FE01      		movw r30,r28
 5928 1aa8 0A2E      		mov r0,r26
 5929 1aaa 00C0      		rjmp 2f
 5930 1aac F595      	1:	asr r31
 5931 1aae E795      		ror r30
 5932 1ab0 0A94      	2:	dec r0
 5933 1ab2 02F4      		brpl 1b
 5934 1ab4 E0FF      		sbrs r30,0
 5935 1ab6 00C0      		rjmp .L324
 5936               	.LBB222:
 5937               	.LBB221:
1597:iv.c          ****       t <<= pgm_read_byte(segmenttable + i);
 5939               	.LM854:
 5940 1ab8 FD01      		movw r30,r26
 5941 1aba E050      		subi r30,lo8(-(_ZL12segmenttable))
 5942 1abc F040      		sbci r31,hi8(-(_ZL12segmenttable))
 5943               	/* #APP */
 5944               	 ;  1597 "iv.c" 1
 5945 1abe 2491      		lpm r18, Z
 5946               		
 5947               	 ;  0 "" 2
 5948               	/* #NOAPP */
 5949               	.LBE221:
 5950 1ac0 5701      		movw r10,r14
 5951 1ac2 6801      		movw r12,r16
 5952 1ac4 00C0      		rjmp 2f
 5953 1ac6 AA0C      	1:	lsl r10
 5954 1ac8 BB1C      		rol r11
 5955 1aca CC1C      		rol r12
 5956 1acc DD1C      		rol r13
 5957 1ace 2A95      	2:	dec r18
 5958 1ad0 02F4      		brpl 1b
 5959 1ad2 A601      		movw r20,r12
 5960 1ad4 9501      		movw r18,r10
1598:iv.c          ****       d |= t;
 5962               	.LM855:
 5963 1ad6 6A29      		or r22,r10
 5964 1ad8 7B29      		or r23,r11
 5965 1ada 8C29      		or r24,r12
 5966 1adc 9D29      		or r25,r13
 5967               	.L324:
 5968 1ade 1196      		adiw r26,1
 5969               	.LBE222:
 5970               	.LBE219:
1594:iv.c          ****   for (i=0; i<8; i++) {
 5972               	.LM856:
 5973 1ae0 A830      		cpi r26,8
 5974 1ae2 B105      		cpc r27,__zero_reg__
 5975 1ae4 01F4      		brne .L325
 5976 1ae6 2093 0000 		sts t,r18
 5977 1aea 3093 0000 		sts t+1,r19
 5978 1aee 4093 0000 		sts t+2,r20
 5979 1af2 5093 0000 		sts t+3,r21
 5980               	.LBE218:
1603:iv.c          ****   vfd_send(d);
 5982               	.LM857:
 5983 1af6 0E94 0000 		call _Z8vfd_sendm
 5984               	/* epilogue start */
 5985               	.LBE216:
1604:iv.c          **** }
 5987               	.LM858:
 5988 1afa DF91      		pop r29
 5989 1afc CF91      		pop r28
 5990 1afe 1F91      		pop r17
 5991 1b00 0F91      		pop r16
 5992 1b02 FF90      		pop r15
 5993 1b04 EF90      		pop r14
 5994 1b06 DF90      		pop r13
 5995 1b08 CF90      		pop r12
 5996 1b0a BF90      		pop r11
 5997 1b0c AF90      		pop r10
 5998 1b0e 0895      		ret
 6003               	.Lscope33:
 6005               		.stabd	78,0,0
 6007               	.global	__vector_16
 6009               	__vector_16:
 6010               		.stabd	46,0,0
 122:iv.c          **** ISR(TIMER0_OVF_vect) {
 6012               	.LM859:
 6013               	.LFBB34:
 6014 1b10 1F92      		push __zero_reg__
 6015 1b12 0F92      		push r0
 6016 1b14 0FB6      		in r0,__SREG__
 6017 1b16 0F92      		push r0
 6018 1b18 1124      		clr __zero_reg__
 6019 1b1a 2F93      		push r18
 6020 1b1c 3F93      		push r19
 6021 1b1e 4F93      		push r20
 6022 1b20 5F93      		push r21
 6023 1b22 6F93      		push r22
 6024 1b24 7F93      		push r23
 6025 1b26 8F93      		push r24
 6026 1b28 9F93      		push r25
 6027 1b2a AF93      		push r26
 6028 1b2c BF93      		push r27
 6029 1b2e EF93      		push r30
 6030 1b30 FF93      		push r31
 6031               	/* prologue: Signal */
 6032               	/* frame size = 0 */
 6033               	/* stack size = 15 */
 6034               	.L__stack_usage = 15
 124:iv.c          ****   sei();
 6036               	.LM860:
 6037               	/* #APP */
 6038               	 ;  124 "iv.c" 1
 6039 1b32 7894      		sei
 6040               	 ;  0 "" 2
 6041               	/* #NOAPP */
 6042               	.LBB223:
 6043               	.LBB224:
 118:iv.c          ****   wdt_reset();
 6045               	.LM861:
 6046               	/* #APP */
 6047               	 ;  118 "iv.c" 1
 6048 1b34 A895      		wdr
 6049               	 ;  0 "" 2
 6050               	/* #NOAPP */
 6051               	.LBE224:
 6052               	.LBE223:
 130:iv.c          ****   muxdiv++;
 6054               	.LM862:
 6055 1b36 8091 0000 		lds r24,muxdiv
 6056 1b3a 9091 0000 		lds r25,muxdiv+1
 6057 1b3e 0196      		adiw r24,1
 6058 1b40 9093 0000 		sts muxdiv+1,r25
 6059 1b44 8093 0000 		sts muxdiv,r24
 131:iv.c          ****   if (muxdiv < MUX_DIVIDER)
 6061               	.LM863:
 6062 1b48 8132      		cpi r24,33
 6063 1b4a 9105      		cpc r25,__zero_reg__
 6064 1b4c 00F4      		brsh .+2
 6065 1b4e 00C0      		rjmp .L327
 133:iv.c          ****   muxdiv = 0;
 6067               	.LM864:
 6068 1b50 1092 0000 		sts muxdiv+1,__zero_reg__
 6069 1b54 1092 0000 		sts muxdiv,__zero_reg__
 137:iv.c          ****   milliseconds++;
 6071               	.LM865:
 6072 1b58 8091 0000 		lds r24,milliseconds
 6073 1b5c 9091 0000 		lds r25,milliseconds+1
 6074 1b60 0196      		adiw r24,1
 6075 1b62 9093 0000 		sts milliseconds+1,r25
 6076 1b66 8093 0000 		sts milliseconds,r24
 140:iv.c          ****   if (currdigit >= DISPLAYSIZE)
 6078               	.LM866:
 6079 1b6a 8091 0000 		lds r24,currdigit
 6080 1b6e 8930      		cpi r24,lo8(9)
 6081 1b70 00F0      		brlo .L329
 141:iv.c          ****     currdigit = 0;
 6083               	.LM867:
 6084 1b72 1092 0000 		sts currdigit,__zero_reg__
 6085               	.L329:
 144:iv.c          ****   setdisplay(currdigit, display[currdigit]);
 6087               	.LM868:
 6088 1b76 8091 0000 		lds r24,currdigit
 6089 1b7a E82F      		mov r30,r24
 6090 1b7c F0E0      		ldi r31,lo8(0)
 6091 1b7e E050      		subi r30,lo8(-(display))
 6092 1b80 F040      		sbci r31,hi8(-(display))
 6093 1b82 6081      		ld r22,Z
 6094 1b84 0E94 0000 		call _Z10setdisplayhh
 146:iv.c          ****   currdigit++;
 6096               	.LM869:
 6097 1b88 8091 0000 		lds r24,currdigit
 6098 1b8c 8F5F      		subi r24,lo8(-(1))
 6099 1b8e 8093 0000 		sts currdigit,r24
 149:iv.c          ****   if (alarming && !snoozetimer) {
 6101               	.LM870:
 6102 1b92 8091 0000 		lds r24,alarming
 6103 1b96 8823      		tst r24
 6104 1b98 01F4      		brne .+2
 6105 1b9a 00C0      		rjmp .L327
 149:iv.c          ****   if (alarming && !snoozetimer) {
 6107               	.LM871:
 6108 1b9c 8091 0000 		lds r24,snoozetimer
 6109 1ba0 9091 0000 		lds r25,snoozetimer+1
 6110 1ba4 0097      		sbiw r24,0
 6111 1ba6 01F0      		breq .+2
 6112 1ba8 00C0      		rjmp .L327
 150:iv.c          ****     alarmdiv++;
 6114               	.LM872:
 6115 1baa 8091 0000 		lds r24,alarmdiv
 6116 1bae 9091 0000 		lds r25,alarmdiv+1
 6117 1bb2 0196      		adiw r24,1
 6118 1bb4 9093 0000 		sts alarmdiv+1,r25
 6119 1bb8 8093 0000 		sts alarmdiv,r24
 151:iv.c          ****     if (alarmdiv > ALARM_DIVIDER) {
 6121               	.LM873:
 6122 1bbc 8536      		cpi r24,101
 6123 1bbe 9105      		cpc r25,__zero_reg__
 6124 1bc0 00F0      		brlo .L327
 152:iv.c          ****       alarmdiv = 0;
 6126               	.LM874:
 6127 1bc2 1092 0000 		sts alarmdiv+1,__zero_reg__
 6128 1bc6 1092 0000 		sts alarmdiv,__zero_reg__
 159:iv.c          ****     ICR1 = 250;
 6130               	.LM875:
 6131 1bca 8AEF      		ldi r24,lo8(250)
 6132 1bcc 90E0      		ldi r25,hi8(250)
 6133 1bce 9093 8700 		sts 134+1,r25
 6134 1bd2 8093 8600 		sts 134,r24
 160:iv.c          ****     OCR1A = OCR1B = ICR1/2;
 6136               	.LM876:
 6137 1bd6 8091 8600 		lds r24,134
 6138 1bda 9091 8700 		lds r25,134+1
 6139 1bde 9695      		lsr r25
 6140 1be0 8795      		ror r24
 6141 1be2 9093 8B00 		sts 138+1,r25
 6142 1be6 8093 8A00 		sts 138,r24
 6143 1bea 8091 8A00 		lds r24,138
 6144 1bee 9091 8B00 		lds r25,138+1
 6145 1bf2 9093 8900 		sts 136+1,r25
 6146 1bf6 8093 8800 		sts 136,r24
 163:iv.c          ****     if (alarming & 0xF0) { // top bit indicates pulsing alarm state
 6148               	.LM877:
 6149 1bfa 8091 0000 		lds r24,alarming
 6150 1bfe 807F      		andi r24,lo8(-16)
 6151 1c00 01F0      		breq .L330
 164:iv.c          ****       alarming &= ~0xF0;
 6153               	.LM878:
 6154 1c02 8091 0000 		lds r24,alarming
 6155 1c06 8F70      		andi r24,lo8(15)
 6156 1c08 8093 0000 		sts alarming,r24
 165:iv.c          ****       TCCR1B &= ~_BV(CS11); // turn buzzer off!
 6158               	.LM879:
 6159 1c0c 8091 8100 		lds r24,129
 6160 1c10 8D7F      		andi r24,lo8(-3)
 6161 1c12 00C0      		rjmp .L331
 6162               	.L330:
 167:iv.c          ****       alarming |= 0xF0;
 6164               	.LM880:
 6165 1c14 8091 0000 		lds r24,alarming
 6166 1c18 806F      		ori r24,lo8(-16)
 6167 1c1a 8093 0000 		sts alarming,r24
 168:iv.c          ****       TCCR1B |= _BV(CS11); // turn buzzer on!
 6169               	.LM881:
 6170 1c1e 8091 8100 		lds r24,129
 6171 1c22 8260      		ori r24,lo8(2)
 6172               	.L331:
 6173 1c24 8093 8100 		sts 129,r24
 6174               	.L327:
 6175               	/* epilogue start */
 172:iv.c          **** }
 6177               	.LM882:
 6178 1c28 FF91      		pop r31
 6179 1c2a EF91      		pop r30
 6180 1c2c BF91      		pop r27
 6181 1c2e AF91      		pop r26
 6182 1c30 9F91      		pop r25
 6183 1c32 8F91      		pop r24
 6184 1c34 7F91      		pop r23
 6185 1c36 6F91      		pop r22
 6186 1c38 5F91      		pop r21
 6187 1c3a 4F91      		pop r20
 6188 1c3c 3F91      		pop r19
 6189 1c3e 2F91      		pop r18
 6190 1c40 0F90      		pop r0
 6191 1c42 0FBE      		out __SREG__,r0
 6192 1c44 0F90      		pop r0
 6193 1c46 1F90      		pop __zero_reg__
 6194 1c48 1895      		reti
 6196               	.Lscope34:
 6198               		.stabd	78,0,0
 6199               	.global	app_start
 6200               	.global	app_start
 6201               		.section .bss
 6204               	app_start:
 6205 0000 0000      		.skip 2,0
 6206               	.global	region
 6207               	.global	region
 6210               	region:
 6211 0002 00        		.skip 1,0
 6212               	.global	time_s
 6213               	.global	time_s
 6216               	time_s:
 6217 0003 00        		.skip 1,0
 6218               	.global	time_m
 6219               	.global	time_m
 6222               	time_m:
 6223 0004 00        		.skip 1,0
 6224               	.global	time_h
 6225               	.global	time_h
 6228               	time_h:
 6229 0005 00        		.skip 1,0
 6230               	.global	date_m
 6231               	.global	date_m
 6234               	date_m:
 6235 0006 00        		.skip 1,0
 6236               	.global	date_d
 6237               	.global	date_d
 6240               	date_d:
 6241 0007 00        		.skip 1,0
 6242               	.global	date_y
 6243               	.global	date_y
 6246               	date_y:
 6247 0008 00        		.skip 1,0
 6248               	.global	volume
 6249               	.global	volume
 6252               	volume:
 6253 0009 00        		.skip 1,0
 6254               	.global	alarm_on
 6255               	.global	alarm_on
 6258               	alarm_on:
 6259 000a 00        		.skip 1,0
 6260               	.global	alarming
 6261               	.global	alarming
 6264               	alarming:
 6265 000b 00        		.skip 1,0
 6266               	.global	alarm_h
 6267               	.global	alarm_h
 6270               	alarm_h:
 6271 000c 00        		.skip 1,0
 6272               	.global	alarm_m
 6273               	.global	alarm_m
 6276               	alarm_m:
 6277 000d 00        		.skip 1,0
 6278               	.global	displaymode
 6279               	.global	displaymode
 6282               	displaymode:
 6283 000e 00        		.skip 1,0
 6284               	.global	sleepmode
 6285               	.global	sleepmode
 6288               	sleepmode:
 6289 000f 00        		.skip 1,0
 6290               	.global	timeunknown
 6291               	.global	timeunknown
 6294               	timeunknown:
 6295 0010 00        		.skip 1,0
 6296               	.global	restored
 6297               	.global	restored
 6300               	restored:
 6301 0011 00        		.skip 1,0
 6302               	.global	display
 6303               	.global	display
 6306               	display:
 6307 0012 0000 0000 		.skip 9,0
 6307      0000 0000 
 6307      00
 6308               	.global	currdigit
 6309               	.global	currdigit
 6312               	currdigit:
 6313 001b 00        		.skip 1,0
 6314               	.global	muxdiv
 6315               	.global	muxdiv
 6318               	muxdiv:
 6319 001c 0000      		.skip 2,0
 6320               	.global	alarmdiv
 6321               	.global	alarmdiv
 6324               	alarmdiv:
 6325 001e 0000      		.skip 2,0
 6326               	.global	snoozetimer
 6327               	.global	snoozetimer
 6330               	snoozetimer:
 6331 0020 0000      		.skip 2,0
 6332               	.global	milliseconds
 6333               	.global	milliseconds
 6336               	milliseconds:
 6337 0022 0000      		.skip 2,0
 6338               	.global	last_buttonstate
 6339               	.global	last_buttonstate
 6342               	last_buttonstate:
 6343 0024 00        		.skip 1,0
 6344               	.global	just_pressed
 6345               	.global	just_pressed
 6348               	just_pressed:
 6349 0025 00        		.skip 1,0
 6350               	.global	pressed
 6351               	.global	pressed
 6354               	pressed:
 6355 0026 00        		.skip 1,0
 6356               	.global	buttonholdcounter
 6357               	.global	buttonholdcounter
 6360               	buttonholdcounter:
 6361 0027 00        		.skip 1,0
 6362               	.global	timeoutcounter
 6363               	.global	timeoutcounter
 6366               	timeoutcounter:
 6367 0028 00        		.skip 1,0
 6368               	.global	t
 6369               	.global	t
 6372               	t:
 6373 0029 0000 0000 		.skip 4,0
 6374               		.section	.progmem.data,"a",@progbits
 6377               	_ZL10digittable:
 6378 0000 03        		.byte	3
 6379 0001 07        		.byte	7
 6380 0002 08        		.byte	8
 6381 0003 09        		.byte	9
 6382 0004 06        		.byte	6
 6383 0005 0A        		.byte	10
 6384 0006 05        		.byte	5
 6385 0007 0C        		.byte	12
 6386 0008 04        		.byte	4
 6389               	_ZL12segmenttable:
 6390 0009 0B        		.byte	11
 6391 000a 10        		.byte	16
 6392 000b 12        		.byte	18
 6393 000c 0F        		.byte	15
 6394 000d 0D        		.byte	13
 6395 000e 0E        		.byte	14
 6396 000f 11        		.byte	17
 6397 0010 13        		.byte	19
 6400               	_ZL10alphatable:
 6401 0011 FA        		.byte	-6
 6402 0012 3E        		.byte	62
 6403 0013 1A        		.byte	26
 6404 0014 7A        		.byte	122
 6405 0015 DE        		.byte	-34
 6406 0016 8E        		.byte	-114
 6407 0017 F6        		.byte	-10
 6408 0018 2E        		.byte	46
 6409 0019 60        		.byte	96
 6410 001a 78        		.byte	120
 6411 001b AE        		.byte	-82
 6412 001c 1C        		.byte	28
 6413 001d AA        		.byte	-86
 6414 001e 2A        		.byte	42
 6415 001f 3A        		.byte	58
 6416 0020 CE        		.byte	-50
 6417 0021 F3        		.byte	-13
 6418 0022 0A        		.byte	10
 6419 0023 B6        		.byte	-74
 6420 0024 1E        		.byte	30
 6421 0025 38        		.byte	56
 6422 0026 38        		.byte	56
 6423 0027 B8        		.byte	-72
 6424 0028 6E        		.byte	110
 6425 0029 76        		.byte	118
 6426 002a DA        		.byte	-38
 6429               	_ZL11numbertable:
 6430 002b FC        		.byte	-4
 6431 002c 60        		.byte	96
 6432 002d DA        		.byte	-38
 6433 002e F2        		.byte	-14
 6434 002f 66        		.byte	102
 6435 0030 B6        		.byte	-74
 6436 0031 BE        		.byte	-66
 6437 0032 E0        		.byte	-32
 6438 0033 FE        		.byte	-2
 6439 0034 E6        		.byte	-26
 6442               	_ZZ13setalarmstatevE3__c:
 6443 0035 616C 6172 		.string	"alarm off"
 6443      6D20 6F66 
 6443      6600 
 6446               	_ZZ8set_datevE3__c:
 6447 003f 5365 7420 		.string	"Set day"
 6447      6461 7900 
 6450               	_ZZ4mainE3__c_8:
 6451 0047 646F 6E65 		.string	"done"
 6451      00
 6454               	_ZZ4mainE3__c_7:
 6455 004c 616C 6172 		.string	"alarm init"
 6455      6D20 696E 
 6455      6974 00
 6458               	_ZZ4mainE3__c_6:
 6459 0057 636C 6F63 		.string	"clock init"
 6459      6B20 696E 
 6459      6974 00
 6462               	_ZZ4mainE3__c_5:
 6463 0062 7370 6561 		.string	"speaker init"
 6463      6B65 7220 
 6463      696E 6974 
 6463      00
 6466               	_ZZ4mainE3__c_4:
 6467 006f 626F 6F73 		.string	"boost init"
 6467      7420 696E 
 6467      6974 00
 6470               	_ZZ4mainE3__c_3:
 6471 007a 7666 6420 		.string	"vfd init"
 6471      696E 6974 
 6471      00
 6474               	_ZZ4mainE3__c_2:
 6475 0083 7475 726E 		.string	"turning on alarmsw"
 6475      696E 6720 
 6475      6F6E 2061 
 6475      6C61 726D 
 6475      7377 00
 6478               	_ZZ4mainE3__c_1:
 6479 0096 7475 726E 		.string	"turning on buttons"
 6479      696E 6720 
 6479      6F6E 2062 
 6479      7574 746F 
 6479      6E73 00
 6482               	_ZZ4mainE3__c_0:
 6483 00a9 636C 6F63 		.string	"clock init"
 6483      6B20 696E 
 6483      6974 00
 6486               	_ZZ4mainE3__c:
 6487 00b4 2100      		.string	"!"
 6490               	_ZZ6wakeupvE3__c:
 6491 00b6 7761 6B65 		.string	"waketime"
 6491      7469 6D65 
 6491      00
 6494               	_ZZ11__vector_23E3__c_0:
 6495 00bf 5741 4B45 		.string	"WAKERESET"
 6495      5245 5345 
 6495      5400 
 6498               	_ZZ11__vector_23E3__c:
 6499 00c9 7A00      		.string	"z"
 6502               	_ZZ10__vector_9E3__c:
 6503 00cb 616C 6172 		.string	"alarm on!"
 6503      6D20 6F6E 
 6503      2100 
 6506               	_ZZ10__vector_3E3__c:
 6507 00d5 6232 00   		.string	"b2"
 6510               	_ZZ10__vector_5E3__c_0:
 6511 00d8 6233 00   		.string	"b3"
 6514               	_ZZ10__vector_5E3__c:
 6515 00db 6231 00   		.string	"b1"
 6518               	_ZZ9setsnoozevE3__c:
 6519 00de 736E 6F6F 		.string	"snooze"
 6519      7A65 00
 6553               		.text
 6555               	.Letext0:
 6556               	.global __do_copy_data
 6557               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 iv.c
     /tmp/cclLq83w.s:2      *ABS*:000000000000003f __SREG__
     /tmp/cclLq83w.s:3      *ABS*:000000000000003e __SP_H__
     /tmp/cclLq83w.s:4      *ABS*:000000000000003d __SP_L__
     /tmp/cclLq83w.s:5      *ABS*:0000000000000034 __CCP__
     /tmp/cclLq83w.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cclLq83w.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/cclLq83w.s:89     .text:0000000000000000 _Z7delaymsj
     /tmp/cclLq83w.s:6336   .bss:0000000000000022 milliseconds
     /tmp/cclLq83w.s:128    .text:000000000000001a _Z11pet_the_dogv
     /tmp/cclLq83w.s:155    .text:000000000000001e __vector_23
     /tmp/cclLq83w.s:6288   .bss:000000000000000f sleepmode
     /tmp/cclLq83w.s:6300   .bss:0000000000000011 restored
     /tmp/cclLq83w.s:6222   .bss:0000000000000004 time_m
     /tmp/cclLq83w.s:6216   .bss:0000000000000003 time_s
     /tmp/cclLq83w.s:6498   .progmem.data:00000000000000c9 _ZZ11__vector_23E3__c
     /tmp/cclLq83w.s:6252   .bss:0000000000000009 volume
     /tmp/cclLq83w.s:6494   .progmem.data:00000000000000bf _ZZ11__vector_23E3__c_0
     /tmp/cclLq83w.s:6204   .bss:0000000000000000 app_start
     /tmp/cclLq83w.s:320    .text:00000000000000f4 _Z9gotosleepv
     /tmp/cclLq83w.s:430    .text:000000000000014c _Z11initbuttonsv
     /tmp/cclLq83w.s:481    .text:0000000000000172 _Z10clock_initv
     /tmp/cclLq83w.s:6228   .bss:0000000000000005 time_h
     /tmp/cclLq83w.s:6276   .bss:000000000000000d alarm_m
     /tmp/cclLq83w.s:6270   .bss:000000000000000c alarm_h
     /tmp/cclLq83w.s:6246   .bss:0000000000000008 date_y
     /tmp/cclLq83w.s:6234   .bss:0000000000000006 date_m
     /tmp/cclLq83w.s:6240   .bss:0000000000000007 date_d
     /tmp/cclLq83w.s:596    .text:0000000000000228 _Z8leapyearj
     /tmp/cclLq83w.s:651    .text:000000000000025c _Z12speaker_initv
     /tmp/cclLq83w.s:719    .text:00000000000002be _Z4tickv
     /tmp/cclLq83w.s:796    .text:0000000000000306 _Z4beepjh
     /tmp/cclLq83w.s:912    .text:0000000000000398 _Z10boost_inith
     /tmp/cclLq83w.s:1082   .text:0000000000000420 _Z12display_timehhh
     /tmp/cclLq83w.s:6429   .progmem.data:000000000000002b _ZL11numbertable
     /tmp/cclLq83w.s:6306   .bss:0000000000000012 display
     /tmp/cclLq83w.s:6210   .bss:0000000000000002 region
     /tmp/cclLq83w.s:1285   .text:00000000000004fc _Z8set_timev
     /tmp/cclLq83w.s:6366   .bss:0000000000000028 timeoutcounter
     /tmp/cclLq83w.s:6348   .bss:0000000000000025 just_pressed
     /tmp/cclLq83w.s:6354   .bss:0000000000000026 pressed
     /tmp/cclLq83w.s:6282   .bss:000000000000000e displaymode
     /tmp/cclLq83w.s:1652   .text:0000000000000708 _Z13display_alarmhh
     /tmp/cclLq83w.s:6400   .progmem.data:0000000000000011 _ZL10alphatable
     /tmp/cclLq83w.s:1836   .text:00000000000007bc _Z9set_alarmv
     /tmp/cclLq83w.s:2134   .text:0000000000000960 _Z11display_strPKc
     /tmp/cclLq83w.s:2279   .text:00000000000009ba _Z12display_dateh
     /tmp/cclLq83w.s:2798   .text:0000000000000c5c _Z8set_datev
     /tmp/cclLq83w.s:6446   .progmem.data:000000000000003f _ZZ8set_datevE3__c
     /tmp/cclLq83w.s:3230   .text:0000000000000e94 _Z13setalarmstatev
     /tmp/cclLq83w.s:6258   .bss:000000000000000a alarm_on
     /tmp/cclLq83w.s:6330   .bss:0000000000000020 snoozetimer
     /tmp/cclLq83w.s:6264   .bss:000000000000000b alarming
     /tmp/cclLq83w.s:6442   .progmem.data:0000000000000035 _ZZ13setalarmstatevE3__c
     /tmp/cclLq83w.s:3342   .text:0000000000000f1a __vector_1
     /tmp/cclLq83w.s:3438   .text:0000000000000f8c _Z6wakeupv
     /tmp/cclLq83w.s:6490   .progmem.data:00000000000000b6 _ZZ6wakeupvE3__c
     /tmp/cclLq83w.s:3583   .text:000000000000100e _Z10set_regionv
     /tmp/cclLq83w.s:3751   .text:00000000000010c8 _Z10set_volumev
     /tmp/cclLq83w.s:3982   .text:00000000000011f8 _Z14set_brightnessv
     /tmp/cclLq83w.s:4422   .text:00000000000013b2 __vector_9
     /tmp/cclLq83w.s:6294   .bss:0000000000000010 timeunknown
     /tmp/cclLq83w.s:6502   .progmem.data:00000000000000cb _ZZ10__vector_9E3__c
     /tmp/cclLq83w.s:6360   .bss:0000000000000027 buttonholdcounter
     /tmp/cclLq83w.s:4800   .text:00000000000015f4 _Z9setsnoozev
     /tmp/cclLq83w.s:6518   .progmem.data:00000000000000de _ZZ9setsnoozevE3__c
     /tmp/cclLq83w.s:4853   .text:0000000000001626 __vector_3
     /tmp/cclLq83w.s:6342   .bss:0000000000000024 last_buttonstate
     /tmp/cclLq83w.s:6506   .progmem.data:00000000000000d5 _ZZ10__vector_3E3__c
     /tmp/cclLq83w.s:4987   .text:00000000000016cc __vector_5
     /tmp/cclLq83w.s:6514   .progmem.data:00000000000000db _ZZ10__vector_5E3__c
     /tmp/cclLq83w.s:6510   .progmem.data:00000000000000d8 _ZZ10__vector_5E3__c_0
     /tmp/cclLq83w.s:5231   .text:00000000000017ec main
     /tmp/cclLq83w.s:6486   .progmem.data:00000000000000b4 _ZZ4mainE3__c
     /tmp/cclLq83w.s:6482   .progmem.data:00000000000000a9 _ZZ4mainE3__c_0
     /tmp/cclLq83w.s:6478   .progmem.data:0000000000000096 _ZZ4mainE3__c_1
     /tmp/cclLq83w.s:6474   .progmem.data:0000000000000083 _ZZ4mainE3__c_2
     /tmp/cclLq83w.s:6470   .progmem.data:000000000000007a _ZZ4mainE3__c_3
     /tmp/cclLq83w.s:6466   .progmem.data:000000000000006f _ZZ4mainE3__c_4
     /tmp/cclLq83w.s:6462   .progmem.data:0000000000000062 _ZZ4mainE3__c_5
     /tmp/cclLq83w.s:6458   .progmem.data:0000000000000057 _ZZ4mainE3__c_6
     /tmp/cclLq83w.s:6454   .progmem.data:000000000000004c _ZZ4mainE3__c_7
     /tmp/cclLq83w.s:6450   .progmem.data:0000000000000047 _ZZ4mainE3__c_8
     /tmp/cclLq83w.s:5736   .text:0000000000001a08 _Z8vfd_initv
     /tmp/cclLq83w.s:5761   .text:0000000000001a0e _Z8spi_xferh
     /tmp/cclLq83w.s:5790   .text:0000000000001a18 _Z8vfd_sendm
     /tmp/cclLq83w.s:5856   .text:0000000000001a4c _Z10setdisplayhh
     /tmp/cclLq83w.s:6377   .progmem.data:0000000000000000 _ZL10digittable
     /tmp/cclLq83w.s:6372   .bss:0000000000000029 t
     /tmp/cclLq83w.s:6389   .progmem.data:0000000000000009 _ZL12segmenttable
     /tmp/cclLq83w.s:6009   .text:0000000000001b10 __vector_16
     /tmp/cclLq83w.s:6318   .bss:000000000000001c muxdiv
     /tmp/cclLq83w.s:6312   .bss:000000000000001b currdigit
     /tmp/cclLq83w.s:6324   .bss:000000000000001e alarmdiv

UNDEFINED SYMBOLS
__eewr_byte_m328p
_Z13ROM_putstringPKch
__eerd_byte_m328p
__udivmodqi4
__udivmodhi4
__divmodsi4
__divmodhi4
_Z12uart_putcharc
_Z13uart_putw_hexj
_Z9uart_initj
__do_copy_data
__do_clear_bss
