   1               		.file	"util.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
  10               		.text
  11               	.Ltext0:
  86               	.global	_Z10delay_10ush
  88               	_Z10delay_10ush:
  89               		.stabd	46,0,0
   1:util.c        **** /***************************************************************************
   2:util.c        ****  Ice Tube Clock firmware August 13, 2009
   3:util.c        ****  (c) 2009 Limor Fried / Adafruit Industries
   4:util.c        **** 
   5:util.c        **** Permission is hereby granted, free of charge, to any person obtaining a copy
   6:util.c        **** of this software and associated documentation files (the "Software"), to deal
   7:util.c        **** in the Software without restriction, including without limitation the rights
   8:util.c        **** to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   9:util.c        **** copies of the Software, and to permit persons to whom the Software is
  10:util.c        **** furnished to do so, subject to the following conditions:
  11:util.c        **** 
  12:util.c        **** The above copyright notice and this permission notice shall be included in
  13:util.c        **** all copies or substantial portions of the Software.
  14:util.c        **** 
  15:util.c        **** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:util.c        **** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  17:util.c        **** FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  18:util.c        **** AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  19:util.c        **** LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  20:util.c        **** OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  21:util.c        **** THE SOFTWARE.
  22:util.c        **** ****************************************************************************/
  23:util.c        **** 
  24:util.c        **** #include <avr/io.h>
  25:util.c        **** #include <avr/interrupt.h>
  26:util.c        **** #include <util/delay.h>
  27:util.c        **** #include <avr/pgmspace.h>
  28:util.c        **** #include "util.h"
  29:util.c        **** 
  30:util.c        **** void delay_10us(uint8_t ns)
  31:util.c        **** {
  91               	.LM0:
  92               	.LFBB1:
  93               	/* prologue: function */
  94               	/* frame size = 0 */
  95               	/* stack size = 0 */
  96               	.L__stack_usage = 0
  97               	.LBB5:
  32:util.c        ****   uint8_t i;
  33:util.c        ****   
  34:util.c        ****   while (ns != 0) {
  99               	.LM1:
 100 0000 00C0      		rjmp .L2
 101               	.L4:
  35:util.c        ****     ns--;
 103               	.LM2:
 104 0002 8150      		subi r24,lo8(-(-1))
 105 0004 9EE1      		ldi r25,lo8(30)
 106               	.L3:
  36:util.c        ****     for (i=0; i< 30; i++) {
  37:util.c        ****       NOP;
 108               	.LM3:
 109               	/* #APP */
 110               	 ;  37 "util.c" 1
 111 0006 0000      		nop
 112               	 ;  0 "" 2
 113               	/* #NOAPP */
 114 0008 9150      		subi r25,lo8(-(-1))
  36:util.c        ****     for (i=0; i< 30; i++) {
 116               	.LM4:
 117 000a 01F4      		brne .L3
 118               	.L2:
  34:util.c        ****   while (ns != 0) {
 120               	.LM5:
 121 000c 8823      		tst r24
 122 000e 01F4      		brne .L4
 123               	/* epilogue start */
 124               	.LBE5:
  38:util.c        ****     }
  39:util.c        ****   }
  40:util.c        **** }
 126               	.LM6:
 127 0010 0895      		ret
 129               	.Lscope1:
 131               		.stabd	78,0,0
 134               	.global	_Z7delay_sh
 136               	_Z7delay_sh:
 137               		.stabd	46,0,0
  41:util.c        **** 
  42:util.c        **** void delay_s(uint8_t s) {
 139               	.LM7:
 140               	.LFBB2:
 141               	/* prologue: function */
 142               	/* frame size = 0 */
 143               	/* stack size = 0 */
 144               	.L__stack_usage = 0
  43:util.c        ****   while (s--) {
 146               	.LM8:
 147 0012 00C0      		rjmp .L7
 148               	.L8:
 149               	.LBB6:
 150               	.LBB7:
 152               	.Ltext1:
   1:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
   6:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
   9:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  12:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****      distribution.
  16:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  17:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  21:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  33:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** /* $Id: delay.h.in 2189 2010-10-13 09:39:34Z aboyapati $ */
  34:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  35:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  38:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #endif
  41:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  42:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  46:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** /** \file */
  47:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     \code
  49:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     \endcode
  53:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  54:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     used.
  58:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  59:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  68:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  77:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  81:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** */
  82:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  83:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #endif
  87:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  88:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #endif
  93:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  94:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #endif
  97:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  98:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** /**
  99:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    \ingroup util_delay
 100:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 101:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 102:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 103:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 104:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 105:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 106:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 107:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 108:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 109:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 110:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 111:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 112:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 113:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 114:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 115:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 116:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 117:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    no delay i.e., 0ms.
 118:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 119:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 120:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 121:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 122:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 123:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 124:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 125:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 126:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 127:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 128:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay
 129:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    although this will be deprecated in future.
 130:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 131:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****  */
 132:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** void
 133:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 134:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** {
 135:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 136:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	double __tmp ; 
 137:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && !defined(__DELAY_BACKWARD_COMPATIBLE__)
 138:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 139:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 140:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 141:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 142:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 143:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 144:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 145:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 146:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 147:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 148:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	#else
 149:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 		//round up by default
 150:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 151:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	#endif
 152:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 153:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 154               	.LM9:
 155 0014 2FEF      		 ldi r18,lo8(1599999)
 156 0016 39E6      	    ldi r19,hi8(1599999)
 157 0018 48E1      	    ldi r20,hlo8(1599999)
 158 001a 2150      	    1:subi r18,1
 159 001c 3040      	    sbci r19,0
 160 001e 4040      	    sbci r20,0
 161 0020 01F4      	    brne 1b
 162 0022 00C0      		rjmp .
 163 0024 0000      		nop
 164 0026 8150      		subi r24,lo8(-(-1))
 165               	.L7:
 166               	.LBE7:
 167               	.LBE6:
 169               	.Ltext2:
 171               	.LM10:
 172 0028 8823      		tst r24
 173 002a 01F4      		brne .L8
 174               	/* epilogue start */
  44:util.c        ****     _delay_ms(1000);
  45:util.c        ****   }
  46:util.c        **** }
 176               	.LM11:
 177 002c 0895      		ret
 179               	.Lscope2:
 181               		.stabd	78,0,0
 184               	.global	_Z9uart_initj
 186               	_Z9uart_initj:
 187               		.stabd	46,0,0
  47:util.c        **** 
  48:util.c        **** void uart_init(uint16_t BRR) {
 189               	.LM12:
 190               	.LFBB3:
 191               	/* prologue: function */
 192               	/* frame size = 0 */
 193               	/* stack size = 0 */
 194               	.L__stack_usage = 0
  49:util.c        ****   /* setup the main UART */
  50:util.c        ****   UBRR0 = BRR;               // set baudrate counter
 196               	.LM13:
 197 002e 9093 C500 		sts 196+1,r25
 198 0032 8093 C400 		sts 196,r24
  51:util.c        **** 
  52:util.c        ****   UCSR0B = _BV(RXEN0) | _BV(TXEN0);
 200               	.LM14:
 201 0036 88E1      		ldi r24,lo8(24)
 202 0038 8093 C100 		sts 193,r24
  53:util.c        ****   UCSR0C = _BV(USBS0) | (3<<UCSZ00);
 204               	.LM15:
 205 003c 8EE0      		ldi r24,lo8(14)
 206 003e 8093 C200 		sts 194,r24
  54:util.c        ****   DDRD |= _BV(PD1);
 208               	.LM16:
 209 0042 519A      		sbi 42-32,1
  55:util.c        ****   DDRD &= ~_BV(PD0);
 211               	.LM17:
 212 0044 5098      		cbi 42-32,0
 213               	/* epilogue start */
  56:util.c        **** 
  57:util.c        **** }
 215               	.LM18:
 216 0046 0895      		ret
 218               	.Lscope3:
 220               		.stabd	78,0,0
 223               	.global	_Z12uart_putcharc
 225               	_Z12uart_putcharc:
 226               		.stabd	46,0,0
  58:util.c        **** 
  59:util.c        **** int uart_putchar(char c)
  60:util.c        **** {
 228               	.LM19:
 229               	.LFBB4:
 230               	/* prologue: function */
 231               	/* frame size = 0 */
 232               	/* stack size = 0 */
 233               	.L__stack_usage = 0
 234               	.L11:
  61:util.c        ****   loop_until_bit_is_set(UCSR0A, UDRE0);
 236               	.LM20:
 237 0048 9091 C000 		lds r25,192
 238 004c 95FF      		sbrs r25,5
 239 004e 00C0      		rjmp .L11
  62:util.c        ****   UDR0 = c;
 241               	.LM21:
 242 0050 8093 C600 		sts 198,r24
  63:util.c        ****   return 0;
  64:util.c        **** }
 244               	.LM22:
 245 0054 80E0      		ldi r24,lo8(0)
 246 0056 90E0      		ldi r25,hi8(0)
 247               	/* epilogue start */
 248 0058 0895      		ret
 250               	.Lscope4:
 252               		.stabd	78,0,0
 254               	.global	_Z12uart_getcharv
 256               	_Z12uart_getcharv:
 257               		.stabd	46,0,0
  65:util.c        **** 
  66:util.c        **** char uart_getchar(void) {
 259               	.LM23:
 260               	.LFBB5:
 261               	/* prologue: function */
 262               	/* frame size = 0 */
 263               	/* stack size = 0 */
 264               	.L__stack_usage = 0
 265               	.L14:
  67:util.c        **** 	while (!(UCSR0A & _BV(RXC0)));
 267               	.LM24:
 268 005a 8091 C000 		lds r24,192
 269 005e 87FF      		sbrs r24,7
 270 0060 00C0      		rjmp .L14
  68:util.c        **** 	return UDR0;
 272               	.LM25:
 273 0062 8091 C600 		lds r24,198
 274               	/* epilogue start */
  69:util.c        **** }
 276               	.LM26:
 277 0066 0895      		ret
 279               	.Lscope5:
 281               		.stabd	78,0,0
 283               	.global	_Z10uart_getchv
 285               	_Z10uart_getchv:
 286               		.stabd	46,0,0
  70:util.c        **** 
  71:util.c        **** char uart_getch(void) {
 288               	.LM27:
 289               	.LFBB6:
 290               	/* prologue: function */
 291               	/* frame size = 0 */
 292               	/* stack size = 0 */
 293               	.L__stack_usage = 0
  72:util.c        **** 	return (UCSR0A & _BV(RXC0));
 295               	.LM28:
 296 0068 8091 C000 		lds r24,192
  73:util.c        **** }
 298               	.LM29:
 299 006c 8078      		andi r24,lo8(-128)
 300               	/* epilogue start */
 301 006e 0895      		ret
 303               	.Lscope6:
 305               		.stabd	78,0,0
 309               	.global	_Z13ROM_putstringPKch
 311               	_Z13ROM_putstringPKch:
 312               		.stabd	46,0,0
  74:util.c        **** 
  75:util.c        **** void ROM_putstring(const char *str, uint8_t nl) {
 314               	.LM30:
 315               	.LFBB7:
 316 0070 EF92      		push r14
 317 0072 FF92      		push r15
 318 0074 1F93      		push r17
 319 0076 DF93      		push r29
 320 0078 CF93      		push r28
 321 007a 0F92      		push __tmp_reg__
 322 007c CDB7      		in r28,__SP_L__
 323 007e DEB7      		in r29,__SP_H__
 324               	/* prologue: function */
 325               	/* frame size = 1 */
 326               	/* stack size = 6 */
 327               	.L__stack_usage = 6
 328 0080 7C01      		movw r14,r24
 329               	.LBB8:
 330               	.LBB9:
  76:util.c        ****     uint8_t i;
  77:util.c        **** 
  78:util.c        ****     for (i=0; pgm_read_byte(&str[i]); i++) {
 332               	.LM31:
 333 0082 10E0      		ldi r17,lo8(0)
 334 0084 00C0      		rjmp .L18
 335               	.L19:
 336               	.LBB10:
  79:util.c        ****         uart_putchar(pgm_read_byte(&str[i]));
 338               	.LM32:
 339 0086 6983      		std Y+1,r22
 340 0088 0E94 0000 		call _Z12uart_putcharc
 341               	.LBE10:
  78:util.c        ****     for (i=0; pgm_read_byte(&str[i]); i++) {
 343               	.LM33:
 344 008c 1F5F      		subi r17,lo8(-(1))
 345 008e 6981      		ldd r22,Y+1
 346               	.L18:
 347               	.LBB11:
  78:util.c        ****     for (i=0; pgm_read_byte(&str[i]); i++) {
 349               	.LM34:
 350 0090 F701      		movw r30,r14
 351 0092 E10F      		add r30,r17
 352 0094 F11D      		adc r31,__zero_reg__
 353               	/* #APP */
 354               	 ;  78 "util.c" 1
 355 0096 8491      		lpm r24, Z
 356               		
 357               	 ;  0 "" 2
 358               	/* #NOAPP */
 359               	.LBE11:
 360 0098 8823      		tst r24
 361 009a 01F4      		brne .L19
 362               	.LBE9:
  80:util.c        ****   }
  81:util.c        ****   if (nl) {
 364               	.LM35:
 365 009c 6623      		tst r22
 366 009e 01F0      		breq .L17
  82:util.c        ****         uart_putchar('\n'); uart_putchar('\r');
 368               	.LM36:
 369 00a0 8AE0      		ldi r24,lo8(10)
 370 00a2 0E94 0000 		call _Z12uart_putcharc
 371 00a6 8DE0      		ldi r24,lo8(13)
 372 00a8 0E94 0000 		call _Z12uart_putcharc
 373               	.L17:
 374               	/* epilogue start */
 375               	.LBE8:
  83:util.c        ****   }
  84:util.c        **** }
 377               	.LM37:
 378 00ac 0F90      		pop __tmp_reg__
 379 00ae CF91      		pop r28
 380 00b0 DF91      		pop r29
 381 00b2 1F91      		pop r17
 382 00b4 FF90      		pop r15
 383 00b6 EF90      		pop r14
 384 00b8 0895      		ret
 392               	.Lscope7:
 394               		.stabd	78,0,0
 396               	.global	_Z9uart_putsPKc
 398               	_Z9uart_putsPKc:
 399               		.stabd	46,0,0
  85:util.c        **** 
  86:util.c        **** void uart_puts(const char* str)
  87:util.c        **** {
 401               	.LM38:
 402               	.LFBB8:
 403 00ba EF92      		push r14
 404 00bc FF92      		push r15
 405 00be CF93      		push r28
 406 00c0 DF93      		push r29
 407               	/* prologue: function */
 408               	/* frame size = 0 */
 409               	/* stack size = 4 */
 410               	.L__stack_usage = 4
 412               	.LM39:
 413 00c2 E82E      		mov r14,r24
 414 00c4 E701      		movw r28,r14
 415 00c6 7E01      		movw r14,r28
 416 00c8 F92E      		mov r15,r25
 417 00ca E701      		movw r28,r14
  88:util.c        ****     while(*str)
 419               	.LM40:
 420 00cc 00C0      		rjmp .L22
 421               	.L23:
  89:util.c        ****         uart_putc(*str++);
 423               	.LM41:
 424 00ce 0E94 0000 		call _Z12uart_putcharc
 425               	.L22:
  88:util.c        ****     while(*str)
 427               	.LM42:
 428 00d2 8991      		ld r24,Y+
 429 00d4 8823      		tst r24
 430 00d6 01F4      		brne .L23
 431               	/* epilogue start */
  90:util.c        **** }
 433               	.LM43:
 434 00d8 DF91      		pop r29
 435 00da CF91      		pop r28
 436 00dc FF90      		pop r15
 437 00de EF90      		pop r14
 438 00e0 0895      		ret
 440               	.Lscope8:
 442               		.stabd	78,0,0
 445               	.global	_Z13uart_putc_hexh
 447               	_Z13uart_putc_hexh:
 448               		.stabd	46,0,0
  91:util.c        **** 
  92:util.c        **** 
  93:util.c        **** void uart_putc_hex(uint8_t b)
  94:util.c        **** {
 450               	.LM44:
 451               	.LFBB9:
 452 00e2 1F93      		push r17
 453 00e4 CF93      		push r28
 454 00e6 DF93      		push r29
 455               	/* prologue: function */
 456               	/* frame size = 0 */
 457               	/* stack size = 3 */
 458               	.L__stack_usage = 3
 459 00e8 182F      		mov r17,r24
  95:util.c        ****     /* upper nibble */
  96:util.c        ****     if((b >> 4) < 0x0a)
 461               	.LM45:
 462 00ea C82F      		mov r28,r24
 463 00ec D0E0      		ldi r29,lo8(0)
 464 00ee 9E01      		movw r18,r28
 465 00f0 84E0      		ldi r24,4
 466 00f2 3595      	1:	asr r19
 467 00f4 2795      		ror r18
 468 00f6 8A95      		dec r24
 469 00f8 01F4      		brne 1b
 470 00fa 2A30      		cpi r18,10
 471 00fc 3105      		cpc r19,__zero_reg__
 472 00fe 04F4      		brge .L25
  97:util.c        ****         uart_putc((b >> 4) + '0');
 474               	.LM46:
 475 0100 822F      		mov r24,r18
 476 0102 805D      		subi r24,lo8(-(48))
 477 0104 00C0      		rjmp .L29
 478               	.L25:
  98:util.c        ****     else
  99:util.c        ****         uart_putc((b >> 4) - 0x0a + 'a');
 480               	.LM47:
 481 0106 822F      		mov r24,r18
 482 0108 895A      		subi r24,lo8(-(87))
 483               	.L29:
 484 010a 0E94 0000 		call _Z12uart_putcharc
 100:util.c        **** 
 101:util.c        ****     /* lower nibble */
 102:util.c        ****     if((b & 0x0f) < 0x0a)
 486               	.LM48:
 487 010e CF70      		andi r28,lo8(15)
 488 0110 D070      		andi r29,hi8(15)
 489 0112 812F      		mov r24,r17
 490 0114 8F70      		andi r24,lo8(15)
 491 0116 CA30      		cpi r28,10
 492 0118 D105      		cpc r29,__zero_reg__
 493 011a 04F4      		brge .L27
 103:util.c        ****         uart_putc((b & 0x0f) + '0');
 495               	.LM49:
 496 011c 805D      		subi r24,lo8(-(48))
 497 011e 00C0      		rjmp .L30
 498               	.L27:
 104:util.c        ****     else
 105:util.c        ****         uart_putc((b & 0x0f) - 0x0a + 'a');
 500               	.LM50:
 501 0120 895A      		subi r24,lo8(-(87))
 502               	.L30:
 503 0122 0E94 0000 		call _Z12uart_putcharc
 504               	/* epilogue start */
 106:util.c        **** }
 506               	.LM51:
 507 0126 DF91      		pop r29
 508 0128 CF91      		pop r28
 509 012a 1F91      		pop r17
 510 012c 0895      		ret
 512               	.Lscope9:
 514               		.stabd	78,0,0
 516               	.global	_Z13uart_putw_hexj
 518               	_Z13uart_putw_hexj:
 519               		.stabd	46,0,0
 107:util.c        **** 
 108:util.c        **** void uart_putw_hex(uint16_t w)
 109:util.c        **** {
 521               	.LM52:
 522               	.LFBB10:
 523 012e 1F93      		push r17
 524               	/* prologue: function */
 525               	/* frame size = 0 */
 526               	/* stack size = 1 */
 527               	.L__stack_usage = 1
 528 0130 182F      		mov r17,r24
 110:util.c        ****     uart_putc_hex((uint8_t) (w >> 8));
 530               	.LM53:
 531 0132 892F      		mov r24,r25
 532 0134 0E94 0000 		call _Z13uart_putc_hexh
 111:util.c        ****     uart_putc_hex((uint8_t) (w & 0xff));
 534               	.LM54:
 535 0138 812F      		mov r24,r17
 536 013a 0E94 0000 		call _Z13uart_putc_hexh
 537               	/* epilogue start */
 112:util.c        **** }
 539               	.LM55:
 540 013e 1F91      		pop r17
 541 0140 0895      		ret
 543               	.Lscope10:
 545               		.stabd	78,0,0
 548               	.global	_Z14uart_putdw_hexm
 550               	_Z14uart_putdw_hexm:
 551               		.stabd	46,0,0
 113:util.c        **** 
 114:util.c        **** void uart_putdw_hex(uint32_t dw)
 115:util.c        **** {
 553               	.LM56:
 554               	.LFBB11:
 555 0142 EF92      		push r14
 556 0144 FF92      		push r15
 557 0146 0F93      		push r16
 558 0148 1F93      		push r17
 559               	/* prologue: function */
 560               	/* frame size = 0 */
 561               	/* stack size = 4 */
 562               	.L__stack_usage = 4
 563 014a 7B01      		movw r14,r22
 564 014c 8C01      		movw r16,r24
 116:util.c        ****     uart_putw_hex((uint16_t) (dw >> 16));
 566               	.LM57:
 567 014e C801      		movw r24,r16
 568 0150 0E94 0000 		call _Z13uart_putw_hexj
 117:util.c        ****     uart_putw_hex((uint16_t) (dw & 0xffff));
 570               	.LM58:
 571 0154 C701      		movw r24,r14
 572 0156 0E94 0000 		call _Z13uart_putw_hexj
 573               	/* epilogue start */
 118:util.c        **** }
 575               	.LM59:
 576 015a 1F91      		pop r17
 577 015c 0F91      		pop r16
 578 015e FF90      		pop r15
 579 0160 EF90      		pop r14
 580 0162 0895      		ret
 582               	.Lscope11:
 584               		.stabd	78,0,0
 587               	.global	_Z13uart_putw_decj
 589               	_Z13uart_putw_decj:
 590               		.stabd	46,0,0
 119:util.c        **** 
 120:util.c        **** void uart_putw_dec(uint16_t w)
 121:util.c        **** {
 592               	.LM60:
 593               	.LFBB12:
 594 0164 AF92      		push r10
 595 0166 BF92      		push r11
 596 0168 CF92      		push r12
 597 016a DF92      		push r13
 598 016c EF92      		push r14
 599 016e FF92      		push r15
 600 0170 0F93      		push r16
 601 0172 1F93      		push r17
 602 0174 CF93      		push r28
 603 0176 DF93      		push r29
 604               	/* prologue: function */
 605               	/* frame size = 0 */
 606               	/* stack size = 10 */
 607               	.L__stack_usage = 10
 608 0178 8C01      		movw r16,r24
 609               	.LBB12:
 610               	.LBB13:
 122:util.c        ****     uint16_t num = 10000;
 123:util.c        ****     uint8_t started = 0;
 124:util.c        **** 
 125:util.c        ****     while(num > 0)
 126:util.c        ****     {
 127:util.c        ****         uint8_t b = w / num;
 128:util.c        ****         if(b > 0 || started || num == 1)
 129:util.c        ****         {
 130:util.c        ****             uart_putc('0' + b);
 131:util.c        ****             started = 1;
 132:util.c        ****         }
 133:util.c        ****         w -= b * num;
 134:util.c        **** 
 135:util.c        ****         num /= 10;
 612               	.LM61:
 613 017a 25E0      		ldi r18,lo8(5)
 614 017c E22E      		mov r14,r18
 615 017e F12C      		mov r15,__zero_reg__
 123:util.c        ****     uint8_t started = 0;
 617               	.LM62:
 618 0180 20E0      		ldi r18,lo8(0)
 122:util.c        ****     uint16_t num = 10000;
 620               	.LM63:
 621 0182 C0E1      		ldi r28,lo8(10000)
 622 0184 D7E2      		ldi r29,hi8(10000)
 624               	.LM64:
 625 0186 9AE0      		ldi r25,lo8(10)
 626 0188 C92E      		mov r12,r25
 627 018a D12C      		mov r13,__zero_reg__
 628               	.L37:
 127:util.c        ****         uint8_t b = w / num;
 630               	.LM65:
 631 018c C801      		movw r24,r16
 632 018e BE01      		movw r22,r28
 633 0190 0E94 0000 		call __udivmodhi4
 634 0194 B62E      		mov r11,r22
 128:util.c        ****         if(b > 0 || started || num == 1)
 636               	.LM66:
 637 0196 6623      		tst r22
 638 0198 01F4      		brne .L34
 128:util.c        ****         if(b > 0 || started || num == 1)
 640               	.LM67:
 641 019a 2223      		tst r18
 642 019c 01F4      		brne .L34
 128:util.c        ****         if(b > 0 || started || num == 1)
 644               	.LM68:
 645 019e C130      		cpi r28,1
 646 01a0 D105      		cpc r29,__zero_reg__
 647 01a2 01F4      		brne .L35
 648               	.L34:
 130:util.c        ****             uart_putc('0' + b);
 650               	.LM69:
 651 01a4 8B2D      		mov r24,r11
 652 01a6 805D      		subi r24,lo8(-(48))
 653 01a8 0E94 0000 		call _Z12uart_putcharc
 131:util.c        ****             started = 1;
 655               	.LM70:
 656 01ac 21E0      		ldi r18,lo8(1)
 657               	.L35:
 659               	.LM71:
 660 01ae CE01      		movw r24,r28
 661 01b0 B601      		movw r22,r12
 662 01b2 0E94 0000 		call __udivmodhi4
 663 01b6 0894      		sec
 664 01b8 E108      		sbc r14,__zero_reg__
 665 01ba F108      		sbc r15,__zero_reg__
 666               	.LBE13:
 125:util.c        ****     while(num > 0)
 668               	.LM72:
 669 01bc E114      		cp r14,__zero_reg__
 670 01be F104      		cpc r15,__zero_reg__
 671 01c0 01F0      		breq .L33
 672               	.LBB14:
 133:util.c        ****         w -= b * num;
 674               	.LM73:
 675 01c2 4B2D      		mov r20,r11
 676 01c4 50E0      		ldi r21,lo8(0)
 677 01c6 4C9F      		mul r20,r28
 678 01c8 C001      		movw r24,r0
 679 01ca 4D9F      		mul r20,r29
 680 01cc 900D      		add r25,r0
 681 01ce 5C9F      		mul r21,r28
 682 01d0 900D      		add r25,r0
 683 01d2 1124      		clr r1
 684 01d4 081B      		sub r16,r24
 685 01d6 190B      		sbc r17,r25
 687               	.LM74:
 688 01d8 A62E      		mov r10,r22
 689 01da E501      		movw r28,r10
 690 01dc 5E01      		movw r10,r28
 691 01de B72E      		mov r11,r23
 692 01e0 E501      		movw r28,r10
 693 01e2 00C0      		rjmp .L37
 694               	.L33:
 695               	/* epilogue start */
 696               	.LBE14:
 697               	.LBE12:
 136:util.c        ****     }
 137:util.c        **** }
 699               	.LM75:
 700 01e4 DF91      		pop r29
 701 01e6 CF91      		pop r28
 702 01e8 1F91      		pop r17
 703 01ea 0F91      		pop r16
 704 01ec FF90      		pop r15
 705 01ee EF90      		pop r14
 706 01f0 DF90      		pop r13
 707 01f2 CF90      		pop r12
 708 01f4 BF90      		pop r11
 709 01f6 AF90      		pop r10
 710 01f8 0895      		ret
 721               	.Lscope12:
 723               		.stabd	78,0,0
 726               	.global	_Z14uart_putdw_decm
 728               	_Z14uart_putdw_decm:
 729               		.stabd	46,0,0
 138:util.c        **** 
 139:util.c        **** void uart_putdw_dec(uint32_t dw)
 140:util.c        **** {
 731               	.LM76:
 732               	.LFBB13:
 733 01fa 4F92      		push r4
 734 01fc 5F92      		push r5
 735 01fe 6F92      		push r6
 736 0200 7F92      		push r7
 737 0202 8F92      		push r8
 738 0204 9F92      		push r9
 739 0206 AF92      		push r10
 740 0208 BF92      		push r11
 741 020a CF92      		push r12
 742 020c DF92      		push r13
 743 020e EF92      		push r14
 744 0210 FF92      		push r15
 745 0212 0F93      		push r16
 746 0214 1F93      		push r17
 747 0216 CF93      		push r28
 748 0218 DF93      		push r29
 749               	/* prologue: function */
 750               	/* frame size = 0 */
 751               	/* stack size = 16 */
 752               	.L__stack_usage = 16
 753 021a 5B01      		movw r10,r22
 754 021c 6C01      		movw r12,r24
 755               	.LBB15:
 756               	.LBB16:
 141:util.c        ****     uint32_t num = 1000000000;
 142:util.c        ****     uint8_t started = 0;
 143:util.c        **** 
 144:util.c        ****     while(num > 0)
 145:util.c        ****     {
 146:util.c        ****         uint8_t b = dw / num;
 147:util.c        ****         if(b > 0 || started || num == 1)
 148:util.c        ****         {
 149:util.c        ****             uart_putc('0' + b);
 150:util.c        ****             started = 1;
 151:util.c        ****         }
 152:util.c        ****         dw -= b * num;
 153:util.c        **** 
 154:util.c        ****         num /= 10;
 758               	.LM77:
 759 021e CAE0      		ldi r28,lo8(10)
 760 0220 D0E0      		ldi r29,hi8(10)
 142:util.c        ****     uint8_t started = 0;
 762               	.LM78:
 763 0222 4424      		clr r4
 141:util.c        ****     uint32_t num = 1000000000;
 765               	.LM79:
 766 0224 E12C      		mov r14,__zero_reg__
 767 0226 3AEC      		ldi r19,hi8(1000000000)
 768 0228 F32E      		mov r15,r19
 769 022a 3AE9      		ldi r19,hlo8(1000000000)
 770 022c 032F      		mov r16,r19
 771 022e 3BE3      		ldi r19,hhi8(1000000000)
 772 0230 132F      		mov r17,r19
 773               	.L42:
 146:util.c        ****         uint8_t b = dw / num;
 775               	.LM80:
 776 0232 C601      		movw r24,r12
 777 0234 B501      		movw r22,r10
 778 0236 A801      		movw r20,r16
 779 0238 9701      		movw r18,r14
 780 023a 0E94 0000 		call __udivmodsi4
 781 023e 922E      		mov r9,r18
 147:util.c        ****         if(b > 0 || started || num == 1)
 783               	.LM81:
 784 0240 2223      		tst r18
 785 0242 01F4      		brne .L39
 147:util.c        ****         if(b > 0 || started || num == 1)
 787               	.LM82:
 788 0244 4420      		tst r4
 789 0246 01F4      		brne .L39
 147:util.c        ****         if(b > 0 || started || num == 1)
 791               	.LM83:
 792 0248 81E0      		ldi r24,lo8(1)
 793 024a E816      		cp r14,r24
 794 024c F104      		cpc r15,__zero_reg__
 795 024e 0105      		cpc r16,__zero_reg__
 796 0250 1105      		cpc r17,__zero_reg__
 797 0252 01F4      		brne .L40
 798               	.L39:
 149:util.c        ****             uart_putc('0' + b);
 800               	.LM84:
 801 0254 892D      		mov r24,r9
 802 0256 805D      		subi r24,lo8(-(48))
 803 0258 0E94 0000 		call _Z12uart_putcharc
 150:util.c        ****             started = 1;
 805               	.LM85:
 806 025c 4424      		clr r4
 807 025e 4394      		inc r4
 808               	.L40:
 810               	.LM86:
 811 0260 C801      		movw r24,r16
 812 0262 B701      		movw r22,r14
 813 0264 2AE0      		ldi r18,lo8(10)
 814 0266 30E0      		ldi r19,hi8(10)
 815 0268 40E0      		ldi r20,hlo8(10)
 816 026a 50E0      		ldi r21,hhi8(10)
 817 026c 0E94 0000 		call __udivmodsi4
 818 0270 822E      		mov r8,r18
 819 0272 732E      		mov r7,r19
 820 0274 642E      		mov r6,r20
 821 0276 552E      		mov r5,r21
 822 0278 2197      		sbiw r28,1
 823               	.LBE16:
 144:util.c        ****     while(num > 0)
 825               	.LM87:
 826 027a 01F0      		breq .L38
 827               	.LBB17:
 152:util.c        ****         dw -= b * num;
 829               	.LM88:
 830 027c 692D      		mov r22,r9
 831 027e 70E0      		ldi r23,lo8(0)
 832 0280 80E0      		ldi r24,lo8(0)
 833 0282 90E0      		ldi r25,hi8(0)
 834 0284 A801      		movw r20,r16
 835 0286 9701      		movw r18,r14
 836 0288 0E94 0000 		call __mulsi3
 837 028c A61A      		sub r10,r22
 838 028e B70A      		sbc r11,r23
 839 0290 C80A      		sbc r12,r24
 840 0292 D90A      		sbc r13,r25
 842               	.LM89:
 843 0294 E82C      		mov r14,r8
 844 0296 F72C      		mov r15,r7
 845 0298 062D      		mov r16,r6
 846 029a 152D      		mov r17,r5
 847 029c 00C0      		rjmp .L42
 848               	.L38:
 849               	/* epilogue start */
 850               	.LBE17:
 851               	.LBE15:
 155:util.c        ****     }
 156:util.c        **** }
 853               	.LM90:
 854 029e DF91      		pop r29
 855 02a0 CF91      		pop r28
 856 02a2 1F91      		pop r17
 857 02a4 0F91      		pop r16
 858 02a6 FF90      		pop r15
 859 02a8 EF90      		pop r14
 860 02aa DF90      		pop r13
 861 02ac CF90      		pop r12
 862 02ae BF90      		pop r11
 863 02b0 AF90      		pop r10
 864 02b2 9F90      		pop r9
 865 02b4 8F90      		pop r8
 866 02b6 7F90      		pop r7
 867 02b8 6F90      		pop r6
 868 02ba 5F90      		pop r5
 869 02bc 4F90      		pop r4
 870 02be 0895      		ret
 881               	.Lscope13:
 883               		.stabd	78,0,0
 885               	.Letext0:
DEFINED SYMBOLS
                            *ABS*:0000000000000000 util.c
     /tmp/ccoRPNCW.s:2      *ABS*:000000000000003f __SREG__
     /tmp/ccoRPNCW.s:3      *ABS*:000000000000003e __SP_H__
     /tmp/ccoRPNCW.s:4      *ABS*:000000000000003d __SP_L__
     /tmp/ccoRPNCW.s:5      *ABS*:0000000000000034 __CCP__
     /tmp/ccoRPNCW.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccoRPNCW.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccoRPNCW.s:88     .text:0000000000000000 _Z10delay_10ush
     /tmp/ccoRPNCW.s:136    .text:0000000000000012 _Z7delay_sh
     /tmp/ccoRPNCW.s:186    .text:000000000000002e _Z9uart_initj
     /tmp/ccoRPNCW.s:225    .text:0000000000000048 _Z12uart_putcharc
     /tmp/ccoRPNCW.s:256    .text:000000000000005a _Z12uart_getcharv
     /tmp/ccoRPNCW.s:285    .text:0000000000000068 _Z10uart_getchv
     /tmp/ccoRPNCW.s:311    .text:0000000000000070 _Z13ROM_putstringPKch
     /tmp/ccoRPNCW.s:398    .text:00000000000000ba _Z9uart_putsPKc
     /tmp/ccoRPNCW.s:447    .text:00000000000000e2 _Z13uart_putc_hexh
     /tmp/ccoRPNCW.s:518    .text:000000000000012e _Z13uart_putw_hexj
     /tmp/ccoRPNCW.s:550    .text:0000000000000142 _Z14uart_putdw_hexm
     /tmp/ccoRPNCW.s:589    .text:0000000000000164 _Z13uart_putw_decj
     /tmp/ccoRPNCW.s:728    .text:00000000000001fa _Z14uart_putdw_decm

UNDEFINED SYMBOLS
__udivmodhi4
__udivmodsi4
__mulsi3
